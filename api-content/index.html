{"posts":[{"title":"树的各种遍历","content":" 二叉树的前序遍历 递归： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: def dfs(root): if not root: return res.append(root.val) dfs(root.left) dfs(root.right) res = [] dfs(root) return res 迭代: # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] q = [] while q or root: while root: res.append(root.val) q.append(root) root = root.left root = q.pop() root = root.right return res 二叉树的中序遍历 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: def dfs(root): if not root: return dfs(root.left) res.append(root.val) dfs(root.right) res = [] dfs(root) return res 迭代 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() res.append(root.val) root = root.right return res 二叉树的后序遍历 递归： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: def dfs(root): if not root: return dfs(root.left) dfs(root.right) res.append(root.val) res = [] dfs(root) return res 迭代： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: res, stack = [], [] prev = None while root or stack: while root: stack.append(root) root = root.left root = stack.pop() if not root.right or root.right == prev: res.append(root.val) prev = root root = None else: stack.append(root) root = root.right return res 二叉树的层序遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] res = [] q = [root] while q: n = len(q) level = [] for i in range(n): k = q.pop(0) level.append(k.val) if k.left: q.append(k.left) if k.right: q.append(k.right) res.append(level) return res ","link":"https://tudouvvv.github.io/post/shu-de-ge-chong-bian-li/"},{"title":"Top-100-liked-questions①","content":"1. Two Sum 思路：构建一个字典存储每个数的索引，然后从前往后判断即可。 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { if (nums.empty()) return vector&lt;int&gt; {-1, -1}; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i ++){ if (hash.count(target - nums[i])) return vector&lt;int&gt; {hash[target - nums[i]], i}; hash[nums[i]] = i; } return vector&lt;int&gt; {-1, -1}; } }; class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: if not nums: return [-1, -1] count = {} for i in range(len(nums)): if target - nums[i] in count: return [count[target - nums[i]], i] count[nums[i]] = i return [-1, -1] 2. Add Two Numbers 思路：模仿加法步骤，每次将进位存起来，然后创建虚拟头结点来避免边界情况判断，每次将两个数和进位加起来，创建val等于该值的节点，最后加完以后需要判断是否还有进位，如果有的话还要接在后面。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { auto dummy = new ListNode(-1); auto cur = dummy; int carry = 0; while (l1 || l2){ int n1 = l1 ? l1-&gt;val : 0; int n2 = l2 ? l2-&gt;val : 0; int sum = n1 + n2 + carry; carry = sum / 10; cur-&gt;next = new ListNode(sum % 10); cur = cur-&gt;next; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; } if (carry) cur-&gt;next = new ListNode(carry); return dummy-&gt;next; } }; /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { auto dummy = new ListNode(-1); auto cur = dummy; int carry = 0; while (l1 || l2 || carry){ if (l1) { carry += l1-&gt;val; l1 = l1-&gt;next; } if (l2) { carry += l2-&gt;val; l2 = l2-&gt;next; } cur -&gt; next = new ListNode(carry % 10); cur = cur-&gt;next; carry /= 10; } return dummy-&gt;next; } }; # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1, l2): dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next 3. Longest Substring Without Repeating Characters 思路：求不重复的字母的最长长度，可以用双指针来做，用一个hash来存储第一个指针路过每个单词出现的次数，如果次数超过一，第二个指针就往前走，直到次数重新变为1为止。 class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map&lt;char, int&gt; hash; int res = 0; for (int i = 0, j = 0; i &lt; s.size(); i++ ){ hash[s[i]] ++; while (hash[s[i]] &gt; 1) hash[s[j ++]] --; res = max(res, i - j + 1); } return res; } }; class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: count = {} j = 0 res = 0 for i in range(len(s)): if s[i] in count: count[s[i]] += 1 else: count[s[i]] = 1 while (count[s[i]] &gt; 1): count[s[j]] -= 1 j += 1 res = max(res, i - j + 1) return res ❌4. Median of Two Sorted Arrays 思路：第一下想到的解法就是合并两个数组，按照数据流的中位数那样做，即创建两个堆，一个大根堆一个小根堆，然后求解中位数，但是太慢了。题目要求log(m + n)的时间复杂度，估计要用二分等方法来做，先放放着。 class Solution { public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up; priority_queue&lt;int&gt; down; vector&lt;int&gt; nums; for (auto x : nums1) nums.push_back(x); for (auto x : nums2) nums.push_back(x); for (auto x : nums){ if(down.empty() || x &gt; down.top()) up.push(x); else{ down.push(x); up.push(down.top()); down.pop(); } if (up.size() &gt; down.size() + 1){ down.push(up.top()); up.pop(); } } if ((down.size() + up.size()) % 2 == 1) return up.top(); else return (down.top() + up.top()) * 0.5; } }; 5. Longest Palindromic Substring 思路：暴力做法，去枚举每个数为中心的时候，左右扩展找到最长的回文串。 ✅substr的第一个参数是起点， 第二个参数是长度 class Solution { public: string longestPalindrome(string s) { string res; for (int i = 0; i &lt; s.size(); i ++){ for (int j = i, k = i; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j --, k ++){ if (res.size() &lt; (k - j + 1)) res = s.substr(j, k - j + 1); } for (int j = i, k = i + 1; j &gt;= 0 &amp;&amp; k &lt;= s.size() &amp;&amp; s[j] == s[k]; j --, k ++){ if (res.size() &lt; (k - j + 1)) res = s.substr(j, k - j + 1); } } return res; } }; class Solution: def longestPalindrome(self, s: str) -&gt; str: i = 0 res = &quot;&quot; while i &lt; len(s): j, k = i, i while (j &gt;=0 and k &lt; len(s) and s[j] == s[k]): if len(res) &lt; k - j + 1: res = s[j : k + 1] j -= 1 k += 1 p, q = i, i+1 while (p &gt;= 0 and q &lt; len(s) and s[p] == s[q]): if len(res) &lt; q - p + 1: res = s[p : q + 1] p -= 1 q += 1 i += 1 return res 11. Container With Most Water 思路：首先肯定是要用双指针来做的，但是没有想出来怎么更新指针，不可能算出所有指针指向的结果吧。后来看了题解，假设左右指针分别是i和j，那么如果height[i] &gt; height[j]，就j往左移动，否则就移动i，证明过程这里 class Solution { public: int maxArea(vector&lt;int&gt;&amp; height) { int res = 0; for (int i = 0, j = height.size() - 1; i &lt; j;){ res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] &gt; height[j]) j --; else i ++; } return res; } }; class Solution: def maxArea(self, height: List[int]) -&gt; int: res = 0 i, j = 0, len(height) - 1 while i &lt; j: res = max(res, min(height[i], height[j]) * (j - i)) if height[i] &gt; height[j]: j -= 1 else: i += 1 return res 15. 3Sum 思路：首先排序整个数组，然后在确定第一个数字的前提下，用双指针算法i和j，分别指向该数字不同的下一个数字与末尾数字和，计算它们的和，如果&gt;0，则j往前走，如果&lt; 0，则i往后走，直到找到为0的情况，并且找到一组答案后，下一次开始的i和j不能指向相同的元素。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size(); i ++){ if (i &gt; 0 &amp;&amp; i &lt; nums.size() &amp;&amp; nums[i] == nums[i - 1]) continue; int l = i + 1, r = nums.size() - 1; while (l &lt; r){ int s = nums[i] + nums[l] + nums[r]; if (s &gt; 0) r --; else if (s &lt; 0) l ++; else{ res.push_back(vector&lt;int&gt;{nums[i], nums[l], nums[r]}); while(l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l ++; while(l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r --; l ++, r --; } } } return res; } }; 17. Letter Combinations of a Phone Number 思路：首先确定查找的字典chars，然后去遍历给的数字所代表的那串字母，每次都加在我们的答案后面。 class Solution { public: vector&lt;string&gt; letterCombinations(string digits) { if (digits.empty()) return vector&lt;string&gt; {}; vector&lt;string&gt; states (1, &quot;&quot;); string chars[8] = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}; for (auto u : digits) { vector&lt;string&gt; res; for (auto c : chars[u - '2']) for (auto s : states) res.push_back(s + c); states = res; } return states; } }; class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if not digits: return None; chars = ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'] states = [&quot;&quot;] for u in digits: res = [] for c in chars[int(u) - 2]: for s in states: res.append(s + c) states = res return states 19. Remove Nth Node From End of List 思路： 要删除某一个节点就是要找到该结点前面的那个节点，然后让他指向next的next即可，找的方法就是双指针。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto first = dummy, second = dummy; while (n --) first = first-&gt;next; while(first-&gt;next){ first = first -&gt; next; second = second-&gt;next; } second-&gt;next = second-&gt;next-&gt;next; return dummy-&gt;next; } }; # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: dummy = ListNode(-1) dummy.next = head first, second = dummy, dummy while (n &gt; 0): first = first.next n -= 1 while (first.next): first = first.next second = second.next second.next = second.next.next return dummy.next 20. Valid Parentheses 思路： ","link":"https://tudouvvv.github.io/post/top1/"},{"title":"做作的日常②","content":"179. Largest Number 题目描述： Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: &quot;210&quot; class Solution { public: static bool cmp(int a, int b){ string as = to_string(a), bs = to_string(b); return as + bs &gt; bs + as; } string largestNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end(), cmp); string res; for (auto x : nums) res += to_string(x); int k = 0; while (res[k] == '0') k ++; return k == res.size() ? &quot;0&quot; : res.substr(k, res.size()); } }; from functools import cmp_to_key class Solution: def largestNumber(self, nums: List[int]) -&gt; str: if not nums: return '' nums = map(str, nums) nums = sorted(nums, key = cmp_to_key(lambda a, b : int(a + b) - int (b + a)), reverse=True) return &quot;&quot;.join(nums).lstrip('0') or '0' ","link":"https://tudouvvv.github.io/post/zuo-zuo-de-ri-chang2/"},{"title":"剑指offer刷题-Week7","content":"80. 骰子的点数 题目描述：将一个骰子投掷n次，获得的总点数为s，s的可能范围为n~6n。 掷出某一点数，可能有多种掷法，例如投掷2次，掷出3点，共有[1,2],[2,1]两种掷法。 请求出投掷n次，掷出n~6n点分别有多少种掷法。 样例1 输入：n=1 输出：[1, 1, 1, 1, 1, 1] 解释：投掷1次，可能出现的点数为1-6，共计6种。每种点数都只有1种掷法。所以输出[1, 1, 1, 1, 1, 1]。 思路: 递归方法来做，我们用次数n和总和sum作为状态，sum的取值为n--6n. class Solution { public: vector&lt;int&gt; numberOfDice(int n) { vector&lt;int&gt; res; for (int i = n; i &lt;= 6 * n; i ++) res.push_back(dfs(n, i)); return res; } int dfs(int n, int sum){ if (sum &lt; 0) return 0; if (n == 0) return !sum; int res = 0; for(int i = 1; i &lt;= 6; i ++){ res += dfs(n - 1, sum - i); } return res; } }; 但是由于计算的状态太多，超时了。 2. 动态规划 class Solution { public: vector&lt;int&gt; numberOfDice(int n) { vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(6 * n + 1)); f[0][0] = 1; for (int i = 1; i &lt;= n; i ++) // 表示次数 for (int j = i; j &lt;= 6 * i; j ++) // 表示sum的取值 for (int k = 1; k &lt;= min(j ,6); k ++){ f[i][j] += f[i - 1][j - k]; // 状态转移 } vector&lt;int&gt; res; for (int i = n; i &lt;= 6 * n; i ++) res.push_back(f[n][i]); return res; } }; 79. 滑动窗口的最大值 题目描述：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。 例如，如果输入数组[2, 3, 4, 2, 6, 2, 5, 1]及滑动窗口的大小3,那么一共存在6个滑动窗口，它们的最大值分别为[4, 4, 6, 6, 6, 5]。 注意： 数据保证k大于0，且k小于等于数组长度。 样例 输入：[2, 3, 4, 2, 6, 2, 5, 1] , k=3 输出: [4, 4, 6, 6, 6, 5] 思路：我们维护一个双向单调队列，队列放的是元素的下标。我们假设该双端队列的队头是整个队列的最大元素所在下标，至队尾下标代表的元素值依次降低。初始时单调队列为空。随着对数组的遍历过程中，每次插入元素前，首先需要看队头是否还能留在队列中，如果队头下标距离i超过了k，则应该出队。同时需要维护队列的单调性，如果nums[i]大于或等于队尾元素下标所对应的值，则当前队尾再也不可能充当某个滑动窗口的最大值了，故需要队尾出队。始终保持队中元素从队头到队尾单调递减。依次遍历一遍数组，每次队头就是每个滑动窗口的最大值所在下标。 时间复杂度分析：每个元素最多入队出队一次，复杂度为O(n) class Solution { public: vector&lt;int&gt; maxInWindows(vector&lt;int&gt;&amp; nums, int k) { deque&lt;int&gt; q; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i ++){ while (q.size() &amp;&amp; nums[i] &gt; nums[q.back()]) q.pop_back(); // 维护单调性 if (q.size() &amp;&amp; i - q.front() &gt;= k) q.pop_front(); // 如果队头元素与下标距离超过k，则应该出队 q.push_back(i); if (i - k + 1 &gt;= 0) res.push_back(nums[q.front()]); } return res; } }; class Solution(object): def maxInWindows(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; res = [] if not nums: return res q = [] for i in range(len(nums)): while (len(q) and nums[i] &gt; nums[q[-1]]): q.pop(-1) if (len(q) and i - q[0] + 1 &gt; k): q.pop(0) q.append(i) if (i - k + 1 &gt;= 0): res.append(nums[q[0]]) return res 81. 扑克牌的顺子 题目描述：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。 2～10为数字本身，A为1，J为11，Q为12，K为13，大小王可以看做任意数字。 为了方便，大小王均以0来表示，并且假设这副牌中大小王均有两张。 样例1 输入：[8,9,10,11,12] 输出：true 思路： 1. 首先要计算出给定的数组中0的个数 其次需要知道不是顺子的条件：1）如果给定的牌中有对子，那么肯定不是顺子；2）如果两个牌之间的差值超过了0的个数，那么肯定也不是。 class Solution { public: bool isContinuous( vector&lt;int&gt; numbers ) { int n = numbers.size(); if (n &lt; 5) return false; sort(numbers.begin(), numbers.end()); int cnt = 0; for (int i = 0; i &lt; n - 1; i ++){ if (numbers[i] == 0) cnt ++; else { if (numbers[i + 1] == numbers[i]) return false; if (numbers[i + 1] - numbers[i] - 1 &gt; cnt) return false; cnt -= numbers[i + 1] - numbers[i] - 1; } } return true; } }; 一个总和为5的顺子，那么最大值与最小值之间的差距一定是5 class Solution { public: bool isContinuous( vector&lt;int&gt; numbers ) { if (numbers.empty()) return false; sort(numbers.begin(), numbers.end()); int k = 0; while (! numbers[k]) k ++; for (int i = k + 1; i &lt; numbers.size();i ++){ if (numbers[i] == numbers[i - 1]) return false; } return numbers.back() - numbers[k] &lt;= 4; } }; 82. 圆圈中最后剩下的数字 题目描述：0, 1, …, n-1这n个数字(n&gt;0)排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。 求出这个圆圈里剩下的最后一个数字。 样例 输入：n=5 , m=3 输出：3 思路: 每次需要计算出删除元素的索引值，然后删除即可。 class Solution { public: int lastRemaining(int n, int m){ if (n == 0 || m == 0) return -1; vector&lt;int&gt; res; for (int i = 0; i &lt; n; i ++) res.push_back(i); int pos = 0; while (res.size() &gt; 1){ pos = (pos + m - 1) % res.size(); res.erase(res.begin() + pos); } return res[0]; } }; class Solution(object): def lastRemaining(self, n, m): &quot;&quot;&quot; :type n: int :type m: int :rtype: int &quot;&quot;&quot; if n == 0 or m == 0: return -1; res = [i for i in range(n)] pos = 0 while len(res) &gt; 1: pos = (pos + m - 1) % len(res) res.pop(pos) return res[0] 83. 股票的最大利润 题目描述：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 一次 该股票可能获得的利润是多少？ 例如一只股票在某些时间节点的价格为[9, 11, 8, 5, 7, 12, 16, 14]。 如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。 样例 输入：[9, 11, 8, 5, 7, 12, 16, 14] 输出：11 思路: 构建一个数组，每个位置存的是当前元素之前的min(自己，自己之前的最小值)，最后算最大值的时候只需要遍历一次该数组就可以了。 class Solution { public: int maxDiff(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int n = nums.size(); vector&lt;int&gt; minnum(n); minnum[0] = nums[0]; for (int i = 1; i &lt; n; i ++){ if (nums[i] &lt; minnum[i - 1]) minnum[i] = nums[i]; else minnum[i] = minnum[i - 1]; } int res = 0; for (int i = 0; i &lt; n; i ++) res = max(res, nums[i] - minnum[i]); return res; } }; 也可以只维护一个最小值的变量就可以了。 class Solution { public: int maxDiff(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int res = 0; for (int i = 1, minv = nums[0]; i &lt; nums.size(); i ++){ res = max(res, nums[i] - minv); minv = min(minv, nums[i]); } return res; } }; 84. 求1+2+…+n 题目描述：求1+2+…+n,要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 样例 输入：10 输出：55 思路: 求和运算可以通过递归的方式来做，主要的问题就是我们的终止条件是什么，可以通过判断n是否为0来进行终止。 class Solution { public: int getSum(int n) { int sum = n; n &amp;&amp; (sum += getSum(--n)); return sum; } }; 85. 不用加减乘除做加法 题目描述：写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷ 四则运算符号。 样例 输入：num1 = 1 , num2 = 2 输出：3 思路: 1、两个整数做异或^，得到各位相加不进位的运算结果； 2、两个整数做与&amp;，然后再左移一位，即得到进位的运算结果； 3、将上面两个结果相加，即重复步骤1,2，直至进位的运算结果为0； class Solution { public: int add(int num1, int num2){ while (num2){ int sum = num1 ^ num2; int carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum, num2 = carry; } return num1; } }; 86. 构建乘积数组 题目描述：给定一个数组A[0, 1, …, n-1]，请构建一个数组B[0, 1, …, n-1]，其中B中的元素B[i]=A[0]×A[1]×… ×A[i-1]×A[i+1]×…×A[n-1]。 不能使用除法。 样例 输入：[1, 2, 3, 4, 5] 输出：[120, 60, 40, 30, 24] 思考题： 能不能只使用常数空间？（除了输出的数组之外） 思路： ","link":"https://tudouvvv.github.io/post/jian-zhi-offer-shua-ti-week7/"},{"title":"剑指offer刷题-Week6","content":"68. 0到n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。 在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 样例 输入：[0,1,2,4] 输出：3 思路: 第一眼看到这道题就想到用前n个数字的和去求。 class Solution { public: int getMissingNumber(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int count = n * (n + 1) &gt;&gt; 1; int res = 0; for (x : nums) res += x; return count - res; } }; 可是谁又能想到这道题竟然也可以用二分的方式来做呢。❓❓❓因为数组下标的关系，所以正常的序列当前值就是下标的值，同通过这个判断条件进行判断。 class Solution { public: int getMissingNumber(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int l = 0, r = nums.size() - 1; while (l &lt; r){ int mid = l + r &gt;&gt; 1; if (nums[mid] == mid) l = mid + 1; else r = mid; } if (nums[l] == l) l ++; // 当所有数都满足的时候，缺失就是n return l; } }; 69. 数组中数值和下标相等的元素 题目描述：假设一个单调递增的数组里的每个元素都是整数并且是唯一的。 请编程实现一个函数找出数组中任意一个数值等于其下标的元素。 例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。 样例 输入：[-3, -1, 1, 3, 5] 输出：3 注意:如果不存在，则返回-1。 思路： 直接遍历，复杂度O(n); class Solution { public: int getNumberSameAsIndex(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return -1; for (int i = 0; i &lt; nums.size(); i ++){ if (nums[i] == i) return i; } return -1; } }; 又一次没想到这道题可以用二分来做，由于给的数组是单调递增的，所以在答案的左边，肯定所有的元素都小于下标，右边所有的元素都大于下标。 class Solution { public: int getNumberSameAsIndex(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1; while (l &lt; r){ int mid = l + r &gt;&gt; 1; if (nums[mid] &gt;= mid) r = mid; else l = mid + 1; } if (nums[l] - l == 0) return nums[l]; return -1; } }; 70. 二叉搜索树的第k个结点 题目描述：给定一棵二叉搜索树，请找出其中的第k小的结点。 你可以假设树和k都存在，并且1≤k≤树的总结点数。 样例 输入：root = [2, 1, 3, null, null, null, null] ，k = 3 2 / \\ 1 3 输出：3 思路: 中序遍历该树即可，然后每次pop的时候记得k--，当k为0的时候就说明这就是我们要找的第k小的节点。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* kthNode(TreeNode* root, int k) { stack&lt;TreeNode*&gt; stk; auto p = root; while (p || stk.size()){ while (p){ stk.push(p); p = p-&gt;left; } if (stk.size()){ p = stk.top(); stk.pop(); k --; if (! k) return p; else { p = p -&gt; right; } } } return NULL; } }; 71. 二叉树的深度 题目描述：输入一棵二叉树的根结点，求该树的深度。 从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 样例 输入：二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示： 8 / \\ 12 2 / \\ 6 4 输出：3 思路： 遍历的时候，每次可以成功遍历的时候，深度 + 1, 存储一个全局的最深深度。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int ans = 0; int treeDepth(TreeNode* root) { if (! root) return 0; dfs(root, 1); return ans; } void dfs(TreeNode* root, int d){ if (root-&gt;left) dfs(root-&gt;left, d + 1); if (root-&gt;right) dfs(root-&gt;right, d + 1); ans = max(ans, d); } }; 可以用自己递归来做, 分别找到左节点和右节点的最大深度，然后max一下取最大值即可。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int treeDepth(TreeNode* root) { if (! root) return 0; return max(treeDepth(root-&gt;left) + 1, treeDepth(root-&gt;right) + 1); } }; 72. 平衡二叉树 题目描述: 输入一棵二叉树的根结点，判断该树是不是平衡二叉树。 如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 注意： 规定空树也是一棵平衡二叉树。 样例 输入：二叉树[5,7,11,null,null,12,9,null,null,null,null]如下所示， 5 / \\ 7 11 / \\ 12 9 输出：true 思路: 分别求出左右子树的深度，然后进行判断。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool ans = true; bool isBalanced(TreeNode* root) { dfs(root); return ans; } int dfs(TreeNode* root){ if (! root) return 0; auto left = dfs(root-&gt;left); auto right = dfs(root-&gt;right); if (abs(left-right) &gt; 1) ans = false; return max(left, right) + 1; } }; 73. 数组中只出现一次的两个数字 题目描述：一个整型数组里除了两个数字之外，其他的数字都出现了两次。 请写程序找出这两个只出现一次的数字。 你可以假设这两个数字一定存在。 样例 输入：[1,2,3,3,4,4] 输出：[1,2] 思路： 创一个hash存每个元素出现的次数，最后再遍历一遍，把次数为1的存起来就好了。 class Solution { public: vector&lt;int&gt; findNumsAppearOnce(vector&lt;int&gt;&amp; nums) { unordered_map &lt;int, int&gt; hash; vector&lt;int&gt; res; for (auto x : nums) hash[x] ++; for (item : hash){ if (item.second == 1) res.push_back(item.first); } return res; } }; 因为异或运算中，两个相同的数异或结果肯定为0，所以整个数组的异或结果就是两个不同的数的异或结果，寻找这个结果中为1的那位，根据这位为1，将数组分为两部分，这样两个不同的数就属于不同的集合，然后在每个集合中进行异或运算得到结果。 class Solution { public: vector&lt;int&gt; findNumsAppearOnce(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return vector&lt;int&gt; {}; int sum = 0; for (auto x : nums) sum ^= x; int k = 0; while (!(sum &gt;&gt; k &amp; 1)) k ++; int first = 0; for (auto x : nums){ if (x &gt;&gt; k &amp; 1) first ^= x; } return vector&lt;int&gt; {first, sum ^ first}; } }; 74. 数组中唯一只出现一次的数字 题目描述：在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。 请找出那个只出现一次的数字。 你可以假设满足条件的数字一定存在。 思考题： 如果要求只使用 O(n) 的时间和额外 O(1) 的空间，该怎么做呢？ 样例 输入：[1,1,1,2,2,2,3,4,4,4] 输出：3 思路: 由于是int型数，所有共有32位，我们统计每个位上0和1的个数，最后再模3，如果是1就说明出现一次的这个数该位是1，反之则是0，最后拼起来就好了。 class Solution { public: int findNumberAppearingOnce(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; sum(32); for (auto x : nums){ for (int i = 0; i &lt; 32; i ++){ int p = (x &gt;&gt; i &amp; 1); sum[i] += p; } } int res = 0; for (int i = 0; i &lt; 32; i ++){ res += (sum[i] % 3 == 0 ? 0 : 1) &lt;&lt; i; } return res; } }; update: 用位运算来做， 构造一个遇见三个一样的数就返回原状态的状态机。（这都是咋想出来的） class Solution { public: int findNumberAppearingOnce(vector&lt;int&gt;&amp; nums) { int ones = 0, twos = 0; for (auto x : nums){ ones = (ones ^ x) &amp; ~twos; twos = (twos ^ x) &amp; ~ones; } return ones; } }; 75. 和为S的两个数字 题目描述：输入一个数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。 如果有多对数字的和等于s，输出任意一对即可。 你可以认为每组输入中都至少含有一组满足条件的输出。 样例 输入：[1,2,3,4] , sum=7 输出：[3,4] 思路: 和leetcode的第一题一样，不同的是那道题存放的是索引，这道题可以存放每个数本身，然后进行判断即可。 class Solution { public: vector&lt;int&gt; findNumbersWithSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i ++){ if (hash.count(target - nums[i])) return {hash[target - nums[i]], nums[i]}; hash[nums[i]] = nums[i]; } } }; class Solution { public: vector&lt;int&gt; findNumbersWithSum(vector&lt;int&gt;&amp; nums, int target) { unordered_set&lt;int&gt; hash; for (int i = 0; i &lt; nums.size(); i ++){ if (hash.count(target - nums[i])) return {target - nums[i], nums[i]}; hash.insert(nums[i]); } } }; 76. 和为S的连续正数序列 题目描述: 输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。 例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。 样例 输入：15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] 分析：双指针算法，设两个指针i, j，然后i先不动，然后加上j并让j往后移动直到大于或等于sum，然后进行判断，等于sum的话，就把i到j的值输入到答案里面去，然后i向后移动一位，i到j的总和中减去i。 class Solution { public: vector&lt;vector&lt;int&gt; &gt; findContinuousSequence(int sum) { vector&lt;vector&lt;int&gt;&gt; res; for (int i = 1, j = 1, s = 1; i &lt;= sum / 2; i ++){ while (s &lt; sum) s += (++ j); if (s == sum){ vector&lt;int&gt; line; for (int k = i; k &lt;= j; k ++) line.push_back(k); res.push_back(line); } s -= i; } return res; } }; 77. 翻转单词顺序 题目描述：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 为简单起见，标点符号和普通字母一样处理。 例如输入字符串&quot;I am a student.&quot;，则输出&quot;student. a am I&quot;。 样例 输入：&quot;I am a student.&quot; 输出：&quot;student. a am I&quot; 分析：之前做leetcode的时候遇见过，不过这个比那个简单，那个前面还有空格，这个只需要把每个单词先翻转，然后翻转整个字符串即可。 class Solution { public: string reverseWords(string s) { if (s.empty()) return s; for (int i = 0; i &lt; s.size();i ++){ int j = i; while (j &lt; s.size() &amp;&amp; s[j] != ' ') j ++; reverse(s.begin() + i, s.begin() + j); i = j; } reverse(s.begin(), s.end()); return s; } }; class Solution(object): def reverseWords(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; s = s.split(' ')[::-1] return ' '.join(s) 78. 左旋转字符串 题目描述: 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。 请定义一个函数实现字符串左旋转操作的功能。 比如输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转2位得到的结果&quot;cdefgab&quot;。 注意： 数据保证n小于等于输入字符串的长度。 样例 输入：&quot;abcdefg&quot; , n=2 输出：&quot;cdefgab&quot; class Solution { public: string leftRotateString(string str, int n) { return str.substr(n) + str.substr(0, n); } }; ","link":"https://tudouvvv.github.io/post/jian-zhi-offer-shua-ti-week6/"},{"title":"剑指offer刷题-Week5(1道没有做)","content":"57. 数字序列中某一位的数字 题目描述：数字以0123456789101112131415…的格式序列化到一个字符序列中。 在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数求任意位对应的数字。 样例 输入：13 输出：1 思路： 首先确定它是几位数 确定是几位数的第几个数 确定是那个数的第几位 class Solution { public: int digitAtIndex(int n) { long long i = 1, s = 9, base = 1; // i 表示几位数，s表示该位共有几个数字，base表示该位的起始数字是几 while (n &gt; i * s){ n -= i * s; i ++; s *= 10; base *= 10; } int number = base + (n + i - 1) / i - 1; // 这里应该n/i上取整，但是c++中没有上取整，所以用n+i-1代替 int r = n % i ? n % i : i; for (int j = 0; j &lt; i - r; j ++) number /= 10; // 已经知道是哪个数字，并且也知道是哪一位，只需要把后面的删掉就可以了 // 比如number=23432，r=2，我们要求的就是3，把后三位删掉，即i-r位删掉 return number % 10; } }; class Solution: def findNthDigit(self, n: int) -&gt; int: i, s, base = 1, 9, 1 while n &gt; i * s: n -= i * s i += 1 s *= 10 base *= 10 number = base + int ((n + i - 1) / i ) - 1 r = n % i if n % i else i; for j in range(i - r): number /= 10 return int (number % 10) ps. leetcode400 58. 把数组排成最小的数 题目描述： 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 例如输入数组[3, 32, 321]，则打印出这3个数字能排成的最小数字321323。 样例 输入：[3, 32, 321] 输出：321323 注意：输出数字的格式为字符串。 思路：这道题本来想的是先寻找所有可能的取值，然后在进行大小的比较，后来超时了。 看到的做法是定义一个新的排序规则，str(a) + str(b) &lt; str(b) + str(a)，这样的话就会使得最小的数排在前面，然后拼起来就好了。 class Solution { public: static bool cmp(int a, int b){ string as = to_string(a), bs = to_string(b); return as + bs &lt; bs + as; } string printMinNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end(), cmp); string res; for (auto x : nums) res += to_string(x); return res; } }; 59. 把数字翻译成字符串 题目描述：给定一个数字，我们按照如下规则把它翻译为字符串： 0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。 一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。 请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。 样例 输入：&quot;12258&quot; 输出：5 思路：这道题之前做过，可以用动态规划来做。 f[i]表示前i位数字有多少种不同的表示方式， class Solution: def getTranslationCount(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s); f = [0 for _ in range(n + 2)] f[0] = 1 for i in range(1, n + 1): f[i] = f[i - 1] t = int(s[i - 1]) + int(s[i - 2]) * 10 if (t &gt;= 10 and t &lt;= 25): f[i] += f[i - 2] return f[i] class Solution { public: int getTranslationCount(string s) { int n = s.size(); vector&lt;int&gt; f(n + 1); f[0] = 1; for (int i = 1; i &lt;= n; i ++){ f[i] = f[i - 1]; if (i &gt; 1){ int t = (s[i - 1] - '0') + (s[i - 2] - '0') * 10; if (t &gt;= 10 &amp;&amp; t &lt;= 25) f[i] += f[i - 2]; } } return f[n]; } }; 60. 礼物的最大价值 题目描述：一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。 你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。 给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？ 注意： m, n &gt; 0 样例： 输入： [ [2,3,1], [1,7,1], [4,6,1] ] 输出：19 解释：沿着路径 2→3→7→6→1 可以得到拿到最大价值礼物。 思路：因为只能向右或者向下走，所以每个点的状态只能通过它上面的格子或者左边的格子转移过来。 class Solution { public: int getMaxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt; (m + 1)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]) + grid[i - 1][j - 1]; } return f[n][m]; } }; 61. 最长不含重复字符的子字符串 题目描述：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 假设字符串中只包含从’a’到’z’的字符。 样例 输入：&quot;abcabc&quot; 输出：3 思路: 两个指针，一个一直往前走，用字典存储它里面每个字母出现的次数，如果遇见了之前遇见的，那么另一个指针就往前走，直到该字母的出现次数再度变为一。 class Solution { public: int longestSubstringWithoutDuplication(string s) { unordered_map &lt;char, int&gt; hash; int res = 0; for (int i = 0, j = 0; i &lt; s.size(); i ++){ hash[s[i]] ++; while (hash[s[i]] &gt; 1) hash[s[j ++]] --; res = max(res, i - j + 1); } return res; } }; 62. 丑数 题目描述：我们把只包含质因子2、3和5的数称作丑数（Ugly Number）。 例如6、8都是丑数，但14不是，因为它包含质因子7。 求第n个丑数的值。 样例 输入：5 输出：5 注意：习惯上我们把1当做第一个丑数。 思路: 用三个指针指向1，三个指针分别代表2， 3， 5，每次让它们与它们指向的元素相乘，取最小的添加到我们的丑数序列中，然后指针向后移一位。 class Solution { public: int getUglyNumber(int n) { vector&lt;int&gt; q(1, 1); int i = 0, j = 0, k = 0; while (-- n){ int t = min(q[i] * 2, min(q[j] * 3, q[k] * 5)); q.push_back(t); if (t == q[i] * 2) i ++; if (t == q[j] * 3) j ++; if (t == q[k] * 5) k ++; } return q.back(); } }; 63. 字符串中第一个只出现一次的字符 题目描述: 在字符串中找出第一个只出现一次的字符。 如输入&quot;abaccdeff&quot;，则输出b。 如果字符串中不存在只出现一次的字符，返回#字符。 样例： 输入：&quot;abaccdeff&quot; 输出：'b' 思路: 用一个字典来储存每个元素出现的次数，然后再遍历这个字典，发现次数为一的直接返回，否则返回#，因为遍历字典的时候就是按照从前往后的顺序。 class Solution { public: char firstNotRepeatingChar(string s) { unordered_map&lt;char, int&gt; hash; for (auto x : s) hash[x] ++; for (c : s) { if (hash[c] == 1) return c; } return '#'; } }; 64. 字符流中第一个只出现一次的字符 题目描述: 请实现一个函数用来找出字符流中第一个只出现一次的字符。 例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。 当从该字符流中读出前六个字符”google”时，第一个只出现一次的字符是’l’。 如果当前字符流没有存在出现一次的字符，返回#字符。 样例 输入：&quot;google&quot; 输出：&quot;ggg#ll&quot; 解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。 思路：创建一个队列存放单独元素，创建一个hash存放每个元素出现的次数。如果发现次数大于一，那么就进行判断是否是队头元素，是队头元素的就pop掉直到队头元素次数为1。 class Solution{ public: unordered_map &lt;char, int&gt; hash; queue&lt;int&gt; q; //Insert one char from stringstream void insert(char ch){ if (++ hash[ch] &gt; 1){ while (q.size() &amp;&amp; hash[q.front()] &gt; 1) q.pop(); } else q.push(ch); } //return the first appearence once char in current stringstream char firstAppearingOnce(){ if (q.empty()) return '#'; else return q.front(); } }; class Solution: def __init__(self): self.hash = {} self.q = [] def firstAppearingOnce(self): &quot;&quot;&quot; :rtype: str &quot;&quot;&quot; if not self.q: return '#' return self.q[0] def insert(self, char): &quot;&quot;&quot; :type char: str :rtype: void &quot;&quot;&quot; self.hash[char] = self.hash.get(char, 0) + 1 if (self.hash[char] &gt; 1): while len(self.q) &gt; 0 and self.hash[self.q[0]] &gt; 1: self.q.pop(0) else: self.q.append(char) 66. 两个链表的第一个公共结点 之前做过这道题，Leetcode链表那节。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *findFirstCommonNode(ListNode *headA, ListNode *headB) { auto p = headA, q = headB; while (p != q){ if (p) p = p-&gt;next; else p = headB; if (q) q = q-&gt;next; else q = headA; } return p; } }; 67. 数字在排序数组中出现的次数 题目描述：统计一个数字在排序数组中出现的次数。 例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。 样例 输入：[1, 2, 3, 3, 3, 3, 4, 5] , 3 输出：4 思路：第一次看到准备用字典统计次数，然后输出即可。但是谁又能想到用两次二分呢。 class Solution { public: int getNumberOfK(vector&lt;int&gt;&amp; nums , int k) { if (nums.empty()) return 0; int l = 0, r = nums.size() - 1; while (l &lt; r){ int mid = l + r &gt;&gt; 1; if (nums[mid] &gt;= k) r= mid; else l = mid + 1; } if (nums[l] != k) return 0; int start = l; l = 0, r = nums.size() - 1; while (l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if (nums[mid] &lt;= k) l = mid; else r = mid - 1; } int end = r; return end - start + 1; } }; class Solution { public: int getNumberOfK(vector&lt;int&gt;&amp; nums , int k) { unordered_map&lt;int, int&gt; hash; for (auto x : nums) hash[x] ++; return hash[k]; } }; ","link":"https://tudouvvv.github.io/post/jian-zhi-offer-shua-ti-week5/"},{"title":"剑指offer刷题-Week4（1道不会做）","content":"46. 二叉搜索树的后序遍历序列 题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。 如果是则返回true，否则返回false。 假设输入的数组的任意两个数字都互不相同。 样例 输入：[4, 8, 6, 12, 16, 14, 10] 输出：true 思路：后序遍历的顺序是左右根，所以输入的最后一位肯定是根节点，然后输入的前面一部分小于根节点，是左子树；后面一部分大于跟节点，是右子树。先找到这个分界点，然后看后面这部分是否满足要求&gt;root，然后对左子树和右子树进行迭代即可。 class Solution { public: bool verifySequenceOfBST(vector&lt;int&gt; sequence) { if (sequence.empty()) return true; int l = 0, r = sequence.size() - 1; return dfs(sequence, l, r); } bool dfs(vector&lt;int&gt; &amp;sequence, int l, int r){ if (l &gt;= r) return true; auto root = sequence[r]; int k = 0; while (k &lt; r &amp;&amp; sequence[k] &lt; root) k++; for (int i = k; i &lt; r; i ++){ if (sequence[i] &lt; root) return false; } return dfs(sequence, l, k - 1) &amp;&amp; dfs(sequence, k, r - 1); } }; 47. 二叉树中和为某一值的路径 题目描述：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。 从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 样例 给出二叉树如下所示，并给出num=22。 5 / \\ 4 6 / / \\ 12 13 6 / \\ / \\ 9 1 5 1 输出：[[5,4,12,1],[5,6,6,5]] 思路：遍历一棵树，不同的是遍历的时候加了一些限制条件，需要找到一个从根节点开始到叶节点的路径，需要记录这个路径。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; findPath(TreeNode* root, int sum) { dfs(root, sum); return ans; } void dfs(TreeNode* root, int sum){ if (! root) return; path.push_back(root-&gt;val); sum -= root-&gt;val; if (! root-&gt;left &amp;&amp; ! root-&gt;right &amp;&amp; !sum) ans.push_back(path); dfs(root-&gt;left, sum); dfs(root-&gt;right, sum); path.pop_back(); sum += root-&gt;val; } }; 48. 复杂链表的复刻（Leecode138） 题目描述：请实现一个函数可以复制一个复杂链表。 在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者null。 注意： 函数结束后原链表要与输入时保持一致。 思路：题意就是让我们把一个复杂链表复制再返回，因为有额外指针的关系，我们可以这样来做： 首先每个节点可以在后面复制一个它，再接到下一个节点上，本来可能是1-&gt;2-&gt;3，现在变成了1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3，假如1.random = 3，那么现在，1.next.random = 1.random.next，之后再把下面这些多加的节点拿出来就好了。 /** * Definition for singly-linked list with a random pointer. * struct ListNode { * int val; * ListNode *next, *random; * ListNode(int x) : val(x), next(NULL), random(NULL) {} * }; */ class Solution { public: ListNode *copyRandomList(ListNode *head) { for (auto p = head; p;){ auto np = new ListNode(p-&gt;val); auto next = p-&gt;next; p-&gt;next = np; np-&gt;next= next; p = next; } for (auto p = head; p; p = p-&gt;next-&gt;next){ if (p-&gt;random) p-&gt;next-&gt;random = p-&gt;random-&gt;next; } auto dummy = new ListNode(-1); auto cur = dummy; for (auto p = head; p; p = p-&gt;next){ cur-&gt;next = p-&gt;next; cur = cur-&gt;next; p -&gt; next = p-&gt;next-&gt;next; } return dummy-&gt;next; } }; 49. 二叉搜索树与双向链表 题目描述: 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。 要求不能创建任何新的结点，只能调整树中结点指针的指向。 注意： 需要返回双向链表最左侧的节点。 例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。 思路: 二叉搜索树的中序遍历就是双向链表的顺序，唯一不同的是，在中序遍历的时候需要把当前节点的左指针指向前一个点，前一个点的右指针指向当前点。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* convert(TreeNode* root) { stack&lt;TreeNode*&gt; q; if (! root || (! root-&gt;left &amp;&amp; ! root-&gt;right)) return root; auto dummy = new TreeNode(0); auto head = dummy; while (root || q.size()){ if (root) q.push(root), root = root-&gt;left; else{ root = q.top(); q.pop(); auto cur = root; cur-&gt;left = dummy; dummy-&gt;right = cur; dummy = cur; root = root-&gt;right; } } head-&gt;right-&gt;left = NULL; return head-&gt;right; } }; 也可以通过递归的方式，设定一个pair，它存的是当前节点的子树的最左边的点和最右边的点，左子树需要把左子树的pair.second-&gt;right = root，root-&gt;left = pair.second，右子树同理。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* convert(TreeNode* root) { if (! root) return NULL; auto sides = dfs(root); return sides.first; } pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode * root){ if (!root-&gt;left &amp;&amp; !root-&gt;right) return {root, root}; if (root-&gt;left &amp;&amp; root-&gt;right){ auto lside = dfs(root-&gt;left), rside = dfs(root-&gt;right); lside.second-&gt;right = root, root-&gt;left = lside.second; rside.first-&gt;left = root, root-&gt;right = rside.first; return {lside.first, rside.second}; } if (root-&gt;left){ auto lside = dfs(root-&gt;left); lside.second-&gt;right = root, root-&gt;left = lside.second; return {lside.first, root}; } if (root-&gt;right){ auto rside = dfs(root-&gt;right); rside.first-&gt;left = root, root-&gt;right = rside.first; return {root, rside.second}; } } }; 50. 序列化二叉树 题目描述：请实现两个函数，分别用来序列化和反序列化二叉树。 您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。 样例 你可以序列化如下的二叉树 8 / \\ 12 2 / \\ 6 4 为：&quot;[8, 12, 2, null, null, 6, 4, null, null, null, null]&quot; 思路： 序列化按照中序遍历的顺序，从根开始，遇见空的就添加'#,'，否则就添加'root.val' + ','。 比较困难的是反序列化的步骤，需要判断各种情况： 遇见了'#'，那么返回NULL，向后跳两个字符 u += 2； 遇见了'-'，那么需要标记一下这是个负数，然后对字符进行恢复，比如从'123'恢复成123，在 c++ 中，可以这样: int t = 0, t = t * 10 + str[i]，最后在根据正负号确定节点的val 迭代 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string res; dfs_1(root, res); return res; } void dfs_1(TreeNode* root, string &amp;res){ if(!root) { res += &quot;#,&quot;; return; } res += to_string(root-&gt;val) + ','; dfs_1(root-&gt;left, res); dfs_1(root-&gt;right, res); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { int u = 0; return dfs_2(data, u); } TreeNode* dfs_2(string data, int &amp;u){ if (data[u] == '#'){ u += 2; return NULL; } int t = 0; bool is_minus = false; if (data[u] == '-'){ u ++; is_minus = true; } while (data[u] != ','){ t = t * 10 + data[u] - '0'; u ++; } u ++; if (is_minus) t = -t; auto root = new TreeNode(t); root-&gt;left = dfs_2(data, u); root-&gt;right = dfs_2(data, u); return root; } }; 使用python来写的话，可以用split函数把节点值都给分开。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; if not root: return 'None'; return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right); def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; self.i = -1 data = data.split(',') return self.dfs(data); def dfs(self, data): if self.i &gt;= len(data): return self.i += 1 root = None if data[self.i] != 'None': root = TreeNode(int(data[self.i])) root.left = self.dfs(data) root.right = self.dfs(data) return root 51. 数字排列 题目描述：输入一组数字（可能包含重复数字），输出其所有的排列方式。 样例 输入：[1,2,3] 输出： [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] class Solution { public: int n ; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;bool&gt; st; vector&lt;vector&lt;int&gt;&gt; permutation(vector&lt;int&gt;&amp; nums) { n = nums.size(); path = vector&lt;int&gt;(n); st = vector&lt;bool&gt;(n); sort(nums.begin(), nums.end()); dfs(nums, 0, 0); return ans; } void dfs(vector&lt;int&gt;&amp; nums, int u, int start){ if (u == n){ ans.push_back(path); return ; } for (int i = start; i &lt; n; i ++){ if (! st[i]){ st[i] = true; path[i] = nums[u]; dfs(nums, u + 1, nums[u] == nums[u + 1] ? i + 1 : 0); st[i] = false; } } } }; 52. 数组中出现次数超过一半的数字 题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 假设数组非空，并且一定存在满足条件的数字。 思考题： 假设要求只能使用 O(n) 的时间和额外 O(1) 的空间，该怎么做呢？ 样例 输入：[1,2,1,1,3] 输出：1 思路： 开心消消乐：首先取第一个元素为标记元素，记录次数n = 1，然后和后面的元素进行比较，一样的时候，次数加一，不一样的时候次数减一，当次数为0的时候，换标记元素为当前元素，记录次数n归一，继续，因为题目中告诉我们一定存在这样一个数字超过一半，所以这样消消乐下来，剩下的一定就是我们想要的。 class Solution { public: int moreThanHalfNum_Solution(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return NULL; if (nums.size() == 1) return nums[0]; int res = nums[0]; int n = 1; for (int i = 1; i &lt; nums.size(); i ++){ if (nums[i] == res) n ++; else n --; if (n == 0){ res = nums[i]; n = 1; } } return res; } }; 排序然后输出中间元素就是的，但是这样时间复杂度就不满足要求了。 53. 最小的k个数 题目描述:输入n个整数，找出其中最小的k个数。 注意： 数据保证k一定小于等于输入数组的长度; 输出数组内元素请按从小到大顺序排序; 样例 输入：[1,2,3,4,5,6,7,8] , k=4 输出：[1,2,3,4] 思路：创建一个大根堆，遍历输入元素，push进堆里，如果发现堆里元素超过了k，那么就pop掉，这样就能保证堆内元素一定是最小的k个。 class Solution { public: vector&lt;int&gt; getLeastNumbers_Solution(vector&lt;int&gt; input, int k) { priority_queue&lt;int&gt; heap; for (auto c : input){ heap.push(c); if (heap.size() &gt; k) heap.pop(); } vector&lt;int&gt; res; while (heap.size()){ res.push_back(heap.top()); heap.pop(); } reverse(res.begin(), res.end()); return res; } }; 54. 数据流中的中位数 题目描述：如何得到一个数据流中的中位数？ 如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。 如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 样例 输入：1, 2, 3, 4 输出：1,1.5,2,2.5 解释：每当数据流读入一个数据，就进行一次判断并输出当前的中位数。 思路: 构建一个对顶堆，上面是一个小根堆，存的是比较大的数，下面是一个大根堆，存的是比较小的数，保证小根堆最多只比大根堆多一个数，这样两个堆的top处存的就是中间的两个数，然后再判断奇偶就可以了。 class Solution { public: priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up; priority_queue &lt;int&gt; down; void insert(int num){ if (down.empty() || num &gt; down.top()) up.push(num); else{ down.push(num); up.push(down.top()); down.pop(); } if (up.size() &gt; down.size() + 1){ down.push(up.top()); up.pop(); } } double getMedian(){ if ((down.size() + up.size()) % 2 == 1) return up.top(); else return (down.top() + up.top()) / 2.; } }; 55. 连续子数组的最大和 题目描述：输入一个 非空 整型数组，数组里的数可能为正，也可能为负。 数组中一个或连续的多个整数组成一个子数组。 求所有子数组的和的最大值。 要求时间复杂度为O(n)。 样例 输入：[1, -2, 3, 10, -4, 7, 2, -5] 输出：18 思路： 只有前面的和对我是有益的（大于0），我才会去加它，否则就抛弃前面的所有数字。遍历整个数组，如果前面的数字大于0，那么就加上，相当于求一个前缀和，但是不同的是只看是否大于0，这样整个数组中最大的元素就是连续子数组的最大和； class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int ans = INT_MIN; for (int i = 1; i &lt; nums.size(); i ++){ if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1]; } for (auto x : nums){ ans = max(ans, x); } return ans; } }; 设定一个s表示前面n - 1位数字的和，每次加元素之前判断一下s是否大于0，如果小于0，那么归零s，从现在开始重新加。 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int s = 0, ans = INT_MIN; for (auto x : nums){ if (s &lt; 0) s = 0; s += x; ans = max(ans, s); } return ans; } }; 56. 从1到n整数中1出现的次数 题目描述：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。 例如输入12，从1到12这些整数中包含“1”的数字有1，10，11和12，其中“1”一共出现了5次。 样例 输入： 12 输出： 5 思路: 暴力搜索(❌)TLE了 class Solution { public: int numberOf1Between1AndN_Solution(int n) { if (n == 1) return 1; int cnt = 0; for (int i = 1; i &lt;= n; i ++){ auto tmp = to_string(i); for (auto x : tmp){ if (x == '1') cnt ++; } } return cnt; } }; ","link":"https://tudouvvv.github.io/post/jian-zhi-offer-shua-ti-week4/"},{"title":"剑指offer刷题-Week3","content":"35. 反转链表 题目描述：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 样例 输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路:之前做过这道题，每次反转两个，然后向后移一位，指导翻转完所有的，这个时候让尾部指向NULL, 即head -&gt; next = NULL, 然后设定新的头结点。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (! head) return head; auto a = head, b = head -&gt; next; while (b){ auto c = b -&gt; next; b -&gt; next = a; a = b, b = c; } head -&gt; next = NULL; head = a; return head; } }; 36. 合并两个排序的链表 输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 样例 输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5 输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5 思路: 设定一个新的空结点，每次l1和l2比较完，就在后面接上小的，最后比完后有可能两个链表还有一个不为空，把它接在后面即可。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* merge(ListNode* l1, ListNode* l2) { auto dummy = new ListNode(-1); auto cur = dummy; while (l1 != NULL &amp;&amp; l2 != NULL){ if (l1-&gt;val &lt; l2-&gt;val){ cur -&gt; next = l1; l1 = l1 -&gt; next; } else { cur -&gt; next = l2; l2 = l2 -&gt; next; } cur = cur -&gt; next; } if (l1 == NULL) cur -&gt; next = l2; else cur -&gt; next = l1; return dummy -&gt; next; } }; 37. 树的子结构 题目描述: 输入两棵二叉树A，B，判断B是不是A的子结构。 我们规定空树不是任何树的子结构。 样例 树A： 8 / \\ 8 7 / \\ 9 2 / \\ 4 7 树B： 8 / \\ 9 2 返回 true ,因为B是A的子结构。 思路：通过递归的方式来做，首先看根节点，不行就看左子树或者右子树；判断的时候要判断左右是否都能匹配。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool hasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { if (! pRoot1 || ! pRoot2) return false; if (isPart(pRoot1, pRoot2)) return true; return hasSubtree(pRoot1-&gt;left, pRoot2) || hasSubtree(pRoot1-&gt;right, pRoot2); } bool isPart(TreeNode* p, TreeNode* q){ if (! q) return true; if (! p || p-&gt;val != q-&gt;val) return false; return isPart(p-&gt;left, q-&gt;left) &amp;&amp; isPart(p-&gt;right, q-&gt;right); } }; 38. 二叉树的镜像 输入一个二叉树，将它变换为它的镜像。 样例 输入树： 8 / \\ 6 10 / \\ / \\ 5 7 9 11 [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] 输出树： 8 / \\ 10 6 / \\ / \\ 11 9 7 5 [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null] 思路：镜像就是从上往下，交换左右节点即可。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: void mirror(TreeNode* root) { if (! root) return ; swap(root-&gt;left, root-&gt;right); mirror(root-&gt;left); mirror(root-&gt;right); } }; 39. 对称的二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。 如果一棵二叉树和它的镜像一样，那么它是对称的。 样例 如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树： 1 / \\ 2 2 / \\ / \\ 3 4 4 3 如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树： 1 / \\ 2 2 \\ / \\ 4 4 3 思路：之前做过这道题，关于树的题，一般都是通过递归的方式，不断地深入直到叶节点为止。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (! root) return true; return dfs(root-&gt;left, root-&gt;right); } bool dfs(TreeNode* p, TreeNode* q){ if (!p || !q) return !p &amp;&amp; !q; if (p-&gt;val != q-&gt;val) return false; return dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); } }; 40. 顺时针打印矩阵 题目描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 样例 输入： [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 思路：定义一个顺时针的方向，然后就开始移动，每次出界或者是遇到了之前遇到的数字就换一个方向。换方向可以通过(d + 1) % 4来实现，因为只有四个方向hh. class Solution { public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { vector&lt;int&gt; res; if (matrix.empty() || matrix[0].empty()) return res; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m)); int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int x = 0, y = 0, d = 1; for (int k = 0; k &lt; n * m; k ++){ res.push_back(matrix[x][y]); st[x][y] = true; int a = x + dx[d], b = y + dy[d]; if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b]){ d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; } x = a, y = b; } return res; } }; 41. 包含min函数的栈 题目描述：设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。 push(x)–将元素x插入栈中 pop()–移除栈顶元素 top()–得到栈顶元素 getMin()–得到栈中最小元素 样例 MinStack minStack = new MinStack(); minStack.push(-1); minStack.push(3); minStack.push(-4); minStack.getMin(); --&gt; Returns -4. minStack.pop(); minStack.top(); --&gt; Returns 3. minStack.getMin(); --&gt; Returns -1. 思路：之前做过这道题，可以另开一个新栈存储最小值，第一个表示第一个数的最小的，第二个表示前两个数的最小值... class MinStack { public: stack&lt;int&gt; stk, min_stk; /** initialize your data structure here. */ MinStack() { } void push(int x) { stk.push(x); if (min_stk.empty()) min_stk.push(x); else min_stk.push(min(x, min_stk.top())); } void pop() { stk.pop(); min_stk.pop(); } int top() { return stk.top(); } int getMin() { return min_stk.top(); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 42. 栈的压入、弹出序列 题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。 假设压入栈的所有数字均不相等。 例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。 注意：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。 样例 输入：[1,2,3,4,5] [4,5,3,2,1] 输出：true 思路：由于输入输出都已经给了，所以只需要进行判断就可以了，开一个栈，每次压入元素，然后判断与输出的头元素是不是相同，相同的就pop，然后输出向后移一位在判断，不同的话就再压。如果输出的序列是正确的，那么栈最后应该为空，否则就是不正确的。 class Solution { public: bool isPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) { if (pushV.size() != popV.size()) return false; stack&lt;int&gt; stk; int i = 0; for (auto x : pushV){ stk.push(x); while (stk.size() &amp;&amp; stk.top() == popV[i]){ stk.pop(); i ++; } } return stk.empty(); } }; 43. 不分行从上往下打印二叉树 从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。 样例 输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null] 8 / \\ 12 2 / 6 / 4 输出：[8, 12, 2, 6, 4] 思路：先把根节点的值放进一个队列中，然后把它的值更新到res中，然后pop掉，顺便把它的左右儿子也push进队列中，遍历整个树。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;int&gt; printFromTopToBottom(TreeNode* root) { vector&lt;int&gt; res; queue&lt;TreeNode*&gt; q; if (! root) return res; q.push(root); while (q.size()){ auto t = q.front(); q.pop(); res.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t -&gt;right) q.push(t-&gt;right); } return res; } }; 44. 分行从上往下打印二叉树 题目描述：从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。 样例 输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null] 8 / \\ 12 2 / 6 / 4 输出：[[8], [12, 2], [6], [4]] 思路：相比较上一题，这道题就需要去遍历每一层的元素放进level，然后再push进最终的答案. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(q.size()){ vector&lt;int&gt; level; int t = q.size(); for (int i = 0; i &lt; t; i++){ auto k = q.front(); q.pop(); level.push_back(k-&gt;val); if (k-&gt;left) q.push(k-&gt;left); if (k-&gt;right) q.push(k-&gt;right); } res.push_back(level); } return res; } }; 45. 之字形打印二叉树 题目描述：请实现一个函数按照之字形顺序从上向下打印二叉树。 即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 样例 输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null] 8 / \\ 12 2 / \\ 6 4 输出：[[8], [2, 12], [6, 4]] 思路：改了一下上一道代码，最后添加一行判断的语句，因为只需要把偶数行的输出翻转就可以了。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(q.size()){ vector&lt;int&gt; level; int t = q.size(); for (int i = 0; i &lt; t; i++){ auto k = q.front(); q.pop(); level.push_back(k-&gt;val); if (k-&gt;left) q.push(k-&gt;left); if (k-&gt;right) q.push(k-&gt;right); } res.push_back(level); } int len = res.size(); for (int i = 0; i &lt; len; i ++){ if (i % 2 == 1) reverse(res[i].begin(), res[i].end()); } return res; } }; ","link":"https://tudouvvv.github.io/post/jian-zhi-offer-shua-ti-week3/"},{"title":"剑指offer刷题-Week2(2道题不会做)","content":"24. 机器人的运动范围 题目描述: 地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。 一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。 但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 请问该机器人能够达到多少个格子？ 样例 输入：k=18, m=40, n=40 输出：1484 解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。 但是，它不能进入方格（35,38），因为3+5+3+8 = 19。 注意: 0&lt;=m&lt;=50 0&lt;=n&lt;=50 0&lt;=k&lt;=100 分析：去枚举每个格子，要记得只能从合法格子进入非法格子，不能从非法格子进入合法格子。 class Solution { public: int movingCount(int threshold, int rows, int cols) { if (! rows || ! cols) return 0; int count = 1; // 表示格子状态 int st[rows][cols] = {0}; st[0][0] = 1; for (int i = 0; i &lt; rows; i ++) for (int j = 0; j &lt; cols; j ++) { int p = i / 10 + i % 10 + j / 10 + j % 10; // 只能从左边或者上边进入 if (p &lt;= threshold &amp;&amp; (st[i - 1][j] == 1 || st[i][j - 1] == 1)) { count ++; st[i][j] = 1; } } return count; } }; 也可以通过宽搜的方式来进行遍历： class Solution { public: int get_single(int x){ int s = x / 10 + x % 10; return s; } int get_sum(pair&lt;int, int&gt; p){ return get_single(p.first) + get_single(p.second); } int movingCount(int threshold, int rows, int cols) { if (! rows || ! cols) return 0; queue&lt;pair&lt;int, int&gt;&gt; q; vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols)); int res = 0; q.push({0, 0}); int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; while (q.size()){ auto t = q.front(); q.pop(); if (get_sum(t) &gt; threshold || st[t.first][t.second]) continue; res ++; st[t.first][t.second] = true; for (int i = 0; i &lt; 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols) q.push({x, y}); } } return res; } }; 25. 剪绳子 题目描述：给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。 每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？ 例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 样例 输入：8 输出：18 思路：尽可能分更多的3的绳子，if n &gt;= 5, 那么3 * (n - 3) = 3n - 9 &gt; n. class Solution { public: int maxProductAfterCutting(int n) { if (n &lt;= 3) return 1 * (n - 1); int res = 1; if (n % 3 == 1) { res *= 4; n -= 4; } if (n % 3 == 2) { res *= 2; n -= 2; } while (n) { res *= 3; n -= 3; } return res; } }; 26. 二进制中1的个数 题目描述：输入一个32位整数，输出该数二进制表示中1的个数。 注意： 负数在计算机中用其绝对值的补码来表示。 ps.什么叫补码呢？这得从原码，反码说起。 原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。 取反操作指：原为1，得0；原为0，得1。（1变0; 0变1） 样例1 输入：9 输出：2 解释：9的二进制表示是1001，一共有2个1。 样例2 输入：-2 输出：31 解释：-2在计算机里会被表示成11111111111111111111111111111110， 一共有31个1。 思路：每次与 1 &amp;，就相当于看看二进制末尾是不是1，然后右移一位，但是有个问题就是正数右移会在前面补0是ok的，但是负数会在前面补1，这样就会多算好多，所以可以把负数变为无符号整数，如果是正数不会变，如果是负数，那么会变为绝对值的反码，但是依然表示为正数，这样就可以了。 class Solution { public: int NumberOf1(int n) { int res = 0; unsigned int un = n; while (un){ res += un &amp; 1, un &gt;&gt;= 1; } return res; } }; 并且由于题目中说了这是一个32位的整数，所以也可以一位一位的进行判断： class Solution { public: int NumberOf1(int n) { int res = 0; for (int i = 32; i &gt; 0; i --){ res += n &gt;&gt; i &amp; 1; } return res; } }; 27. 数值的整数次方 题目描述: 实现函数double Power(double base, int exponent)，求base的 exponent次方。 不得使用库函数，同时不需要考虑大数问题。 注意： 不会出现底数和指数同为0的情况 样例1 输入：10 ，2 输出：100 样例2 输入：10 ，-2 输出：0.01 思路：就正常相乘就可以了，判断一下指数的正负，&lt; 0 的话翻一下就好了。 class Solution { public: double Power(double base, int exponent) { if (exponent == 0) return 1; if (exponent &gt; 0) return help(base, exponent); else return 1 / help(base, -exponent); } double help(double base, int exponent){ int k = base; while (-- exponent){ base *= k; } return base; } }; 也可以不用这么麻烦： class Solution { public: double Power(double base, int exponent) { double res = 1; bool minus = false; if (exponent &lt; 0) minus = true, exponent = -exponent; while (exponent --){ res *= base; } if (minus) return 1 / res; return res; } }; update: 快速幂 比如我们要求 a ^ b，加入b = 13, 那么二进制表示就是1101，即8 + 4 + 1, 所以a ^ b = a ^ 8 * a ^ 4 * a ^ 1, 这就表明当b的二进制位是1的时候，我们可以乘以a ^ 2 ^ 位数。 所以这道题也可以这样做： class Solution { public: double Power(double base, int exponent) { double res = 1, t = base; bool is_minus = false; if (exponent &lt; 0) is_minus = true, exponent = -exponent; while (exponent &gt; 0){ if (exponent &amp; 1) res *= t; t *= t; exponent &gt;&gt;= 1; } if (is_minus) return 1 / res; return res; } }; 快速幂模板： 求 m^k%p ，时间复杂度 O(logk)。 int qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k&amp;1) res = res * t % p; t = t * t % p; k &gt;&gt;= 1; } return res; } 28. 在O(1)时间删除链表结点 题目描述：给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。 假设链表一定存在，并且该节点一定不是尾节点。 思路：之前做过这道题，因为不知道它之前的节点，所以可以把它后面的节点赋值给它，然后删掉它后面的点，曲线救国。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; } }; 29. 删除链表中重复的节点 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。 样例1 输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 输出：1-&gt;2-&gt;5 样例2 输入：1-&gt;1-&gt;1-&gt;2-&gt;3 输出：2-&gt;3 思路：值得注意的重复的节点不会保留，所以头结点是会变的，需要创建虚拟头结点。需要两个指针，p指向一段末尾，q指向一段的开头，如果发现q的这一段长度大于一，那么q移动到另一段的开头，p直接指向q就可以删掉这一段。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplication(ListNode* head) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto p = dummy; while (p-&gt;next){ auto q = p-&gt;next; while (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next; if (p-&gt;next-&gt;next == q) p = p-&gt;next; else p-&gt;next = q; } return dummy-&gt;next; } }; 30. 正则表达式匹配 题目描述：请实现一个函数用来匹配包括'.'和''的正则表达式。 模式中的字符'.'表示任意一个字符，而''表示它前面的字符可以出现任意次（含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。 例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;abaca&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 样例 输入： s=&quot;aa&quot; p=&quot;a*&quot; 输出:true 32. 调整数组顺序使奇数位于偶数前面 题目描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序。 使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。 样例 输入：[1,2,3,4,5] 输出: [1,3,5,2,4] 思路：返回的顺序只要奇数在前，偶数在后面，不需要内部有序。设定两个指针，第一个l之前全是奇数，第二个r后面全是偶数，每次l++，r--，这样每次交换两个指针位置的数字即可。 class Solution { public: void reOrderArray(vector&lt;int&gt; &amp;array) { int l = 0, r = array.size(); while (l &lt; r){ while (l &lt; r &amp;&amp; array[l] % 2 == 1) l ++; while (l &lt; r &amp;&amp; array[r] % 2 == 0) r --; if (l &lt; r){ int tmp = array[l]; array[l] = array[r], array[r] = tmp; } } } }; class Solution(object): def reOrderArray(self, array): l, r = 0, len(array) - 1 while (l &lt; r): while (l &lt; r and array[l] % 2 == 1): l += 1 while (l &lt; r and array[r] % 2 == 0): r -= 1 if (l &lt; r): array[l], array[r] = array[r], array[l] 33. 链表中倒数第k个节点 题目描述: 输入一个链表，输出该链表中倒数第k个结点。 注意： k &gt;= 0; 如果k大于链表长度，则返回 NULL; 样例 输入：链表：1-&gt;2-&gt;3-&gt;4-&gt;5 ，k=2 输出：4 思路：倒数第k个就是正数第n - k个，所以先遍历一遍找出链表的长度，然后再遍历一遍，找到第n-k个返回即可。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* findKthToTail(ListNode* head, int k) { auto p = head; int n = 0; for (auto t = head; t; t = t-&gt;next) n++; if (k &gt; n) return NULL; for (int i = 0; i &lt; n - k; i ++) p = p-&gt;next; return p; } }; Update: 也可以用双指针算法来做 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* findKthToTail(ListNode* head, int k) { auto p = head, q = head; int n = 0; for (auto q = head; q; q = q-&gt;next) n ++; if (k &gt; n) return NULL; while (k --) p = p-&gt;next; while (p){ p = p -&gt; next; q = q-&gt;next; } return q; } }; 34. 链表中环的入口结点 题目描述：给定一个链表，若其中包含环，则输出环的入口节点。 若其中不包含环，则输出null。 思路：之前做过这道题，LC链表专题。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *entryNodeOfLoop(ListNode *head) { auto fast = head, slow = head; while (fast) { fast = fast -&gt; next; slow = slow -&gt; next; if (fast) fast = fast -&gt; next; else break; if (fast == slow){ slow = head; while (slow != fast) { slow = slow -&gt; next; fast = fast -&gt; next; } return slow; } } return NULL; } }; ","link":"https://tudouvvv.github.io/post/jian-zhi-offer-shua-ti-day2/"},{"title":"剑指offer刷题-Week1","content":"13. 找出数组中重复的数字 给定一个长度为 n 的整数数组 nums，数组中所有的数字都在 0∼n−1 的范围内。 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。 请找出数组中任意一个重复的数字。 注意：如果某些数字不在 0∼n−1 的范围内，或数组中不包含重复数字，则返回 -1； 样例 给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。 返回 2 或 3。 思路：刚开始看到这道题就想用字典来做，用字典存储每个数字出现的次数，然后&gt;1的话返回即可。 class Solution { public: unordered_map&lt;int, int&gt; hash; int duplicateInArray(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return -1; for (auto num : nums) { if (num &gt; 0 || num &lt; nums.size() - 1) hash[num] ++; else return -1; } int t = 0; for (int i = 0; i &lt; nums.size(); i ++) { t = max(t, hash[nums[i]]); if (t &gt; 1) return nums[i]; } if (t == 1) return -1; } }; 一个更妙的解题方法：因为一共有n个数，n个坑，所以可以把每个数放在属于自己的位置上，如果出现两个相同的数字，那么返回即可。 class Solution { public: int duplicateInArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (auto num : nums) { if (num &lt; 0 || num &gt; n - 1) return -1; } for (int i = 0; i &lt; n; i ++) { while (i != nums[i] &amp;&amp; nums[nums[i]] != nums[i]) swap(nums[i], nums[nums[i]]); if (i != nums[i] &amp;&amp; nums[i] == nums[nums[i]]) return nums[i]; } return -1; } }; update: class Solution(object): def duplicateInArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype int &quot;&quot;&quot; n = len(nums) for x in nums: if (x &lt; 0 or x &gt; n - 1): return -1 i = 0 for i in range(n): while (i != nums[i] and nums[nums[i]] != nums[i]): x, y = nums[i], nums[nums[i]] nums[nums[i]], nums[i] = x, y if (i != nums[i] and nums[i] == nums[nums[i]]): return nums[i] return -1 14. 不修改数组找出重复的数字 给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。 请找出数组中任意一个重复的数，但不能修改输入的数组。 样例 给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。 返回 2 或 3。 思考题：如果只能使用 O(1) 的额外空间，该怎么做呢？ 思路：之前做过这道题，用二分即可。 class Solution { public: int duplicateInArray(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return -1; int n = nums.size(); int l = 1, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; int cnt = 0; for (auto num : nums) { if (num &gt;= l &amp;&amp; num &lt;= mid) cnt ++; } if (cnt &gt; mid - l + 1) r = mid; else l = mid + 1; } return l; } }; update: class Solution(object): def duplicateInArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype int &quot;&quot;&quot; if not nums: return -1; l, r = 0, len(nums) - 1 while l &lt; r: mid = l + r &gt;&gt; 1; cnt = 0 for num in nums: if (num &gt;= l and num &lt;= mid): cnt += 1 if (cnt &gt; mid - l + 1): r = mid else: l = mid + 1 return l 15. 二维数组中的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 样例 输入数组： [ [1,2,8,9]， [2,4,9,12]， [4,7,10,13]， [6,8,11,15] ] 如果输入查找数值为7，则返回true， 如果输入查找数值为5，则返回false。 思路:刚开始看到这道题以为和LeetCode74一模一样，用二分写了，后来发现不一样hh。 一个很妙的方法：每次都用右上角(左下角)的点进行比较，因为这个点的左边一行比它小，下边一列比它大，所以如果大于它，那么可以去掉一行，小于它可以去掉一列，直到找到答案。 class Solution { public: bool searchArray(vector&lt;vector&lt;int&gt;&gt; array, int target) { if (array.empty() || array[0].empty()) return false; int i = 0, j = array[0].size() - 1; while (i &lt; array.size() &amp;&amp; j &gt;= 0) { if (array[i][j] == target) return true; if (array[i][j] &gt; target) j --; else i ++; } return false; } }; update: class Solution(object): def searchArray(self, array, target): &quot;&quot;&quot; :type array: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if (len(array) == 0 or len(array[0]) == 0): return False n = len(array) m = len(array[0]) i, j = 0, m - 1; while i &lt; n and j &gt;=0: if array[i][j] == target: return True if array[i][j] &gt; target: j -= 1 else: i += 1 return False 16. 替换空格 请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。 你可以假定输入字符串的长度最大是1000。 注意输出字符串的长度可能大于1000。 样例 输入：&quot;We are happy.&quot; 输出：&quot;We%20are%20happy.&quot; 思路：可以设定一个新的字符串，每次遇见空格就加'%20'，其它的就加上即可。 class Solution { public: string replaceSpaces(string &amp;str) { string res; for (auto c : str) { if (c == ' ') res += &quot;%20&quot;; else res += c; } return res; } }; 也可以首先计算出替换空格后的字符串长度，然后扩充原来的字符串，用两个指针直接在原字符串上进行修改。 class Solution { public: string replaceSpaces(string &amp;str) { int len = 0; for (auto c : str) { if (c == ' ') len += 3; else len += 1; } int i = str.size() - 1, j = len - 1; str.resize(len); while (i &gt;= 0) { if (str[i] == ' ') { str[j --] = '0'; str[j --] = '2'; str[j --] = '%'; } else str[j --] = str[i]; i --; } return str; } }; 当然用python来写肯定更简单 class Solution(object): def replaceSpaces(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; res = s.split(' ') return '%20'.join(res) 17. 从尾到头打印链表 题目描述:输入一个链表的头结点，按照从尾到头的顺序返回节点的值。 返回的结果用数组存储。 样例 输入：[2, 3, 5] 返回：[5, 3, 2] 思路：首先反转链表，最后遍历一次，把每个节点的值放进列表中即可。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector&lt;int&gt; printListReversingly(ListNode* head) { if (! head) return {}; vector&lt;int&gt; res; auto a = head, b = head -&gt;next; while (b) { auto c = b-&gt;next; b -&gt; next = a; a = b; b = c; } head -&gt; next = NULL; head = a; for (auto p = head; p; p = p-&gt;next) res.push_back(p-&gt;val); return res; } }; 也可以不用翻转列表，直接先得到正常顺序的节点值列表，然后翻转这个列表即可。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector&lt;int&gt; printListReversingly(ListNode* head) { vector &lt;int&gt; res; for (auto p = head; p; p = p-&gt;next) res.push_back(p-&gt;val); reverse(res.begin(), res.end()); return res; } }; 18. 重建二叉树 题目描述：输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。 注意: 二叉树中每个节点的值都互不相同； 输入的前序遍历和中序遍历一定合法； 样例 给定： 前序遍历是：[3, 9, 20, 15, 7] 中序遍历是：[9, 3, 15, 20, 7] 返回：[3, 9, 20, null, null, 15, 7, null, null, null, null] 返回的二叉树如下所示： 3 / \\ 9 20 / \\ 15 7 思路：之前做过这道题，因为前序遍历的第一个数字肯定是根节点，然后在中序遍历中找到这个数，那么它的左边就是左子树，右边就是右子树，然后不断递归即可。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: unordered_map &lt;int, int&gt; pos; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { int n = preorder.size(); for (int i = 0; i &lt; n; i ++) pos[inorder[i]] = i; return dfs(preorder, inorder, 0, n - 1, 0, n - 1); } TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir) { if (pl &gt; pr) return NULL; int val = preorder[pl]; int k = pos[val]; int len = k - il; auto root = new TreeNode(val); root-&gt;left = dfs(preorder, inorder, pl + 1, pl + len, il, k - 1); root-&gt;right = dfs(preorder, inorder, pl + len + 1, pr, k + 1, ir); return root; } }; 19. 二叉树的下一个节点 题目描述：给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。 注意： 如果给定的节点是中序遍历序列的最后一个，则返回空节点; 二叉树一定不为空，且给定的节点一定不是空节点； 样例 假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。 则应返回值等于3的节点。 解释：该二叉树的结构如下，2的后继节点是3。 2 / \\ 1 3 思路：树的后继：当前节点在中序遍历中的下一个节点，即整颗二叉搜索树中比我大的最小的元素。 要分情况讨论 如图，如果当前节点有右儿子，那么右子树最左侧的节点就是当前节点的后继，比如F的后继就是H； 如果没有的话，就要去寻找它的父节点的，如果当前节点是它父节点的左子树，那么它的父节点就是后继,比如H的后继就是E，否则，就一直向上寻找，比如D，它是它父节点的右子树，那么就继续向上找，直到找到是左子树的父节点，它的父节点是C，C是父节点F的左子树，所以F就是D的后继。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode *father; * TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {} * }; */ class Solution { public: TreeNode* inorderSuccessor(TreeNode* p) { if (p-&gt;right) { p = p-&gt;right; while (p-&gt;left) p = p-&gt;left; return p; } while (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father; return p-&gt;father; } }; 20. 用两个栈实现队列 题目描述: 请用栈实现一个队列，支持如下四种操作： push(x) – 将元素x插到队尾； pop() – 将队首的元素弹出，并返回该元素； peek() – 返回队首元素； empty() – 返回队列是否为空； 注意： 你只能使用栈的标准操作：push to top，peek/pop from top, size 和 is empty； 如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作； 输入数据保证合法，例如，在队列为空时，不会进行pop或者peek等操作； 思路：用两个栈来做，当需要pop的时候可以把原始栈内元素push进cache栈中，然后pop就是队首元素，然后再恢复，peek操作也一样。 class MyQueue { public: stack&lt;int&gt; stk, help; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stk.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { while (! stk.empty()) { int k = stk.top(); help.push(k); stk.pop(); } int t = help.top(); help.pop(); while (! help.empty()) { int k = help.top(); stk.push(k); help.pop(); } return t; } /** Get the front element. */ int peek() { while (! stk.empty()) { int k = stk.top(); help.push(k); stk.pop(); } int t = help.top(); while (! help.empty()) { int k = help.top(); stk.push(k); help.pop(); } return t; } /** Returns whether the queue is empty. */ bool empty() { return stk.empty(); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */ 可以写一个函数，来进行两个栈内元素互换的操作。 class MyQueue { public: /** Initialize your data structure here. */ stack&lt;int&gt; stk, cache; MyQueue() { } void copy(stack&lt;int&gt; &amp;a, stack&lt;int&gt; &amp;b){ while (a.size()){ b.push(a.top()); a.pop(); } } /** Push element x to the back of queue. */ void push(int x) { stk.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { copy(stk, cache); int val = cache.top(); cache.pop(); copy(cache, stk); return val; } /** Get the front element. */ int peek() { copy(stk, cache); int val = cache.top(); copy(cache, stk); return val; } /** Returns whether the queue is empty. */ bool empty() { return stk.empty(); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */ 21. 斐波那契数列 题目描述：输入一个整数 n ，求斐波那契数列的第 n 项。 假定从0开始，第0项为0。(n&lt;=39) 样例 输入整数 n=5 返回 5 思路：设定一个初始值全为1，大小为n的vector，有几个特殊情况需要判断一下，如果n = 0，返回0， 如果n = 1 或者 n = 2，返回1，然后就用迭代方法计算即可，其实也可以用一个滚动数组来节省空间。 class Solution { public: int Fibonacci(int n) { vector&lt;int&gt; res(n, 1); if (n == 0) return 0; if (n == 1 || n == 2) return 1; for (int i = 2; i &lt; n; i ++) { res[i] = res[i - 1] + res[i - 2]; } return res[n - 1]; } }; 滚动数组： class Solution { public: int Fibonacci(int n) { int a = 0, b = 1; while (n --) { int c = a + b; a = b, b = c; } return a; } }; ps.求解斐波那契数列的若干方法 22. 旋转数组的最小数字 题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个升序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 数组可能包含重复项。 注意：数组内所含元素非负，若数组大小为0，请返回-1。 样例 输入：nums=[2,2,2,0,1] 输出：0 思路:之前做过这道题，唯一不同的是，这道题中有重复元素，所以如果用二分做的话，需要先把后面的重复元素删掉，保证二分的性质。 class Solution { public: int findMin(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return -1; int l = 0, r = nums.size() - 1; while (nums[r] == nums[0]) r--; if (nums[r] &gt; nums[0]) return nums[0]; int k = r; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (nums[mid] &lt; nums[k]) r = mid; else l = mid + 1; } return nums[l]; } }; 23. 矩阵中的路径 题目描述: 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。 路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。 如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 注意： 输入的路径不为空； 所有出现的字符均为大写英文字母； 思路: 之前做过这道题但是都忘记了... 就是先枚举起点，然后在上下左右的去寻找后面的单词。 class Solution { public: bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str) { if (matrix.empty() || matrix[0].empty()) return false; int n = matrix.size(), m = matrix[0].size(); for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; m; j++) if (dfs(matrix, str, i, j, 0)) return true; return false; } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string &amp; str, int x, int y, int u){ if (matrix[x][y] != str[u]) return false; if (u == str.size() - 1) return true; char t = matrix[x][y]; matrix[x][y] = '*'; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; for (int i = 0; i &lt; 4; i ++) { int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; matrix.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; matrix[0].size()) { if (dfs(matrix, str, a, b, u + 1)) return true; } } matrix[x][y] = t; return false; } }; ","link":"https://tudouvvv.github.io/post/jian-zhi-offer-shua-ti-day1/"},{"title":"做作的日常①","content":"十一就要结束了呀！！！ 时间呀时间，你慢点撒！ 求斐波那契数列的前1000个数（当时连斐波那契数列是啥都不知道hh） 斐波那契数列是这样一个数列：1, 1, 2, 3, 5, 8, ..., ... 即f(1) = 1, f(2) = 1, f(n) = f(n - 1) + f(n - 2)这样一个递推关系式 可以开一个1000个空间的数组，也可以用while循环来做，但是没啥区别，都是要通过迭代的方式来进行。 Python class Solution: def Fibonacci_sequence(self, nums): f = [0 for _ in range(nums)] if nums == 1: return [1] if nums == 2: return [1, 1] f[0], f[1] = 1, 1 for i in range(2, nums): f[i] = f[i - 1] + f[i - 2] return f 求前1000个质数 质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 可以写一个函数来判断一个数是不是质数，然后主函数用一个while循环进行判断，直到有1000个数，而且判断的时候只需要从2到 x\\sqrt{x}x​即可。 Python class Solution: def Prime(self, nums): f = [2] if nums == 1: return f i = 3 while len(f) &lt; nums: if self.is_prime(i): f.append(i) i += 1 return f def is_prime(self, n): for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True ","link":"https://tudouvvv.github.io/post/zuo-zuo-de-ri-chang/"},{"title":"LeetCode暑期打卡第八周(动态规划专题)","content":"53. Maximum Subarray 题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 分析： 要计算连续的最大和，其实就是要看加了某个数之后的和与该数的大小，如果变小了那就没必要了，所以每次进行判断，如果前面的数&gt;0，那么就加上它，这样遍历一遍，整个数组中最大的值就是我们要找的答案。 C++ class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int ans = INT_MIN; for(int i = 1; i &lt; nums.size(); i ++) { if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1]; } for (auto num : nums) ans = max(ans, num); return ans; } }; Python class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: for i in range(1, len(nums)): if nums[i - 1] &gt; 0: nums[i] += nums[i - 1] return max(nums) 动态规划 从集合的角度来考虑DP问题，最重要的就是要求出状态转移方程是什么样子的，对每个nums[i]来说，它的连续子数组的和共有以下情况: nums[1] + nums[2] + ... + nums[i] nums[2] + nums[3] + ... + nums[i] ... 0 + nums[i] 我们去掉nums[i]来找这些情况中的最大和 f(x)f(x)f(x) ，这些情况中的最大和就等于nums[i - 1]情况下的最大和 f(x−1)f(x-1)f(x−1)，所以状态转移方程就是：f(x)=max(0,f(x−1))+nums[i]f(x) = max(0, f(x-1)) + nums[i]f(x)=max(0,f(x−1))+nums[i]。 C++ class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int res= INT_MIN, last = 0; for (int i = 0; i &lt; nums.size(); i ++) { int now = max(0, last) + nums[i]; res = max(res, now); last = now; } return res; } }; Python class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: res = -float('inf') last = 0 for i in range(len(nums)): now = max(0, last) + nums[i] res = max(res, now) last = now return res 120. Triangle 题目描述：给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 分析：首先记录第一行的数字res = triangle[0][0]，初始时i = 0，然后从第二行开始，res += min(char[i], char[i + 1])，这是它相邻的两个位置，记录min_char的index，然后替换i，继续枚举。 Python❌ class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: if not list: return 0 res = triangle[0][0] i = 0 for char in triangle[1:]: min_char = min(char[i], char[i + 1]) res += min_char i = char.index(min_char) return res 但是不知道为什么有个案例过不了[[-1],[2,3],[1,-1,-3]]，讲道理不是应该-1 + 2 + -1 = 0 嘛，不知道为什么答案是-1。 ✅ps.我明白了，这并不是一个贪心算法的过程，而是要看全局，所以正确的路径应该是-1 + 3 + -3 = -1。 所以这也是一道用dp解决的问题： C++ class Solution { public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(n)); f[0][0] = nums[0][0]; for(int i = 1; i &lt; n; i ++) for(int j = 0; j &lt;= i; j ++) { f[i][j] = INT_MAX; if (j &gt; 0) f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j]); if (j &lt; i) f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j]); } long long res = INT_MAX; for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1][i]); return res; } }; Python class Solution: def minimumTotal(self, nums: List[List[int]]) -&gt; int: n = len(nums) f = [[0 for _ in range(n)] for _ in range(n)] f[0][0] = nums[0][0] for i in range(1, n): for j in range(i + 1): f[i][j] = float('inf') if j &gt; 0: f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j]) if j &lt; i: f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j]) res = float('inf') for i in range(n): res = min(res, f[n - 1][i]) return res 因为我们最后只需要最后一行的数据进行判断，并且每行的结果只依赖于上一行的结果，所以完全不需要开n行数组，只需要开两行，然后滚动就行，这就是滚动数组： class Solution { public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); vector&lt;vector&lt;long long&gt;&gt; f(2, vector&lt;long long&gt;(n)); f[0][0] = nums[0][0]; for(int i = 1; i &lt; n; i ++) for(int j = 0; j &lt;= i; j ++) { f[i &amp; 1][j] = INT_MAX; if (j &gt; 0) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j - 1] + nums[i][j]); if (j &lt; i) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j] + nums[i][j]); } long long res = INT_MAX; for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1 &amp; 1][i]); return res; } }; 63. Unique Paths II 题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例: 输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: 2 解释: 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 分析： 对于状态计算来说，分为两种情况： 最后一步从上往下走: f[i][j] += f[i - 1][j] 最后一步从左往右走: f[i][j] += f[i][j - 1] C++ class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; g) { int n = g.size(), m = g[0].size(); vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(m)); for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; m; j ++) { if (g[i][j]) continue; if (!i &amp;&amp; !j) f[i][j] = 1; if (i &gt; 0) f[i][j] += f[i - 1][j]; if (j &gt; 0) f[i][j] += f[i][j - 1]; } return f[n - 1][m - 1]; } }; Python class Solution: def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int: n = len(g) m = len(g[0]) f = [[0 for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): if g[i][j]: continue; if i == 0 and j == 0: f[i][j] = 1 if (i &gt; 0): f[i][j] += f[i - 1][j] if (j &gt; 0): f[i][j] += f[i][j - 1] return f[n - 1][m - 1] 91. Decode Ways 题目描述：一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -&gt; 1 'B' -&gt; 2 ... 'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例: 输入: &quot;226&quot; 输出: 3 解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 分析：还是用DP的思路来解决： 首先状态表示，f[i]表示所有由前i个数字解码得到的字符串的个数，然后是状态计算，共有两种情况:最后一个字母是一个数字f[i - 1]，最后一个字母是两个数字f[i - 2]，特别还是要考虑边界条件。 C++ class Solution { public: int numDecodings(string s) { int n = s.size(); vector&lt;int&gt; f(n + 1); f[0] = 1; for (int i = 1; i &lt;= n; i ++) { if (s[i - 1] != '0') f[i] += f[i - 1]; if (i &gt;= 2) { int t = (s[i - 2] - '0') * 10 + s[i - 1] - '0'; if (t &gt;= 10 and t &lt;= 26) f[i] += f[i - 2]; } } return f[n]; } }; Python class Solution: def numDecodings(self, s: str) -&gt; int: n = len(s) f = [0 for _ in range(n + 1)] f[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': f[i] += f[i - 1] if i &gt; 1: t = int(s[i - 2]) * 10 + int(s[i - 1]) if 10 &lt;= t &lt;=26: f[i] += f[i - 2] return f[n] 198. House Robber 题目描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 分析：我把奇数的加一起，偶数的加一起，max一下不就可以了嘛 class Solution: def rob(self, nums: List[int]) -&gt; int: res1 = 0 res2 = 0 for i in range(len(nums)): if i % 2 == 0: res1 += nums[i] else: res2 += nums[i] return max(res1, res2) 好吧，少考虑了情况，如果是[2, 1, 1, 2]的话就不需要隔一个偷一个了。 考虑用DP来做，用两个数组分别表示状态： 那么在进行状态计算的时候，f[i]因为表示不取nums[i]的最大值，所以就等于nums[i-1]的最大值，所以f[i] = max(f[i - 1], g[i - 1]) g[i]表示选了nums[i]的最大值，既然选了nums[i]，那么肯定没有选nums[i - 1]，于是g[i] = f[i - 1] + nums[i]。 C++ class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1), g(n + 1); for (int i = 1; i &lt;=n; i ++ ) { f[i] = max(f[i - 1], g[i - 1]); g[i] = f[i - 1] + nums[i - 1]; } return max(f[n], g[n]); } }; Python class Solution: def rob(self, nums: List[int]) -&gt; int: n = len(nums) f = [0 for _ in range(n + 1)] g = [0 for _ in range(n + 1)] for i in range(1, n + 1): f[i] = max(f[i - 1], g[i - 1]) g[i] = f[i - 1] + nums[i - 1] return max(f[n], g[n]) 300. Longest Increasing Subsequence 题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 Note: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2)O(n^2)O(n2) 。 分析：用DP来解决，首先状态表示f[i]：表示以第i个数结尾的上升子序列的最大值；然后是状态更新，我们要遍历从0到i的所有数，如果nums[j] &lt; nums[i]， 就说明它可i以被放进去，那么f[i] = max(f[i], f[j] + 1)，最后再遍历f，找出最大值即可。 C++ class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, 1); for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; i; j ++) if (nums[j] &lt; nums[i]) { f[i] = max(f[i], f[j] + 1); } int res = 0; for (int i = 0; i &lt; n; i ++) res = max(res, f[i]); return res; } }; Python class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: n = len(nums) f = [1 for _ in range(n)] for i in range(n): for j in range(i): if nums[j] &lt; nums[i]: f[i] = max(f[i], f[j] + 1) res = 0 for i in range(n): res = max(res, f[i]) return res 72. Edit Distance 题目描述：给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例: 输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; 输出: 3 解释: horse -&gt; rorse (将 'h' 替换为 'r') rorse -&gt; rose (删除 'r') rose -&gt; ros (删除 'e') 分析：首先集合表示：f[i, j]表示将第一个字符串的前i个字母，变成第二个字符串的前j个字母的方案的最小值，那么在进行状态计算时，我们考虑最后一步的情况，由于它共有三种操作方式，所以最后一步的情况如下： 插入：我在第一个字符串中插入一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i个字符和第二个字符串的前j - 1个字符相同，所以f[i, j] = f[i, j - 1] + 1 删除：我在第一个字符串中删除一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i - 1个字符和第二个字符串的前j的字符相同，所以f[i, j] = f[i - 1, j] + 1 替换：替换又分为两种情况：1）第一个字符串的第i个字符和第二个字符串的第j个字符是相同的，不需要替换了，所以f[i, j] = f[i - 1, j - 1]; 2）第一个字符串的第i个字符和第二个字符串的第j个字符是不同的，需要替换一下，所以f[i, j] = f[i - 1, j - 1] + 1; 最后只需要在上面四种方案中求一个最小值代表状态即可。 C++ class Solution { public: int minDistance(string word1, string word2) { int n = word1.size(), m = word2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1)); for (int i = 0; i &lt;= n; i ++) f[i][0] = i; for (int i = 0; i &lt;= m; i ++) f[0][i] = i; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i -1] != word2[j - 1])); } return f[n][m]; } }; Python class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: n, m = len(word1), len(word2) f = [[0 for _ in range(m + 1)] for _ in range(n + 1)] for i in range(n + 1): f[i][0] = i for i in range(m + 1): f[0][i] = i for i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1 f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i - 1] != word2[j - 1])); return f[n][m] 518. Coin Change 2 题目描述：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 Note: 你可以假设： 0 &lt;= amount (总金额) &lt;= 5000 1 &lt;= coin (硬币面额) &lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数 示例: 输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 分析：首先状态表示f[i,j]表示为用前i个硬币凑出总钱数为j的凑法的数量，那么在状态表示时，有很多种情况： 用了0个第i个硬币，所以f[i, j] = f[i - 1, j]; 用了t个第i个硬币，所以f[i, j] = f[i - 1, j - t * coins[i]]; 所以，f[i ,j] = f[i - 1, j] + f[i - 1, j - c] + f[i - 1, j - 2c] + ... + f[i - 1, j - kc] 但是，f[i, j - c] = f[i - 1, j - c] + f[i - 1, j - 2c] + ... + f[i - 1, j - kc] 所以，我们可以用f[i, j - c]的状态替换掉后面一堆东西，于是f[i, j] = f[i - 1, j] + f[i, j - c] 由于这里i只与上一层有关系，所以可以用滚动数组来求解，同时f[i - 1, j] 与 f[i , j]表示的j都是一样的，所以可以用一个一维的滚动数组来简化f[j] = f[j] + f[j - c]。 C++ class Solution { public: int change(int amount, vector&lt;int&gt;&amp; coins) { int m = amount; vector&lt;int&gt; f(m + 1); f[0] = 1; for (auto c : coins) for (int j = c; j &lt;= m; j ++) f[j] += f[j - c]; return f[m]; } }; Python class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: m = amount f = [0 for _ in range(m + 1)] f[0] = 1 for coin in coins: for j in range(coin, m + 1): f[j] += f[j - coin] return f[m] 664. Strange Printer 题目描述：有台奇怪的打印机有以下两个特殊要求： 打印机每次只能打印同一个字符序列。 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。 给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。 示例: 输入: &quot;aba&quot; 输出: 2 解释: 首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 'a'。 分析：f[l][r]表示将[L, R]染成最终模样的方式的最小值： 首先是把端点染成想要的颜色，f[l][r] = f[l + 1][r] + 1 然后另一种情况是染[l, k]，l和k处的颜色相同的话，f[l][r]= f[l][k - 1] + f[k + 1][r] 最后求两者的最小值即可。 C++ class Solution { public: int strangePrinter(string s) { int n = s.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1)); if (s.empty()) return 0; for (int len = 1; len &lt;= n; len ++) for (int l = 0; l + len - 1 &lt; n; l ++) { int r = l + len - 1; f[l][r] = f[l + 1][r] + 1; for (int k = l + 1; k &lt;= r; k ++) if (s[l] == s[k]) f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r]); } return f[0][n - 1]; } }; Python class Solution: def strangePrinter(self, s: str) -&gt; int: n = len(s) if n == 0: return 0 f = [[0 for _ in range(n + 1)]for _ in range(n + 1)] for lens in range(1, n + 1): for l in range(0, n - lens + 1): r = l + lens - 1 f[l][r] = f[l + 1][r] + 1 for k in range(l + 1, r + 1): if s[l] == s[k]: f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r]) print(f) return f[0][n - 1] ❌10. Regular Expression Matching(存疑) 题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 Note: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例: 输入: s = &quot;aa&quot; p = &quot;a*&quot; 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。 分析：考虑用DP来做，f[i][j]表示s的第i个字符与p的第j个字符是否匹配，我们现在已经得知了之前的状态，也就是f[i - 1][j - 1]，现在要考虑的就是s[i]与p[j]的关系： 如果s[i] = p[j], 那么f[i][j] = f[i - 1][j - 1] 如果p[j] = '.', 那么f[i][j] = f[i - 1][j - 1] 如果p[j] = '*', 那么我们要考虑s[i] 与 p[j - 1]的关系： 如果s[i] != p[j - 1], 那么f[i][j] = f[i - 1][j - 2]，此时*表示匹配0个前面的字母 如果p[j - 1] = '.' || p[j - 1] = s[i]： ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第八周(动态规划专题)/"},{"title":"LeetCode暑期打卡第七周(基本数据结构专题)","content":"1. Two Sum 题目描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 分析：可以设计一个字典来保存值与索引的映射关系，然后去找target-nums[i]是否在字典中，如果在并且该值不等于nums[i]的话(避免重复利用)，就说明这是一个答案。 Python class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dicts = {} for i, v in enumerate(nums): dicts[v] = i for i in range(len(nums)): if target - nums[i] in dicts and dicts[target - nums[i]] != i: return [i, dicts[target-nums[i]]] 也可以用hash表来做： C++ class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i ++) { if (hash.count(target - nums[i])) return{hash[target - nums[i]], i}; hash[nums[i]] = i; } return {-1, -1}; } }; Python class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dicts = {} for i in range(len(nums)): if target - nums[i] in dicts: return [dicts[target - nums[i]], i] dicts[nums[i]] = i return [-1, -1] Ps. if (hash.count(key)) 是判断hash表中是否存在关键字key； if (hash[key]) 是判断key对应的value值是否是真，如果key在hash表中不存在，则会先为其创建默认值，比如int的默认值是0，vector的默认值是vector()； 在C++中，如果想往哈希表中插入一对(key, value)，一般写hash[key] = value； 如果想查找一个key是否存在，一般有两种写法： if (hash.find(key) != hash.end()) if (hash.count(key) != 0) 第二种写法短一些，所以用得比较多。 来源：AcWing 187. Repeated DNA Sequences 题目描述：所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:= 输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot; 输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 分析：如果是确定的十个字母长的字符串，那是否可以从前往后枚举，至多就有n - 1中情况，这样是不是有点慢。 好吧，确实是这样做的，先把字符串中长度为10的子串拿出啦插入到hash表中，然后统计次数，最后输出次数大于等于2的子串就可以了。 C++ class Solution { public: vector&lt;string&gt; findRepeatedDnaSequences(string s) { unordered_map &lt;string, int&gt; hash; vector&lt;string&gt; res; for (int i = 0; i + 10 &lt;= s.size(); i ++) { string str = s.substr(i, 10); hash[str] ++; if (hash[str] == 2) res.push_back(str); } return res; } }; Python class Solution: def findRepeatedDnaSequences(self, s: str) -&gt; List[str]: dicts = {} res = [] for i in range(len(s) - 9): substr = s[i : i + 10] dicts.setdefault(substr, 0) dicts[substr] += 1 if dicts[substr] == 2: res.append(substr) return res 706. Design HashMap 题目描述：不使用任何内建的哈希表库设计一个哈希映射 具体地说，你的设计应该包含以下的功能 put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。 get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。 remove(key)：如果映射中存在这个键，删除这个数值对。 Note: 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希库。 示例： MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1); hashMap.put(2, 2); hashMap.get(1); // 返回 1 hashMap.get(3); // 返回 -1 (未找到) hashMap.put(2, 1); // 更新已有的值 hashMap.get(2); // 返回 1 hashMap.remove(2); // 删除键为2的数据 hashMap.get(2); // 返回 -1 (未找到) 分析：为了避免插入的时候冲突，使用拉链法，用一个链表来存储映射到该位置的元素。 对于put(key, value)操作: 先求出key的哈希值(取模)，然后遍历该位置上的链表: 如果链表中包含key，则更新其对应的value； 如果链表中不包含key，则直接将（key，value）插入该链表中。 对于get(key)操作: 求出key对应的哈希值后，遍历该位置上的链表. 如果key在链表中，则返回其对应的value，否则返回-1。 对于remove(key)，求出key的哈希值后，遍历该位置上的链表，如果key在链表中，则将其删除。 Python class MyHashMap: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.hash = [[] for _ in range(20011)] # 开辟一个大数组，长度为质数，注意这里不能用 [[]] * 20011，会被覆盖 # 一般定义成离2的整次幂比较远的质数，这样取模之后冲突的概率比较低。 def put(self, key: int, value: int) -&gt; None: &quot;&quot;&quot; value will always be non-negative. &quot;&quot;&quot; index = key % 20011 for item in self.hash[index]: if item[0] == key: item[1] = value return self.hash[index].append([key, value]) def get(self, key: int) -&gt; int: &quot;&quot;&quot; Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key &quot;&quot;&quot; index = key % 20011 for item in self.hash[index]: if item[0] == key: return item[1] return -1 def remove(self, key: int) -&gt; None: &quot;&quot;&quot; Removes the mapping of the specified value key if this map contains a mapping for the key &quot;&quot;&quot; index = key % 20011 delete = [] for item in self.hash[index]: if item[0] == key: self.hash[index].remove(item) # Your MyHashMap object will be instantiated and called as such: # obj = MyHashMap() # obj.put(key,value) # param_2 = obj.get(key) # obj.remove(key) 652. Find Duplicate Subtrees 题目描述：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 两棵树重复是指它们具有相同的结构以及相同的结点值。 分析: 首先把所有的子树枚举出来，然后把该子树用hash映射成一个整数。然后在建一个hash表示每个子树出现的次数，寻找子树时可以使用前序遍历的深度优先搜索。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int cnt = 0; unordered_map&lt;string, int&gt; hash; unordered_map&lt;int, int&gt; count; vector &lt;TreeNode*&gt; ans; string dfs(TreeNode* root) { if (!root) return to_string(hash[&quot;#&quot;]); auto left = dfs(root-&gt;left); auto right = dfs(root-&gt;right); string tree = to_string(root-&gt;val) + ',' + left + ',' + right; if (! hash.count(tree)) hash[tree] = ++ cnt; int t = hash[tree]; count[t] ++ ; if (count[t] == 2) ans.push_back(root); return to_string(t); } vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) { hash[&quot;#&quot;] = ++ cnt; dfs(root); return ans; } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def findDuplicateSubtrees(self, root: TreeNode) -&gt; List[TreeNode]: self.cnt = 0 hashs = {} count = {} ans = [] hashs['#'] = self.cnt = self.cnt + 1 def dfs(root): if not root: return str(hashs['#']) left = dfs(root.left) right = dfs(root.right) tree = str(root.val) + ',' + left + ',' + right self.cnt += 1 hashs.setdefault(tree, self.cnt) t = hashs[tree] count.setdefault(t, 0) count[t] += 1 if count[t] == 2: ans.append(root) return str(t) dfs(root); return ans; 560. Subarray Sum Equals K 题目描述：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 Note: 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 示例: 输入: nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 分析：滑动窗口嘛//前缀和！！！ 用前缀和加hash的方式可以做，每次记录s[i] - k出现的次数，因为假设s[j] = s[i] - k, 那么说明从j+1 到 i的和为k。 C++ class Solution { public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; hash; int res = 0; hash[0] = 1; for (int i = 0, sum = 0; i &lt; nums.size(); i ++) { sum += nums[i]; res += hash[sum - k]; hash[sum] ++; } return res; } }; Python class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: hashs = {} res = 0 count = 0 hashs[0] = 1 for i in range(len(nums)): count += nums[i] if count - k in hashs: res += hashs[count - k] if count in hashs: hashs[count] += 1 else: hashs[count] = 1 return res 547. Friend Circles(存疑) 题目描述：班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 Note: N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 示例: 输入: [[1,1,0], [1,1,1], [0,1,1]] 输出: 1 说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 分析： 并查集：1）合并两个集合；2）判断两个点是否在同一个集合中。 所以刚开始每个都是单独的集合，如果两个点之间为1，说明它们在一个集合之中，于是合并它们，集合个数减一。 C++ class Solution { public: vector&lt;int&gt; p; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) { int n = M.size(); int res = n; for (int i = 0; i &lt; n; i ++) p.push_back(i); for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; i; j ++) { if (M[i][j] == 0) continue; if (find(i) != find(j)) { p[find(i)] = find(p[j]); res --; } } return res; } }; Python class Solution: def findCircleNum(self, M: List[List[int]]) -&gt; int: p = [] res = n = len(M) for i in range(n): p.append(i) def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] for i in range(n): for j in range(i): if M[i][j] == 0: continue if find(i) != find(j): p[find(i)] = find(j) res -= 1 return res 684. Redundant Connection 题目描述：在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。 示例： 输入: [[1,2], [2,3], [3,4], [1,4], [1,5]] 输出: [1,4] 解释: 给定的无向图为: 5 - 1 - 2 | | 4 - 3 分析：并查集应用： C++ class Solution { public: vector&lt;int&gt; p; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int n = edges.size(); for (int i = 0; i &lt;= n; i ++) p.push_back(i); for (auto e : edges) { int a = e[0], b = e[1]; if (find(a) == find(b)) return {a, b}; p[find(a)] = find(b); } return {-1, -1}; } }; Python class Solution: def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]: p = [] n = len(edges) for i in range(n + 1): p.append(i) def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] for e in edges: a = e[0] b = e[1] if find(a) == find(b): return [a, b]; p[find(a)] = find(b) return [-1, -1] 692. Top K Frequent Words Ps.对一个堆来说: 查找最大值O(1) 插入一个数O(logn) 删除一个数O(logn) 题目描述：给一非空的单词列表，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。 Note： 假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。 输入的单词均由小写字母组成。 示例： 输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2 输出: [&quot;i&quot;, &quot;love&quot;] 解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。 注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。 分析：可不可以用hash来做！！！ 我们要找出出现次数最多的k个单词，用小根堆来维护出现次数最多的k个单词。 class Solution { public: vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) { unordered_map&lt;string, int&gt; hash; typedef pair&lt;int, string&gt; PIS; priority_queue&lt;PIS&gt; heap; for (auto word : words) hash[word] ++; for (auto item : hash) { PIS t(-item.second, item.first); heap.push(t); if (heap.size() &gt; k) heap.pop(); } vector&lt;string&gt; res(k); for (int i = k - 1; i &gt;= 0; i --) { res[i] = heap.top().second; heap.pop(); } return res; } }; Python class Solution(object): def topKFrequent(self, words, k): count = collections.Counter(words) heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) # print(heapq.nsmallest(3, heap)) return [heapq.heappop(heap)[1] for _ in range(k)] 也可以直接用排序来做： Python class Solution: def topKFrequent(self, words: List[str], k: int) -&gt; List[str]: d = {} for word in words: d[word] = d.get(word, 0) + 1 res = sorted(d, key = lambda word : (-d[word], word)) return res[:k] 295. Find Median from Data Stream 题目描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例： addNum(1) addNum(2) findMedian() -&gt; 1.5 addNum(3) findMedian() -&gt; 2 分析：init一个列表，每次add的时候就往里加元素，find的时候判断长度是否为偶数，可能需要注意的是添加数以后列表应该也是有序的。 Python class MedianFinder: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.res = [] def addNum(self, num: int) -&gt; None: self.res.append(num) def findMedian(self) -&gt; float: self.res = sorted(self.res) n = len(self.res) if n % 2 == 0: return float((self.res[n//2] + self.res[n//2 - 1]) * 0.5) else: return self.res[int(n/2)] # Your MedianFinder object will be instantiated and called as such: # obj = MedianFinder() # obj.addNum(num) # param_2 = obj.findMedian() 然后超时了，因为每次都要对列表进行排序，耗费的时间太多。 正确的解法：构建一个对顶堆： 如图，上面是一个小根堆，保存数值较大的一部分，下面是一个大根堆，保存数值较小的一部分，每部分的元素个数都是n / 2，这样中间的元素就是我们要找的数。 如果 x&gt;= 下面的根节点，插入上面的堆，反之插入下面的堆，然后维护两个堆的个数即可。 C++ class MedianFinder { public: priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up; priority_queue &lt;int&gt; down; /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { if (down.empty() || num &gt; down.top()) up.push(num); else { down.push(num); up.push(down.top()); down.pop(); } if (up.size() &gt; down.size() + 1) { down.push(up.top()); up.pop(); } } double findMedian() { if (down.size() + up.size() &amp; 1) return up.top(); else return (down.top() + up.top()) / 2.0; } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-&gt;addNum(num); * double param_2 = obj-&gt;findMedian(); */ Python from heapq import heappush, heappop class MedianFinder: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.up = [] self.down = [] def addNum(self, num: int) -&gt; None: if (len(self.down) == 0 or -num &lt; self.down[0]): heappush(self.up, num); else: heappush(self.down, -num) heappush(self.up, -self.down[0]) heappop(self.down) if len(self.up) &gt; len(self.down) + 1: heappush(self.down, -self.up[0]) heappop(self.up) def findMedian(self) -&gt; float: if len(self.up) + len(self.down) &amp; 1: return self.up[0] else: return (self.up[0] - self.down[0]) * 0.5 # Your MedianFinder object will be instantiated and called as such: # obj = MedianFinder() # obj.addNum(num) # param_2 = obj.findMedian() 352. Data Stream as Disjoint Intervals 题目描述：给定一个非负整数的数据流输入 a1，a2，…，an，…，将到目前为止看到的数字总结为不相交的区间列表。 例如，假设数据流中的整数为 1，3，7，2，6，…，每次的总结为： [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7] 分析：根据题意，在第四步的时候，应该加一个区间[2, 2]，但是由于[1, 2, 3]是连续的，所以合并区间，变为了[1, 3]。 用平衡树来维护所有区间，构建两个字典，L和R，分别对左右端点进行映射，L中的value是左端点，R中的value是右端点，然后当有新的x插入的时候，一共有四种情况： 比如说一个区间是[x, y]，那么L[y] = x, R[x] = y。 C++ class SummaryRanges { public: /** Initialize your data structure here. */ map&lt;int, int&gt; L, R; SummaryRanges() { } void addNum(int x) { if (L.size()) { auto it = L.lower_bound(x); if (it != L.end() &amp;&amp; it-&gt;second &lt;= x) return; } int left = L.count(x - 1), right = R.count(x + 1); if (left &amp;&amp; right) { R[L[x - 1]] = R[x + 1]; L[R[x + 1]] = L[x - 1]; L.erase(x - 1), R.erase(x + 1); } else if (left) { R[L[x - 1]] = x; L[x] = L[x - 1]; L.erase(x - 1); } else if (right) { L[R[x + 1]] = x; R[x] = R[x + 1]; R.erase(x + 1); } else { R[x] = L[x] = x; } } vector&lt;vector&lt;int&gt;&gt; getIntervals() { vector&lt;vector&lt;int&gt;&gt; res; for (auto item : R) res.push_back({item.first, item.second}); return res; } }; /** * Your SummaryRanges object will be instantiated and called as such: * SummaryRanges* obj = new SummaryRanges(); * obj-&gt;addNum(val); * vector&lt;vector&lt;int&gt;&gt; param_2 = obj-&gt;getIntervals(); */ ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第七周(基本数据结构专题)/"},{"title":"LeetCode暑期打卡第六周( 滑动窗口、双指针、单调队列和单调栈专题)","content":"167. Two Sum II - Input array is sorted 题目描述：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 Note： 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 分析：暴力做法：设置两个for循环，来遍历数对，由于是 n2n^2n2 的复杂度，所以超时了。 双指针算法：我们设定两个指针i和j，i &lt;= j ，并且nums[i] + nums[j] &gt;= target，当i增大时，j势必会减小，这样就有一个单调性，直到我们找到答案。 C++ class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { for (int i = 0, j = numbers.size() - 1; i &lt; numbers.size(); i ++) { while (j - 1 &gt; i &amp;&amp; numbers[j - 1] + numbers[i] &gt;= target) j --; if (numbers[i] + numbers[j] == target) return{i + 1, j + 1}; } return {}; } }; Python class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: j = len(numbers) - 1 for i in range(len(numbers)): while j - 1 &gt; i and numbers[j - 1] + numbers[i] &gt;= target: j -= 1 if numbers[i] + numbers[j] == target: return [i + 1, j + 1] return [] 88. Merge Sorted Array 题目描述：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 Note： 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 分析：先用两个指针分别指向每个数组的最后一位，表示该数组的最大值；每次把两个指针指向的最大值拿出来，然后放在后面。 C++ class Solution { public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int i = m - 1, j = n - 1, k = m + n - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) if (nums1[i] &gt; nums2[j]) nums1[k -- ] = nums1[i --]; else nums1[k --] = nums2[j --]; while (j &gt;= 0) nums1[k --] = nums2[j --]; } }; Python class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; while m &gt; 0 and n &gt; 0: if nums1[m - 1] &gt; nums2[n - 1]: nums1[m + n - 1] = nums1[m - 1] m -= 1 else: nums1[m + n - 1] = nums2[n - 1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] 26. Remove Duplicates from Sorted Array 题目描述：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 : 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 分析：可以设置一个指针target指向最小的数字，每次与它进行判断，如果比它大，那么这就是一个新的数，替换target，并且交换位置。 C++ class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int target = nums[0]; int count = 1; for (int i = 1; i &lt; nums.size(); i ++) { if (nums[i] &gt; target) { target = nums[i]; int tmp = nums[count]; nums[count] = nums[i]; nums[i] = tmp; count += 1; } } return count; } }; Python class Solution: def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 min_target = nums[0] count = 1 i = 1 while i &lt; len(nums): if nums[i] &gt; min_target: min_target = nums[i] nums[count], nums[i] = nums[i], nums[count] count += 1 i += 1 return count 其实，不需要这么麻烦，设定一个指针k指向前面不同的数的最后一位的下一位，从前往后遍历，每次与它的前一个数进行比较，不同的话替换前面的指针k指向的数，k + 1即可； C++ class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int k = 1; for (int j = 1; j &lt; nums.size(); j ++) { if (nums[j] != nums[j - 1]) nums[k ++] = nums[j]; } return k; } }; Python class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if not nums: return 0 k = 1; for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[k] = nums[i]; k += 1 return k; 76. Minimum Window Substring 题目描述：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。 Note： 如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 示例： 输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; 输出: &quot;BANC&quot; 分析：暴力写法：枚举S所有的子串，再去看是否包含T里所有的字母。 滑动窗口算法：i和j表示窗口的左右两个边界，j随i的变化而变化，设定一个hash表表示t中字母的数量，cnt表示有多少个不同的字母；然后遍历s，设定一个变量c表示遇到了几个我们需要的字母，当遇到需要的字母时if hash[s[i]] == 1: c ++，然后hash[s[i]] --表示需要的数量-1，这样不断挪动右窗口的边界就行，那做做窗口怎么更新呢？当我们一直往右走时，总会遇到一段拥有所有的字母，此时再往右走，hash中包含我们需要的字母的数值就会变为负值，此时进行判断，如果左边界的字母的hash值是负值，那就说明这个字母我们不需要，因为右边已经有了或者不是我们需要的，然后往右挪动一下，hash++即可。每次挪动右边记得要更新答案。 C++ class Solution { public: string minWindow(string s, string t) { unordered_map&lt;char, int&gt; hash; string res; for (auto c : t) hash[c] ++; int cnt = hash.size(); for (int i = 0, j = 0, c = 0; i &lt; s.size(); i ++) { if (hash[s[i]] == 1) c++; hash[s[i]] --; while (hash[s[j]] &lt; 0) hash[s[j ++]] ++; if (c == cnt) { if (res.empty() || res.size() &gt; i - j + 1) res = s.substr(j, i - j + 1); } } return res; } }; Python import collections class Solution: def minWindow(self, s: str, t: str) -&gt; str: hash_dict = collections.Counter(t) res = &quot;&quot; cnt = len(hash_dict) j = 0 c = 0 for i in range(len(s)): if (hash_dict[s[i]] == 1): c += 1 hash_dict[s[i]] -= 1 while j &lt; len(s) and hash_dict[s[j]] &lt; 0: hash_dict[s[j]] += 1 j += 1 if c == cnt: if (not res) or len(res) &gt; i - j + 1: res = s[j : i+1] return res 32. Longest Valid Parentheses 题目描述：给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。 示例 : 输入: &quot;)()())&quot; 输出: 4 解释: 最长有效括号子串为 &quot;()()&quot; 分析：刚开始考虑用栈来做... 括号序列的一个性质： 不论怎么匹配，左右括号一定是确定的 一个括号序列合法&lt;=&gt;所有前缀和&gt;=0，且总和=0(左括号为1，右括号为-1) 所以我们可以用这个性质来做，start表示当前枚举的开头位置，cnt表示前缀和，然后开始遍历，计算start--&gt;i的前缀和cnt，如果cnt&lt;0，那就说明当前这一段不合法，start = i + 1，cnt = 0继续遍历；如果cnt &gt; 0那就说明当前合法，继续做；如果cnt = 0， 那就说明[start, i]这一段是合法序列，更新答案即可；但是会有这样一种情况，左括号的数量大于右括号的数量(((())这样cnt永远&gt;0，是更新不了答案的，所以还需要反着再来一遍。 C++ class Solution { public: int work(string s) { int res = 0; for (int i = 0, start = 0, cnt = 0; i &lt; s.size(); i ++) { if (s[i] == '(') cnt ++ ; else { cnt -- ; if (cnt &lt; 0) start = i + 1, cnt = 0; else if (cnt == 0) res = max(res, i - start + 1); } } return res; } int longestValidParentheses(string s) { int res = work(s); reverse(s.begin(), s.end()); for (auto &amp;c : s) c ^= 1; return max(res, work(s)); } }; Python class Solution: def longestValidParentheses(self, s: str) -&gt; int: res = self.work(s); s = s[::-1]; s_reverse = &quot;&quot; for char in s: char = chr(ord(char) ^ 1) s_reverse += char return max(res, self.work(s_reverse)) def work(self, s): res, start, cnt = 0, 0, 0 for i in range(len(s)): if s[i] == '(': cnt += 1 else: cnt -= 1 if cnt &lt; 0: start, cnt = i + 1, 0 elif cnt == 0: res = max(res, i - start + 1) return res 用栈来做： C++ class Solution { public: int longestValidParentheses(string s) { stack&lt;int&gt; stack; int ans = 0; int base = -1; for (int i = 0; i &lt; s.size(); i ++ ) { if (s[i] == '(') stack.push(i); else if (stack.size() &gt; 0) { stack.pop(); if (stack.size() == 0) ans = max(ans, i - base); else ans = max(ans, i - stack.top()); } else base = i; } return ans; } }; Python class Solution: def longestValidParentheses(self, s: str) -&gt; int: stack = [] ans = 0 base = -1 for i, c in enumerate(s): if c == '(': stack.append(i) elif stack: stack.pop() if stack: ans = max(ans, i - stack[-1]) else: ans = max(ans, i - base) else: base = i return ans 155. Min Stack 题目描述：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) -- 将元素 x 推入栈中。 pop() -- 删除栈顶的元素。 top() -- 获取栈顶元素。 getMin() -- 检索栈中的最小元素。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&gt; 返回 -3. minStack.pop(); minStack.top(); --&gt; 返回 0. minStack.getMin(); --&gt; 返回 -2. 分析：本来的想法是建立一个列表，通过append和del操作来构造所需要的函数。 后来发现可以直接调用push和pop操作，不过唯一不同的是，在进行getMin操作时，可以新建一个栈，存的当前栈的最小值，第一个元素表示第一个数的最小值（也就是第一个数），第二个元素存的是前两个数的最小值，以此类推... C++ class MinStack { public: stack&lt;int&gt; stk, stk_min; /** initialize your data structure here. */ MinStack() { } void push(int x) { stk.push(x); if (stk_min.empty()) stk_min.push(x); else stk_min.push(min(x, stk_min.top())); } void pop() { stk.pop(); stk_min.pop(); } int top() { return stk.top(); } int getMin() { return stk_min.top(); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ Python class MinStack: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.stk = [] self.stk_min = [] def push(self, x: int) -&gt; None: self.stk.append(x) if self.stk_min: self.stk_min.append(min(x, self.stk_min[-1])) else: self.stk_min.append(x) def pop(self) -&gt; None: self.stk.pop() self.stk_min.pop() def top(self) -&gt; int: return self.stk[-1] def getMin(self) -&gt; int: return self.stk_min[-1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(x) # obj.pop() # param_3 = obj.top() # param_4 = obj.getMin() 84. Largest Rectangle in Histogram 题目描述：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例: 输入: [2,1,5,6,2,3] 输出: 10 分析： 单调栈：查找每个数左/右侧第一个比它小/大的数 单调队列：查找滑动窗口中的最值 这道题首先要考虑的是如何能枚举出来所有的矩形： 枚举所有柱形的上边界作为整个矩形的上边界，然后求出左右边界（往左右可以扩充的位置） 找出左边离它最近的，比它小的柱形 找出右边离它最近的，比它小的柱形 比如输入[2,1,5,6,2,3]，构建一个栈，每次push元素的时候都要比栈顶元素大，如果没有，就pop栈直到栈中没有比它大的元素，再进栈，这样就构成了一个单调栈。 C++ class Solution { public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int n = heights.size(); vector&lt;int&gt; left(n), right(n); stack&lt;int&gt; stk; for (int i = 0; i &lt; n; i ++) { while (stk.size() &amp;&amp; heights[stk.top()] &gt;= heights[i]) stk.pop(); if (stk.empty()) left[i] = -1; else left[i] = stk.top(); stk.push(i); } while(stk.size()) stk.pop(); for (int i = n - 1; i &gt;= 0; i --) { while (stk.size() &amp;&amp; heights[stk.top()] &gt;= heights[i]) stk.pop(); if (stk.empty()) right[i] = n; else right[i] = stk.top(); stk.push(i); } int res = 0; for (int i = 0; i &lt; n; i ++) res = max(res, heights[i] * (right[i] - left[i] - 1)); return res; } }; Python class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n = len(heights) right, left = [0] * n, [0] * n stk = [] for i in range(n): while (len(stk) and heights[stk[-1]] &gt;= heights[i]): stk.pop() if not stk: left[i] = -1 else: left[i] = stk[-1] stk.append(i) while len(stk): stk.pop() for i in range(n-1, -1, -1): while (len(stk) and heights[stk[-1]] &gt;= heights[i]): stk.pop() if not stk: right[i] = n else: right[i] = stk[-1] stk.append(i) res = 0 for i in range(n): res = max(res, heights[i] * (right[i] - left[i] - 1)) return res 42. Trapping Rain Water 题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 分析：找到数组中的低谷，低谷就是雨水可以存在的位置。 三次线性扫描 每个矩形上方的水的数量是由它自己、它左边最高的位置以及它右边最高的位置决定的，所以我们需要首先得到每个位置左边最高位置和右边最高位置，然后水的数量就等于 min(left[i], right[i]) - height[i]。 C++ class Solution { public: int trap(vector&lt;int&gt;&amp; height) { int n = height.size(); int res = 0; if (n == 0) return 0; vector&lt;int&gt; left(n), right(n); left[0] = height[0]; for (int i = 1; i &lt; n; i ++) left[i] = max(left[i - 1], height[i]); right[n - 1] = height[n - 1]; for (int i = n - 2; i &gt;= 0; i --) right[i] = max(right[i + 1], height[i]); for (int i = 0; i &lt; n; i ++) res += min(left[i], right[i]) - height[i]; return res; } }; Python class Solution: def trap(self, height: List[int]) -&gt; int: n = len(height) res = 0 left, right = [0] * n, [0] * n if not height: return 0 left[0] = height[0] for i in range(n): left[i] = max(left[i - 1], height[i]) right[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right[i] = max(right[i + 1], height[i]) for i in range(n): res += min(left[i], right[i]) - height[i] return res 单调栈（存疑） 239. Sliding Window Maximum 题目描述：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 分析： 暴力解法：枚举所有的情况，python可以进行切片操作，然后用max得到该窗口内的最大值。 Python class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] res = [] n = len(nums) for i in range(n - k + 1): res.append(max(nums[i:i + k])) return res 单调队列 单调队列是一个普通的双端队列，即队头和队尾都可以添加和弹出元素。维护这样一个队列：队头元素最大，队尾最小，这样在每个窗口中，只需要push队头元素即可。 每次添加元素时都需要进行检查：1）合法性检查：即如果队头元素下标已经不在窗口范围内，应该出队；2）单调性检查：如果nums[i]大于或等于队尾元素下标所对应的值，则当前队尾再也不可能充当某个滑动窗口的最大值了，故需要队尾出队。始终保持队中元素从队头到队尾单调递减。 C++ class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; res; deque&lt;int&gt; q; for(int i = 0; i &lt; nums.size(); i ++) { while (q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front(); while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back(); q.push_back(i); if (i &gt;= k - 1) res.push_back(nums[q.front()]); } return res; } }; Python class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: res = [] q = [] n = len(nums) for i in range(n): if(len(q) and i - k + 1 &gt; q[0]): q.pop(0) while(len(q) and nums[i] &gt;= nums[q[-1]]): q.pop() q.append(i) if i &gt;= k - 1: res.append(nums[q[0]]) return res 918. Maximum Sum Circular Subarray(存疑) ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第六周/"},{"title":"LeetCode暑期打卡第五周(DFS+回溯专题)","content":"搜索 != 递归 17. Letter Combinations of a Phone Number 题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 数字到字母的映射与以前电话九宫格按键相同，1不对应任何字母。 示例： 输入：&quot;23&quot; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 分析：用循环来来做这道题，首先设置空列表表示答案，先取出数字，再取出字母，最后再拿出列表中的元素，把它们拼接在一起，更新列表即可。 C++ class Solution { public: string chars[8] = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}; vector&lt;string&gt; letterCombinations(string digits) { if (digits.empty()) return vector&lt;string&gt;(); vector &lt;string&gt; states(1, &quot;&quot;); for (auto u : digits) { vector &lt;string&gt; now; for (auto c : chars[u - '2']) for (auto s : states) now.push_back(s + c); states = now; } return states; } }; Python class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: chars = [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;] if not digits: return [] states = [&quot;&quot;] for u in digits: now = [] for c in chars[int(u) - 2]: for s in states: now.append(s + c) states = now return states 79. Word Search 题目描述：给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例： board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = &quot;ABCCED&quot;, 返回 true. 给定 word = &quot;SEE&quot;, 返回 true. 给定 word = &quot;ABCB&quot;, 返回 false. 分析：首先枚举起点，从起点开始，依次搜索下一个点的位置，在枚举的过程中，要保证和目标单词匹配。 C++ class Solution { public: int n, m; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { if (board.empty() || board[0].empty()) return false; n = board.size(), m = board[0].size(); for (int i=0; i &lt; n; i++) for (int j=0; j &lt; m; j ++) if (dfs(board, i, j, word, 0)) return true; return false; } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string&amp; word, int u) { if (board[x][y] != word[u]) return false; if (u == word.size() - 1) return true; board[x][y] = '.'; for (int i=0; i &lt; 4; i ++ ) { int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m) if (dfs(board, a, b, word, u + 1)) return true; } board[x][y] = word[u]; return false; } }; Python class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] n = len(board) m = len(board[0]) if n == 0 or m == 0: return False def dfs(x, y, u): if board[x][y] != word[u]: return False if u == len(word) - 1: return True board[x][y] = '.' for i in range(4): a = x + dx[i] b = y + dy[i] if a &gt;= 0 and a &lt; n and b &gt;=0 and b &lt; m: if dfs(a, b, u+1): return True board[x][y] = word[u] return False for i in range(n): for j in range(m): if dfs(i, j, 0): return True return False 46. Permutations 题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 分析：有两种顺序：1. 枚举每个位置上放哪个数。2. 枚举每个数放在哪个位置上。 C++ class Solution { public: int n; vector&lt;bool&gt; st; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { n = nums.size(); st = vector&lt;bool&gt;(n); dfs(nums, 0); return ans; } void dfs(vector&lt;int&gt; &amp;nums, int u) { if (u == n) { ans.push_back(path); return; } for (int i = 0; i &lt; n; i++) if (!st[i]) { st[i] = true; path.push_back(nums[i]); dfs(nums, u + 1); path.pop_back(); st[i] = false; } } }; Python (这里需要注意的是，当ans.append(path)时，只是引用了path的地址，当path变化的时候，ans中的path也是会变化的，所以如果不对path进行深拷贝的话，那么最后path会变成空，最后ans里面添加的数值都会变成空) class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: n = len(nums) st = [0] * n path = [] ans = [] def dfs(u): if u == n: path_copy = path[::1] ans.append(path_copy) # ans.append(copy.deepcopy(path)) return for i in range(n): if not st[i]: st[i] = True path.append(nums[i]) dfs(u + 1) path.pop() st[i] = False dfs(0) return ans 47. Permutations II 题目描述：给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例： 输入: [1,1,2] 输出: [ [1,1,2], [1,2,1], [2,1,1] ] 分析：枚举每个数放在哪个位置上去，搜索的时候不能重复。 先将所有相同数放在一起：排序 人为规定相同数字的相对顺序：不变 dfs(u, start) u表示枚举到了哪个数字。 start表示当前可以从哪个位置开始搜，比如把第一个1放在了第五个位置上，那么第二个1就必须从第六个位置开始搜。枚举新的数字时，start = 0，枚举相同的数字时，start 从下一位开始。 C++ class Solution { public: int n; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;bool&gt; st; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { n = nums.size(); st = vector&lt;bool&gt; (n); path = vector&lt;int&gt; (n); sort(nums.begin(), nums.end()); dfs(nums, 0, 0); return ans; } void dfs(vector&lt;int&gt;&amp; nums, int u, int start){ if (u == n) { ans.push_back(path); return; } for (int i = start; i &lt; n; i++) if (!st[i]) { st[i] = true; path[i] = nums[u]; dfs(nums, u + 1, u + 1 &lt; n &amp;&amp; nums[u + 1] == nums[u] ? i + 1 : 0); st[i] = false; } } }; 78. Subsets 题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 Note： 解集不能包含重复的子集。 空集是一个特殊的子集。 示例: 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 分析：可以用二进制表示所有的可能性，比如上面有三位数字，那么共有的可能性就有 232^323 中可能性，二进制表示的可能性如下： 000 -&gt; [] 001 -&gt; [1] 010 -&gt; [2] 011 -&gt; [1, 2] 100 -&gt; [3] 101 -&gt; [1, 3] 110 -&gt; [1, 2] 111 -&gt; [1, 2, 3] 所以通过枚举所有的二进制表示，然后如果位上是1，那么就把该位表示的数字放进来。 C++ class Solution { public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; 1 &lt;&lt; nums.size(); i ++) { vector&lt;int&gt; now; for (int j = 0; j &lt; nums.size(); j ++) if (i &gt;&gt; j &amp; 1) now.push_back(nums[j]); res.push_back(now); } return res; } }; Python class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [] for i in range(1 &lt;&lt; len(nums)): now = [] for j in range(len(nums)): if i &gt;&gt; j &amp; 1: now.append(nums[j]) res.append(now) return res 90. Subsets II 题目描述：给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 Note： 解集不能包含重复的子集。 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 分析：先统计每个数字出现的次数，次数之积就是所有可能的方案。 C++ class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); dfs(nums, 0); return ans; } void dfs(vector&lt;int&gt;&amp; nums, int u){ if (u == nums.size()) { ans.push_back(path); return; } // 计算当前数字的个数 int k = 0; while (u + k &lt; nums.size() &amp;&amp; nums[u+k] == nums[u]) k++; for (int i = 0; i &lt;= k; i ++) { dfs(nums, u + k); path.push_back(nums[u]); } // 恢复现场 for (int i = 0; i &lt;= k; i++) path.pop_back(); } }; Python(存疑) 216. Combination Sum III 题目描述：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 Note： 所有数字都是正整数。 解集不能包含重复的组合。 示例 : 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 分析： C++ class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { dfs(k, 1, n); return ans; } void dfs(int k, int start, int n){ if (!k) { if (!n) ans.push_back(path); return; } for (int i = start; i &lt;= 9; i ++) { path.push_back(i); dfs(k - 1, i + 1, n - i); path.pop_back(); } } }; 52. N-Queens II 题目描述：n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击(任意两个皇后都不能处于同一行、同一列或同一斜线上)。 示例: 输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。 [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ] 分析：由于攻击的关系，所以每行每列只能摆一个皇后。依次枚举每一行皇后的位置，需要满足以下条件： 每一列只能有一个皇后- &gt;设置数组col[n]表示是否有皇后 每一条斜线上只能有一个皇后 - &gt; 由于有两个方向的斜线，所以用d[2n-1]和ud[2n-1]表示。 C++ class Solution { public: int ans = 0, n; vector&lt;bool&gt; col, d, ud; int totalNQueens(int _n) { n = _n; col = vector&lt;bool&gt; (n); d = ud = vector&lt;bool&gt; (n * 2); dfs(0); return ans; } void dfs(int u) { if (u == n) { ans ++; return; } for (int i = 0; i &lt; n; i++) if (!col[i] &amp;&amp; !d[u + i] &amp;&amp; !ud[u - i + n]) { col[i] = d[u + i] = ud[u - i + n] = true; dfs(u + 1); col[i] = d[u + i] = ud[u - i + n] = false; } } }; 37. Sudoku Solver 题目描述：编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 '.' 表示。 Note: 给定的数独序列只包含数字 1-9 和字符 '.' 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 分析：搜索顺序：从前往后枚举每个空格该填哪个数。需要维护每一行、每一列以及每个九宫格的状态，因为每行、每列、每个九宫格中的数字不能重复，所以设定row[9][9]（一共九行，每行九个数字）、col[9][9]、cell[3][3][9]（3 × 3的格子，每个格子有九个数字）来表示状态。 Ps. 八皇后、数独都是精确覆盖问题，可以用Dancing Links来解决。 C++ class Solution { public: bool row[9][9] = {0}, col[9][9] = {0}, cell[3][3][9] = {0}; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++) { char c = board[i][j]; if (c != '.') { int t = c - '1'; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } dfs(board, 0, 0); } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) { if (y == 9) x++, y = 0; if (x == 9) return true; if (board[x][y] != '.') return dfs(board, x, y + 1); for (int i = 0; i &lt; 9; i ++) if (!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / 3][y / 3][i]) { board[x][y] = '1' + i; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if (dfs(board, x, y + 1)) return true; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; board[x][y] = '.'; } return false; } }; 473. Matchsticks to Square 题目描述：还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。 输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。 示例 : 输入: [1,1,2,2,2] 输出: true 解释: 能拼成一个边长为2的正方形，每边两根火柴。 Note: 给定的火柴长度和在 0 到 10^9之间。 火柴数组的长度不超过15。 分析：一次构造正方形的每条边。 从大到小枚举所有边 每条边内部的木棒长度规定从大到小 如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒 如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支 如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉分支 C++ ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第五周(DFS+回溯专题)/"},{"title":"LeetCode暑期打卡第四周(字符串处理专题)","content":"38. Count and Say 题目描述：报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。 11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。 21 被读作 &quot;one 2&quot;, &quot;one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 分析：每一行生成的内容都是根据上一行的内容得来的，每次需要得到连续段的个数以及数值，转成字符串即可。 C++ class Solution { public: string countAndSay(int n) { string s = &quot;1&quot;; for (int i = 0; i &lt; n -1; i++) { string ns; for (int j = 0; j &lt; s.size(); j++) { int k = j + 1; while (k &lt; s.size() &amp;&amp; s[k] == s[j]) k++; ns += to_string(k - j) + s[j]; j = k - 1; } s = ns; } return s; } }; Python class Solution: def countAndSay(self, n: int) -&gt; str: s = '1' for i in range(n-1): ns = &quot;&quot; j = 0 while j &lt; len(s): k = j + 1 while (k &lt; len(s) and s[j] == s[k]): k += 1 ns += str(k - j) + s[j] j = k - 1 j += 1 s = ns return s 49. Group Anagrams 题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例： 输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], 输出: [ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;] ] Note: 所有输入均为小写字母。 不考虑答案输出的顺序。 分析：先把每个字符串排个序，构建一个字典，每个字符串是value，排好序的是key，这样就可以把相同的放在一起。 C++ class Solution { public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for (auto str: strs) { string key = str; sort(key.begin(), key.end()); hash[key].push_back(str); } vector&lt;vector&lt;string&gt;&gt; res; for (auto item : hash) res.push_back(item.second); return res; } }; Python class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: dicts = {} for sts in strs: key = tuple(sorted(sts)) dicts[key] = dicts.get(key, []) + [sts] return list(dicts.values()) 151. Reverse Words in a String(存疑) 题目描述： 给定一个字符串，逐个翻转字符串中的每个单词。 示例： 输入: &quot; hello world! &quot; 输出: &quot;world! hello&quot; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 Note： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 分析：用python写的话可以用split和strip来处理掉无关的空格，然后再用join连接即可。 也可以分两步来做： 先把每个单词翻转 翻转整个字符串 然后再找到连续的不包含空格的一段。 C++ class Solution { public: string reverseWords(string s) { int k = 0; for (int i = 0; i &lt; s.size();) { while(i &lt; s.size() &amp;&amp; s[i] == ' ') i++; if (i == s.size()) break; int j = i; while(j &lt; s.size() &amp;&amp; s[j] != ' ') j++; reverse(s.begin()+i, s.begin()+j); if (k) s[k ++] = ' '; while(i &lt; j) s[k ++ ] = s[i ++]; } s.erase(s.begin() + k, s.end()); reverse(s.begin(), s.end()); return s; } }; Python class Solution: def reverseWords(self, s: str) -&gt; str: sts = s.strip().split(' ')[::-1] while '' in sts: sts.remove('') return &quot; &quot;.join(sts) 165. Compare Version Numbers 题目描述：比较两个版本号 version1 和 version2。 如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。 示例： 输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot; 输出: -1 分析: 每次比较每位的数字是否一样。 C++ class Solution { public: int compareVersion(string v1, string v2) { int i = 0, j = 0; while (i &lt; v1.size() || j &lt; v2.size()) { int x = i, y = j; while (x &lt; v1.size() &amp;&amp; v1[x] != '.') x++; while (y &lt; v2.size() &amp;&amp; v2[y] != '.') y++; int a = i == x ? 0 : atoi(v1.substr(i, x-i).c_str()); int b = j == y ? 0 : atoi(v2.substr(j, y-j).c_str()); if (a &gt; b) return 1; if (a &lt; b) return -1; i = x + 1, j = y + 1; } return 0; } }; Python class Solution: def compareVersion(self, v1: str, v2: str) -&gt; int: i, j = 0, 0 while (i &lt; len(v1) or j &lt; len(v2)): x = i y = j while (x &lt; len(v1) and v1[x] != '.'): x += 1 while (y &lt; len(v2) and v2[y] != '.'): y += 1 a = 0 if i == x else int(v1[i:x]) b = 0 if y == j else int(v2[j:y]) if a &gt; b: return 1 if a &lt; b: return -1 i = x + 1 j = y + 1 return 0 929. Unique Email Addresses 题目描述：如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，&quot;alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。） 如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。） 可以同时使用这两个规则。 示例： Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;] Output: 2 Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 每封 emails[i] 都包含有且仅有一个 '@' 字符。 所有本地和域名都是非空的。 本地名称不以“+”字符开头。 分析：拿到一个地址后，分成两部分：用户名和域名。对用户名进行过滤，.进行忽略，+后面忽略，然后在拼成一个新的email。然后再判断有多少个不同的即可。 C++ class Solution { public: int numUniqueEmails(vector&lt;string&gt;&amp; emails) { unordered_set&lt;string&gt; hash; for (auto email : emails) { int at = email.find('@'); string name; for (auto c : email.substr(0, at)) { if (c == '+') break; if (c != '.') name += c; } string domain = email.substr(at + 1); hash.insert(name + '@' + domain); } return hash.size(); } }; Python class Solution: def numUniqueEmails(self, emails: List[str]) -&gt; int: email_set = set() for email in emails: name = &quot;&quot; at = email.index('@') for c in email[0:at]: if c == '+': break if c != '.': name += c domain = email[at+1:] email_set.add(name + '@' + domain) return len(email_set) Python class Solution: def numUniqueEmails(self, emails: List[str]) -&gt; int: email_set = set() for email in emails: name, domain = email.split(&quot;@&quot;) if('+' in name): plus_pos = name.index('+') name = name[ : plus_pos] email_set.add(name.replace('.','')+'@'+ domain) return len(email_set) 5. Longest Palindromic Substring 题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 分析：要分奇偶两种情况，奇数就是中间的字母，偶数就是中间两个字母。然后进行暴力枚举，判断每个中心点的情况，一定会得到答案。 C++ class Solution { public: string longestPalindrome(string s) { string res; for (int i = 0; i &lt; s.size(); i ++) { // 奇数情况 for (int j = i, k = i; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++) if (res.size() &lt; (k - j + 1)) res = s.substr(j, k - j + 1); // 偶数情况 for (int j = i, k = i + 1; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++) if (res.size() &lt; (k - j + 1)) res = s.substr(j, k - j + 1); } return res; } }; Python class Solution: def longestPalindrome(self, s: str) -&gt; str: i = 0 res = &quot;&quot; while i &lt; len(s): j, k = i, i while (j &gt;=0 and k &lt; len(s) and s[j] == s[k]): if len(res) &lt; k - j + 1: res = s[j:k + 1] j -= 1 k += 1 p, q = i, i+1 while (p &gt;= 0 and q &lt; len(s) and s[p] == s[q]): if len(res) &lt; q - p + 1: res = s[p:q + 1] p -= 1 q += 1 i += 1 return res 6. ZigZag Conversion 题目描述：将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 示例： 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4 输出: &quot;LDREOEIIECIHNTSG&quot; 解释: L D R E O E I I E C I H N T S G 分析： 以n=5为例，可以看出，第一行和最后一行是等差数列，首项分别是0和n-1，中间几行是两个交错的等差数列，公差是2(n-1)。 C++ class Solution { public: string convert(string s, int n) { if (n == 1) return s; string res; for (int i = 0; i &lt; n; i++) { if (!i || i == n - 1) { for (int j = i; j &lt; s.size(); j += 2 * (n-1)) res += s[j]; } else { for (int j = i, k = 2 * (n - 1) - i; j &lt; s.size() || k &lt; s.size(); j += 2*(n-1), k += 2*(n-1)) { if (j &lt; s.size()) res += s[j]; if (k &lt; s.size()) res += s[k]; } } } return res; } }; Python class Solution: def convert(self, s: str, n: int) -&gt; str: if n == 1: return s res = &quot;&quot; i = 0 while i &lt; n: if (not i) or (i == n - 1): j = i while j &lt; len(s): res += s[j] j += 2*(n-1) else: p = i q = 2 * (n - 1) - i while p &lt; len(s) or q &lt; len(s): if p &lt; len(s): res += s[p] if q &lt; len(s): res += s[q] p += 2 * (n-1) q += 2 * (n-1) i += 1 return res 3. Longest Substring Without Repeating Characters 题目描述：给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 【这道题的要求是 ！！！找到字符串中最长的子串而不是子序列 子串即原序列中连在一起的字符串，而子序列是原序列中所有字母的集合】 示例: 输入: &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 分析：双指针算法，一个指针向前走，一个指针待命，如果前一个指针遇见了重复的字符，那么另一个指针向前走一格，构建一个哈希表表示每个字符出现的次数。 C++ class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map&lt;char, int&gt; hash; int res = 0; for (int i = 0, j = 0; i &lt; s.size(); i++) { hash[s[i]] ++; while (hash[s[i]] &gt; 1) hash[s[j++]] -- ; res = max(res, i - j + 1); } return res; } }; Python class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: res = 0 dicts = {} new_s = set(s[::]) for char in new_s: dicts[char] = 0 i, j = 0, 0 while i &lt; len(s): dicts[s[i]] += 1 while dicts[s[i]] &gt; 1: dicts[s[j]] -= 1 j += 1 res = max(i - j + 1, res) i += 1 return res Python class Solution: def lengthOfLongestSubstring(self, s): start = maxLength = 0 usedChar = {} for i in range(len(s)): if s[i] in usedChar and start &lt;= usedChar[s[i]]: start = usedChar[s[i]] + 1 else: maxLength = max(maxLength, i - start + 1) usedChar[s[i]] = i return maxLength 208. Implement Trie (Prefix Tree)（存疑） 题目描述：实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Trie trie = new Trie(); trie.insert(&quot;apple&quot;); trie.search(&quot;apple&quot;); // 返回 true trie.search(&quot;app&quot;); // 返回 false trie.startsWith(&quot;app&quot;); // 返回 true trie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true Note： 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 分析：Trie树是一个字典树，根节点为空，其它任何一个节点包含一个字母，当一个单词完成时，打一个标记。 273. Integer to English Words 题目描述：将非负整数转换为其对应的英文表示。可以保证给定输入小于2312^{31}231-1。 示例： 输入: 1234567891 输出: &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot; 分析：把整个流程分块儿，可以看出三位数是一块儿，构建这样一个函数得到三位数的表示方式，然后填入单位即可。 C++ class Solution { public: string small[20] = {&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;}; string decade[10] = {&quot;&quot;, &quot;&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;}; string big[4] = {&quot;Billion&quot;, &quot;Million&quot;, &quot;Thousand&quot;, &quot;&quot;}; string numberToWords(int num) { if (!num) return small[0]; string res; for (int i = 1000000000, j = 0; i &gt; 0; i /= 1000, j++) if (num &gt;= i) { res += get_part(num / i) + big[j] + ' '; num %= i; } while (res.back() == ' ') res.pop_back(); return res; } string get_part(int num) { string res; if (num &gt;= 100) { res += small[num / 100] + &quot; Hundred &quot;; num %= 100; } if (!num) return res; if (num &gt;= 20) { res += decade[num / 10] + ' '; num %= 10; } if (!num) return res; res += small[num] + ' '; return res; } }; Python class Solution: def numberToWords(self, num: int) -&gt; str: small = [&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;] decade = [&quot;&quot;, &quot;&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;] big = [&quot;Billion&quot;, &quot;Million&quot;, &quot;Thousand&quot;, &quot;&quot;] if not num: return small[0] res = &quot;&quot; i = 1000000000 j = 0 while i &gt; 0: if num &gt;= i: res += self.get_part(int(num // i), small, decade) + big[j] + ' ' num %= i i /= 1000 j +=1 return res.strip() def get_part(self, num, small, decade): res = &quot;&quot; if num &gt;= 100: res += small[int(num // 100)] + &quot; Hundred &quot; num %= 100 if not num: return res if num &gt;= 20: res += decade[int(num // 10)] + ' ' num %= 10 if not num: return res res += small[num] + ' ' return res ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第四周(字符串处理专题)/"},{"title":"LeetCode暑期打卡第三周(树专题)","content":"98. Validate Binary Search Tree 题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树（BST）。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例： 输入: 5 / \\ 1 4 / \\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 分析： 用递归的思想，自上往下的进行搜索判断。首先，假定根节点的值是x，它的范围是在[-∞,+∞]之间的，那么它的左子树的范围就是[-∞,x-1]之间的，假定左子树根节点的值为y，那么对它来说，它的左子树的范围是[-∞,y-1]，右子树的范围是在[y+1,x-1]。以此类推，不断判断，如果哪一个结点的值不在它所属的范围内，那么它就不是一颗BST。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { return dfs(root, INT_MIN, INT_MAX); } bool dfs(TreeNode *root, long long minv, long long maxv) { if (!root) return true; if (root-&gt;val &lt; minv || root-&gt;val &gt; maxv) return false; # 1ll的目的是为了防止溢出，因为val有可能是负无穷或正无穷 return dfs(root-&gt;left, minv, root-&gt;val -1ll) &amp;&amp; dfs(root-&gt;right, root-&gt;val +1ll, maxv); } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: return self.dfs(root, -float('inf'), float('inf')) def dfs(self, root, minv, maxv): if not root: return True if root.val &lt; minv or root.val &gt; maxv: return False return self.dfs(root.left, minv, root.val-1) and self.dfs(root.right, root.val+1, maxv) 94. Binary Tree Inorder Traversal 题目描述：给定一个二叉树，返回它的中序遍历。 示例： 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] Note: 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 分析： 可以用栈来实现中序遍历，将整棵树的最左边一条链压入栈中，每次取出栈顶元素，如果它有右子树，则将右子树压入栈中。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; auto p = root; while (p || stk.size()) { while(p) { stk.push(p); p = p-&gt;left; } p = stk.top(); stk.pop(); res.push_back(p-&gt;val); p = p-&gt;right; } return res; } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stk = [] p = root while(p or len(stk)): while p: stk.append(p) p = p.left p = stk.pop() res.append(p.val) p = p.right return res 101. Symmetric Tree 题目描述：给定一个二叉树，检查它是否是镜像对称的。 示例： 1 / \\ 2 2 / \\ / \\ 3 4 4 3 二叉树 [1,2,2,3,4,4,3] 是对称的。 Note: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 分析： 递归的方式 两个根节点的值要相等 左边的左子树与右边的右子树对称 左边的右子树与右边的左子树对称 迭代的方式 左边的树：左中右遍历 右边的树：右中左遍历 同时遍历，判断两边的值是否一样 C++(递归的方式) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (!root) return true; return dfs(root-&gt;left, root-&gt;right); } bool dfs(TreeNode* p, TreeNode* q){ // 如果是空的，则必须同时为空才对称 if (!p || !q) return !p &amp;&amp; !q; return p-&gt;val == q-&gt;val &amp;&amp; dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True return self.dfs(root.left, root.right) def dfs(self, p, q): if (not p) or (not q): return (not p) and (not q) return p.val == q.val and self.dfs(p.left, q.right) and self.dfs(p.right, q.left) C++(迭代的方式) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (!root) return true; stack&lt;TreeNode*&gt; left, right; auto l = root-&gt;left, r = root-&gt;right; while (l || r || left.size() || right.size()) { while (l &amp;&amp; r) { left.push(l), l = l-&gt;left; right.push(r), r = r-&gt;right; } if (l || r) return false; l = left.top(), left.pop(); r = right.top(), right.pop(); if (l-&gt;val != r-&gt;val) return false; l = l-&gt;right, r = r-&gt;left; } return true; } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True left, right = [], [] l, r = root.left, root.right while (l or r or len(left) or len(right)): while (l and r): left.append(l) l = l.left right.append(r) r = r.right # 上面循环结束只有两种情况:全空或者一个空，一个不空 # 一个空，一个不空肯定不对称，返回False if (l or r): return False l = left.pop() r = right.pop() if l.val != r.val: return False l = l.right r = r.left return True 105. Construct Binary Tree from Preorder and Inorder Traversal 题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。 Node: 你可以假设树中没有重复的元素。 示例： 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 分析： 前序遍历的第一个点肯定是根节点，在中序遍历中找到这个数，那么它左边的数就是左子树，右边的数就是右子树； 知道左子树的个数后，在前序遍历中就可以把左子树的前序遍历和右子树的前序遍历区分开来； 然后不断递归即可； C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: unordered_map&lt;int, int&gt; pos; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { int n = preorder.size(); for (int i =0; i &lt; n; i++) pos[inorder[i]] = i; return dfs(preorder, inorder, 0, n - 1, 0, n - 1); } TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir){ if (pl &gt; pr) return NULL; int val = preorder[pl]; int k = pos[val]; int len = k - il; auto root = new TreeNode(val); root-&gt;left = dfs(preorder, inorder, pl+1, pl+len, il, k-1); root-&gt;right = dfs(preorder, inorder, pl+len+1, pr, k+1, ir); return root; } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: pos = {} n = len(preorder) for i, char in enumerate(inorder): pos[char] = i return self.dfs(pos, preorder, inorder, 0, n-1, 0, n-1) def dfs(self, pos, preorder, inorder, pl, pr, il, ir): if pl &gt; pr: return None val = preorder[pl] k = pos[val] length = k - il root = TreeNode(val) root.left = self.dfs(pos, preorder, inorder, pl+1, pl+length, il, k-1) root.right = self.dfs(pos, preorder, inorder, pl+length+1, pr, k+1, ir) return root ✅update：可以使用pop因为前序遍历中的数字一定是某个子树的根节点，它在中序遍历中左边的数都是左子树，右边的数都是右子树，然后可以根据这个使用pop(python中可以想pop谁就pop谁)每次pop第一个数，然后找到它在中序遍历中的index，继续迭代即可。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if not preorder or not inorder: return None root = TreeNode(preorder.pop(0)) index = inorder.index(root.val) root.left = self.buildTree(preorder, inorder[:index]) root.right = self.buildTree(preorder, inorder[index+1:]) return root 102. Binary Tree Level Order Traversal 题目描述：给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 示例: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 分析：一层一层地进行，设置一个队列，每次存储这层元素，最后再把每层的元素存储到一个二维数组中即可。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(q.size()) { int len = q.size(); vector&lt;int&gt; level; for(int i = 0; i &lt; len; i++) { auto t = q.front(); q.pop(); level.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); } res.push_back(level); } return res; } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: res = [] q = [] if not root: return res q.append(root) while(len(q)): length = len(q) level = [] for i in range(length): t = q[0] del(q[0]) level.append(t.val) if t.left: q.append(t.left) if t.right: q.append(t.right) res.append(level) return res 236. Lowest Common Ancestor of a Binary Tree 题目描述:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” Note: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 示例： 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 分析： 如果以root为根的子树中包含p和q，则返回它们的公共祖先 如果只包含p/q，那么只返回p/q 如果都不包含，则返回NULL C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root || root == p || root == q) return root; auto left = lowestCommonAncestor(root-&gt;left, p, q); auto right = lowestCommonAncestor(root-&gt;right, p, q); if (!left) return right; if (!right) return left; return root; } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if root == None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not left: return right if not right: return left return root 543. Diameter of Binary Tree 题目描述：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 给定二叉树 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 Note 两结点之间的路径长度是以它们之间边的数目表示。 分析：递归时需要计算，从当前结点出发，求左右两边深度的最大值。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int ans = 0; int diameterOfBinaryTree(TreeNode* root) { dfs(root); return ans; } int dfs(TreeNode* root){ if (!root) return 0; auto left = dfs(root-&gt;left); auto right = dfs(root-&gt;right); ans = max(ans, left+right); return max(left+1, right+1); } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: self.ans = 0 def dfs(root): if not root: return 0 left = dfs(root.left) right = dfs(root.right) self.ans = max(self.ans, left+right) return max(left+1, right+1) dfs(root) return self.ans 124. Binary Tree Maximum Path Sum 题目描述：给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 输入: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 输出: 42 分析：与上道题不同返回最长的边数不同，这道题有了权重，但与上题类似，先枚举最高点。 每个点有三种情况： 向左走，root.val+L 向右走，root.val+R 不走，root.val+0 每次在这三种情况中取最大值。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int ans = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return ans; } // 返回从root向下走的最大值 int dfs(TreeNode* root){ if (!root) return 0; auto left = dfs(root-&gt;left); auto right = dfs(root-&gt;right); ans = max(ans, left+right+root-&gt;val); return max(0, root-&gt;val + max(0, max(left, right))); } }; Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def maxPathSum(self, root: TreeNode) -&gt; int: self.ans = -float('inf') def dfs(root): if not root: return 0 left = dfs(root.left) right = dfs(root.right) self.ans = max(self.ans, left+right+root.val) return max(0, root.val+max(0, left, right)) dfs(root) return self.ans 173. Binary Search Tree Iterator 题目描述：实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。 调用 next() 将返回二叉搜索树中的下一个最小的数。 Note: next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。 以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。 示例： BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.hasNext(); // return true iterator.next(); // return 20 iterator.hasNext(); // return false 分析：按照中序遍历的方法输出树中的每一个节点，next返回下一个值，hasNext返回是否存在下一个值，可以用栈的方式来进行，栈的空间大小与树的大小成正比。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class BSTIterator { public: stack&lt;TreeNode*&gt; stk; BSTIterator(TreeNode* root) { while(root) { stk.push(root); root = root-&gt;left; } } /** @return the next smallest number */ int next() { auto p = stk.top(); stk.pop(); int res = p-&gt;val; p = p-&gt;right; while (p) { stk.push(p); p = p-&gt;left; } return res; } /** @return whether we have a next smallest number */ bool hasNext() { return ! stk.empty(); } }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */ Python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class BSTIterator: def __init__(self, root: TreeNode): self.stk = [] while root: self.stk.append(root) root = root.left def next(self) -&gt; int: &quot;&quot;&quot; @return the next smallest number &quot;&quot;&quot; p = self.stk.pop() res = p.val p = p.right while p: self.stk.append(p) p = p.left return res def hasNext(self) -&gt; bool: &quot;&quot;&quot; @return whether we have a next smallest number &quot;&quot;&quot; return len(self.stk) &gt; 0 # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.next() # param_2 = obj.hasNext() 297. Serialize and Deserialize Binary Tree(存疑) 题目描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例： 你可以将以下二叉树： 1 / \\ 2 3 / \\ 4 5 序列化为 &quot;[1,2,3,null,null,4,5]&quot; Note: 这与 LeetCode 目前使用的方式一致，你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 分析：采用前序遍历的方式，因为加上了空节点，所以可以用前序遍历的方式来构建一棵唯一二叉树。一般情况下，前序遍历并不能唯一确定一棵二叉树；前序遍历+中序遍历可以唯一确定一棵二叉树。 C++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string res; dfs1(root, res); return res; } void dfs1(TreeNode* root, string &amp;res) { if (!root) { res += &quot;#,&quot;; return; } res += to_string(root-&gt;val) + ','; dfs1(root-&gt;left, res); dfs1(root-&gt;right, res); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { int u = 0; return dfs2(data, u); } TreeNode* dfs2(string &amp;data, int &amp;u) { if (data[u] == '#'){ u += 2; return NULL; } int t = 0; bool is_minus = false; if (data[u] == '-') { is_minus = true; u ++; } while (data[u] != ',') { t = t * 10 + data[u] - '0'; u ++; } u ++; if (is_minus) t = -t; auto root = new TreeNode(t); root-&gt;left = dfs2(data, u); root-&gt;right = dfs2(data, u); return root; } }; // Your Codec object will be instantiated and called as such: // Codec codec; // codec.deserialize(codec.serialize(root)); ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第三周(树专题)/"},{"title":"LeetCode暑期打卡第二周(链表专题)","content":"链表的题目可以通过画图来看！！！ 19. Remove Nth Node From End of List 题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 你能尝试使用一趟扫描实现吗？ 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 分析：对于单链表而言，要删除一个结点，首先要找到这个结点的头结点， 比如说示例中的4号结点，我们首先要找到3号结点，然后让3号结点的next指针指向下一个结点的头部，这样就可以删掉4号结点。 由于有可能删除我们的头结点，所以我们一般会创建一个虚拟结点来指向头结点。 建立一个虚拟头结点，来指向原始头结点 设定一个红指针，让它先向后走n步，然后在设定一个绿指针，两个指针同时向后移动，红指针到达最后一个结点时终止，此时绿指针就是倒数第n+1个结点。 让绿指针指向后面一个结点的头结点。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { auto dumpy = new ListNode(-1); dumpy-&gt;next = head; auto first = dumpy, second =dumpy; while (n--) first = first -&gt; next; while (first-&gt;next) { first = first-&gt;next; second = second-&gt;next; } second-&gt;next = second-&gt;next-&gt;next; return dumpy -&gt;next; } }; Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: dumpy = ListNode(-1) dumpy.next = head first, second = dumpy, dumpy while first.next: if n: n -= 1 else: second = second.next first = first.next second.next = second.next.next return dumpy.next 237. Delete Node in a Linked List 题目描述：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 示例： 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 分析：因为上一道题说过，删除某个结点需要直到它上一个结点的地址，但是现在只给了该结点的地址，所以一个做法是把它下一个节点的值赋值给它，然后删除下一个结点，因为给的并不是最后一个结点，所以是可行的。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; } }; Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next 并且这道题我们其实是用node-&gt;next的结构来替换node的结构，所以也可以这样写： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { *(node) = *(node-&gt;next); } }; 83. Remove Duplicates from Sorted List 题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例： 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 分析：从小到达排好序的链表，所以第一个结点是肯定不会被删掉的。我们从前到后进行枚举，每个结点有两种情况：1. 如果下一个点和当前点相同，删除下一个点；2. 如果下一个点和当前点不同，指针向后一位。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { auto cur = head; while (cur) { if (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; } return head; } }; Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: cur = head while cur: if cur.next and cur.next.val == cur.val: cur.next = cur.next.next else: cur = cur.next return head 61. Rotate List 题目描述：给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 解释: 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 分析：翻转就是把最后k个结点移到前面，由于k可能超过链表的长度，所以应该首先取模； 然后利用双指针，first指针首先从头往后走k步，然后second指针和first同时走，first走到结尾的时候停止，此时，first指向末尾，second指向倒数第k+1位；最后1. first-&gt;next=head； 2. head=second.next；3. second.next-&gt;null。 ps. 头结点变得情况可以用虚拟头结点 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if(!head) return NULL; int n = 0; for (auto p = head; p; p=p-&gt;next) n++; k %= n; auto first=head, second=head; while(k--) first = first-&gt;next; while(first-&gt;next) { first = first-&gt;next; second = second-&gt;next; } first-&gt;next = head; head = second-&gt;next; second-&gt;next = NULL; return head; } }; Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: if not head: return None n = 1 p = head while p.next: p = p.next n += 1 k %= n first, second = head, head while k: first = first.next k -= 1 while first.next: first = first.next second = second.next first.next = head head = second.next second.next = None return head ⭐24. Swap Nodes in Pairs 题目描述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例： Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 分析：每次枚举一对儿结点，因为这道题头结点会发生变化，所以创建虚拟头结点p，然后分别创建a、b两个结点。 修改三个指针的指向位置即可： p-&gt;next = b；a-&gt;next = b-&gt;next；b-&gt;next = a；然后挪动p 的位置，指向下一对儿结点的头部p= a。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { auto dummy = new ListNode(-1); dummy -&gt; next = head; for (auto p=dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) { auto a = p-&gt;next, b = a-&gt;next; p-&gt;next = b; a-&gt;next = b-&gt;next; b-&gt;next = a; p = a; } return dummy-&gt;next; } }; Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: dummy = ListNode(-1) dummy.next = head p = dummy while p.next and p.next.next: a = p.next b = a.next p.next = b a.next = b.next b.next = a p = a return dummy.next ⭐206. Reverse Linked List 题目描述：反转一个单链表。 示例： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 分析：翻转结点等价于把中间结点的指向位置翻转，具体做法就是： 设定两个指针a、b分别指向1，2 c = b-&gt;next; b-&gt;next=a; a = b, b = c 这样就完成了一次翻转，并且把两个指针移到到了下一个需要反转的位置。当b为空的时候，翻转结束；然后令head-&gt;next = NULL，head = a即可。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (!head) return NULL; auto a = head, b = a-&gt;next; while (b) { auto c = b -&gt; next; b-&gt;next = a; a=b, b=c; } head-&gt;next = NULL; head = a; return head; } }; Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head: return None a = head b = a.next while b: c = b.next b.next = a a = b b = c head.next = None return a ⭐92. Reverse Linked List II 题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 示例： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 分析：我们要翻转其中一段链表m-&gt;n，我们首先得知道m的位置b，它前一个点a以及n的位置c以及它后一个点d，然后因为这道题中头结点也有可能发生翻转，所以我们创建一个虚拟的头结点。 具体做法： 先建立一个虚拟头结点 求出a、b、c、d的位置，a是虚拟头结点走m-1步，依此类推... 然后复用上段代码，翻转b--c; 然后a.next = c，b.next=d。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { if (m==n) return head; auto dummy = new ListNode(-1); dummy -&gt; next = head; auto a=dummy, c=dummy; for (int i=0; i &lt; m- 1; i++) a = a-&gt;next; for (int i=0; i &lt; n; i ++) c = c-&gt;next; auto b = a-&gt;next, d = c-&gt;next; for (auto p = b, q = b-&gt;next; q != d;) { auto o = q-&gt;next; q-&gt;next = p; p = q; q = o; } a -&gt; next = c; b -&gt; next = d; return dummy-&gt;next; } }; Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: if m == n: return head dummy = ListNode(-1) dummy.next = head a, c = dummy, dummy while m-1 &gt; 0: a = a.next m -= 1 while n &gt; 0: c = c.next n -= 1 b = a.next d = c.next p, q = b, b.next while q != d: o = q.next q.next = p p, q = q, o a.next = c b.next = d return dummy.next 160. Intersection of Two Linked Lists 题目描述：编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 分析： 设定两个指针，每次向后走一位，走到头后交换出发点，如果两个链表相交，那么它们在走过a+b+c后就一定会相遇，如果最后为空，那么它们就没有相交。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { auto p = headA, q = headB; while (p!=q) { if (p) p = p-&gt;next; else p = headB; if (q) q = q-&gt;next; else q = headA; } return p; } }; Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; p, q = headA, headB while p != q: if p != None: p = p.next else: p = headB if q != None: q = q.next else: q = headA return p 142. Linked List Cycle II 题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 不允许修改链表 能否只用O(1)的空间 分析：设定两个指针，一个快指针fast（红色），一个慢指针slow（蓝色），fast指针每次走两步，slow指针每次走一步，当slow指针到b的时候，fast指针在左边c'处，离b的距离是y，由于快指针比慢指针快，所以二者会在c处相遇。相遇之后把慢指针重新放在头部，然后两个指针每次走一步，当两者相遇时一定在b点。因为第一次慢指针走到b时，走了x步，而快指针走了2x步，所以b--&gt;c'的距离是x步，整个圈的距离是x+y步，现在慢指针在开头，快指针在c处，两者每次走一步，当慢指针走x步时，快指针也走x步，就恰好相遇在b处。 C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { auto slow = head, fast = head; while (fast) { fast = fast-&gt;next; slow = slow-&gt;next; if (fast) fast = fast -&gt;next; // if (slow) slow = slow-&gt;next; else break; if (fast == slow) { slow = head; while (slow != fast) { slow = slow -&gt;next; fast = fast -&gt;next; } return slow; } } return NULL; } }; Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; slow, fast = head, head while fast: fast = fast.next slow = slow.next if fast: fast = fast.next else: break if slow == fast: slow = head while slow!= fast: slow = slow.next fast = fast.next return slow return None ⭐148. Sort List【存疑】 题目描述：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例： Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 分析：快排和归并排序的空间复杂度不满足要求， C++ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { int n = 0; for (auto p=head; p; p=p-&gt;next) n++; auto dummy = new ListNode(-1); dummy-&gt;next = head; for (int i = 1; i &lt; n; i *= 2) { auto cur = dummy; for (int j = 0; j + i &lt; n; j += i * 2) { auto left = cur-&gt;next, right = cur-&gt;next; for (int k = 0; k &lt; i; k ++) right = right-&gt;next; int l = 0, r = 0; while (l &lt; i &amp;&amp; r &lt; i &amp;&amp; right) if (left-&gt;val &lt;= right-&gt;val) { cur-&gt;next = left; cur = left; left = left-&gt;next; l ++; } else { cur-&gt;next = right; cur = right; right = right-&gt;next; r ++; } while (l &lt; i) { cur-&gt;next = left; cur = left; left = left-&gt;next; l ++; } while (r &lt; i &amp;&amp; right) { cur-&gt;next = right; cur = right; right = right-&gt;next; r ++; } cur-&gt;next = right; } } return dummy-&gt;next; } }; ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第二周(链表专题)/"},{"title":"LeetCode暑期打卡第一周(二分专题)","content":" 二分的知识点就是每次把备选答案的空间缩小一半，但是整数二分一个很蛋疼的问题就是边界问题。 二分思想： 答案是在一个区间之中，L-----R，通过中点的情况来判断答案的所处位置，然后删掉另外一边，缩小一半备选空间，然后再继续判断新的中点的情况，直到L==R找到答案。 70% 的二分题目都跟单调性有关(其余的题目虽然可以用二分但是不一定具有单调性) 95% 的题目存在两段性的性质（左边一段成立，右边一段不成立），就可以找到一个边界点。 时间复杂度：logN 二分模板 模板一： 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。 int bsearch_1(int l, int r) { while (l &lt; r) { int mid = l + r &gt;&gt; 1; // 向下取整 if (check(mid)) r = mid; else l = mid + 1; } return l; } 上面这个模板是用来求解最大值最小的问题 模板二 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。 int bsearch_2(int l, int r) { while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; // 向上取整 if (check(mid)) l = mid; else r = mid - 1; } return l; } 这个模板是用来求解最小值最大的问题 二分的流程： 先考虑二分的区间; 编写二分的代码框架; 设计一个check（性质）; 判断一下区间如何更新; 如果更新方式写的是l = mid，r = mid - 1，那么就在算mid的时候加上1 习题练习 69. Sqrt(x) 题目描述：计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 分析：首先二分的区间是[0, x]，然后确定一下判断的性质，我们想要mid2mid^2mid2&lt;=x，那么就应该用第二个模板。 C++ class Solution { public: int mySqrt(int x) { int l=0, r=x; while (l &lt; r) { int mid = l + (long long)r + 1 &gt;&gt; 1; // 防止mid溢出，所以用long long 型 if (mid &lt;= x / mid) l=mid; //并且为了防止陷入死循环，需要+1向上取整 else r = mid -1; } return l; } }; Python class Solution: def mySqrt(self, x: int) -&gt; int: l, r = 0, x while l&lt;r: mid = l + r + 1 &gt;&gt; 1 if mid &lt;= (x / mid): l = mid else: r = mid -1 return l 当然也可以选择另一个判断方式，比如mid2mid^2mid2&gt;x，此时在[0, ⌊x⌋\\left \\lfloor\\sqrt{x }\\right \\rfloor⌊x​⌋]内是不满足的，在[⌊x⌋\\left \\lfloor\\sqrt{x }\\right \\rfloor⌊x​⌋+1, x]内是满足的，所以最后返回l-1或者r-1即可 C++ class Solution { public: int mySqrt(int x) { if (x==1) return 1; if (x==0) return 0; int l=0, r=x; while (l &lt; r) { int mid = l + (long long)r &gt;&gt; 1; if (mid &gt; x/mid) r = mid; else l = mid + 1; } return l-1; } }; 35. Search Insert Position 题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 分析：首先可二分的边界条件就是数组的大小，即[0, nums.size()]，我们确定的check条件是：nums[mid] &gt;= target，那就说明target在mid的左边，需要改变 右边界r = mid，如果nums[mid] &lt; target，就说明target在mid右边，需要改变左边界，l = mid + 1。当然check条件也可以改为nums[mid] &lt; target，这样区间更新策略换一下就行。 确定一下边界条件：如果数组为空，那么应该返回0；如果target&gt;nums.back()，返回数组的长度。 updata✅:该题实际上返回的是大于等于target的元素的索引 C++ class Solution { public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { if (nums.empty() || target &gt; nums.back()) return nums.size(); int l=0, r = nums.size()-1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (nums[mid] &gt;= target) r=mid; else l = mid+1; } return l; } }; Python class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: if len(nums) == 0 or target &gt; nums[-1]: return len(nums) l = 0 r = len(nums) - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &gt;= target: r = mid else: l = mid + 1 return l 34. Find First and Last Position of Element in Sorted Array 题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别，如果数组中不存在目标值，返回 [-1, -1]。 示例： 输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] 分析：因为要返回两个位置，所以应该要用两次二分法，一次返回开始位置的索引，一次返回结束位置的索引。首先是开始位置，nums[mid] &gt;= target，然后是结束位置，nums[mid] &lt;= target。 C++ class Solution { public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { if (nums.empty()) return {-1, -1}; int l =0, r = nums.size() - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (nums[mid] &gt;= target) r = mid; else l = mid + 1; } if (nums[l] != target) return {-1, -1}; int start = l; l = 0, r = nums.size() - 1; while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (nums[mid] &lt;= target) l = mid; else r = mid - 1; } int end = r; return {start, end}; } }; Python class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: if len(nums) == 0: return [-1, -1] l, r = 0, len(nums)-1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &gt;= target: r = mid else: l = mid + 1 if nums[l] != target: return [-1, -1] else: start = l l, r = 0, len(nums)-1 while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if nums[mid] &lt;= target: l = mid else: r = mid - 1 end = r return [start, end] 74. Search a 2D Matrix 题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例： 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 分析：如果展成一列的话，那么是单调递增的，这样就可以把整个空间分成两部分，check的性质是nums[mid] &gt;= target，需要了解到的是，数组的长度是：n * m(n为矩阵的行数，n为矩阵的列数)，然后还需要把mid还原为i和j，i = mid // m，j = mid % m。 C++ class Solution { public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.empty() || matrix[0].empty()) return false; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = m * n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (matrix[mid / m][mid % m] &gt;= target) r = mid; else l = mid + 1; } return matrix[r / m][r % m] == target; } }; Python class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if len(matrix) == 0 or len(matrix[0]) == 0: return False n = len(matrix) m = len(matrix[0]) l = 0 r = m * n - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if matrix[mid // m][mid % m] &gt;= target: r = mid else: l = mid + 1 return matrix[l // m][l % m] == target 153. Find Minimum in Rotated Sorted Array 题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素，你可以假设数组中不存在重复元素。 分析：题目就是说把一个升序数组的一部分移到了数组的前面，如果用二分法来做的话，就首先应该找到一个二段性，可以把整个区间分成两部分。 如图，整个数组的分布相当于这个样子，我们想找的就是红色的这个点，判断的条件就是：nums[mid] &lt;= nums.back()，nums.back()就是蓝色的这个点，这样就把整个数组分成了两部分。 C++ class Solution { public: int findMin(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1; while(l &lt; r) { int mid = l + r &gt;&gt; 1; if (nums[mid] &lt;= nums.back()) r = mid; else l = mid + 1; } return nums[r]; } }; Python class Solution: def findMin(self, nums: List[int]) -&gt; int: l, r = 0, len(nums) - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &lt;= nums[-1]: r = mid else: l = mid + 1 return nums[l] 33. Search in Rotated Sorted Array 题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ) 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素，你的算法时间复杂度必须是 O(log n) 级别。 分析：虽然这道题没有明显的二分性，但是可以曲线救国，首先可以找到数组的最小值，把整个数组分成两块儿，然后再通过与nums.back()的比较来查看target是属于哪一块儿，再到该块儿进行二分。那第一步找到数组的最小值可以直接复用上一道题。 C++ class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { if (nums.empty()) return -1; int l = 0, r = nums.size() - 1; // 找到最小值的位置 while(l &lt; r) { int mid = l + r &gt;&gt; 1; if (nums[mid] &lt;= nums.back()) r = mid; else l = mid + 1; } // 判断target属于哪一块儿 if (target &gt; nums.back()) l = 0, r --; else r = nums.size() - 1; while (l &lt; r) { int mid = l + r + 1&gt;&gt; 1; if (nums[mid] &lt;= target) l = mid; else r = mid - 1; } // 这里只能用l，因为如果整个数组是单调的，那么之前l=r=0 // 判断属于哪一块儿后r有可能变为-1，那么第二个while循环就不会执行 // 此时nums[r] = nums[-1]会越界 if (nums[l] == target) return l; return -1; } }; Python class Solution: def search(self, nums: List[int], target: int) -&gt; int: if not nums: return -1; l, r = 0, len(nums) - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &lt;= nums[-1]: r = mid else: l = mid + 1 if target &gt; nums[-1]: l = 0 r -= 1 else: r = len(nums) - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &gt;= target: r = mid else: l = mid + 1 if target == nums[l]: return l else: return -1 278. First Bad Version 题目描述：你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例： 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 分析：很明显这是一个二分的题目，因为就相当于这是一条时间线，从中间某个节点出现问题，那么就二分了，并且都不用去想二分的性质，因为题目已经给你提供了一个接口isBadVersion。 C++ // Forward declaration of isBadVersion API. bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int l = 0, r = n; while (l &lt; r) { int mid = (long long)l + r &gt;&gt; 1; //测试的时候溢出了所以加了long long if (isBadVersion(mid)) r = mid; else l = mid + 1; } return l; } }; Python # The isBadVersion API is already defined for you. # @param version, an integer # @return a bool # def isBadVersion(version): class Solution: def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; l, r = 0, n while l &lt; r: mid = l + r &gt;&gt; 1 if isBadVersion(mid): r = mid else: l = mid + 1 return l 162. Find Peak Element 题目描述：峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 分析：考虑二分的做法，不管怎么样，数组中一定是存在一个峰值的，我们比较nums[mid] 与 nums[mid+1]的关系，如果nums[mid] &lt; nums[mid+1]，那么二分的两段中，右边必存在峰值，就算一直递增，那么端点也算峰值；反之亦然。 所以用二分的思想，必然会找到一个峰值。 update✅:每次都砍掉小的那一边，这样保证另一边中一定存在一个比较大的值，这样不管是接下来递增还是递减就一定保证会有峰值。 C++ class Solution { public: int findPeakElement(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1; while(l &lt; r) { int mid = l + r &gt;&gt; 1; // 为什么不用判断mid+1是否越界呢，因为此时mid= n - 1的话 // l = r = n - 1，没有进入while循环 if (nums[mid] &gt; nums[mid+1]) r = mid; else l = mid + 1; } return l; } }; Python class Solution: def findPeakElement(self, nums: List[int]) -&gt; int: l, r = 0, len(nums) - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if nums[mid] &gt; nums[mid+1]: r = mid else: l = mid + 1 return l 287. Find the Duplicate Number 题目描述：给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 Note： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 分析： 抽屉原理：假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。 将整个数组二分为两半，则两边至少会有一边存在重复的数，两边分别拥有的数的个数是：L = mid - l +1 ，R = r - mid + 1，现在我们的区间是[1, n]，mid就是1---&gt;n中间的那个数，举例：nums = [1,3,4,2,2]，此时的区间为[1, 4]，n= 4, mid = 2，统计小于等于mid的数的个数： for num in nums: if num &lt;= mid: cnt += 1 计算出来cnt = 3，然后来比较cnt与左边的数的个数，如果cnt &gt; L，说明 重复的这个数就在左边(这里的左边是相对区间[1, 4]来说的) C++ class Solution { public: int findDuplicate(vector&lt;int&gt;&amp; nums) { int l = 1, r = nums.size() - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; int cnt = 0; for (auto num : nums) if (num &gt;=l &amp;&amp; num &lt;= mid) cnt++; if (cnt&gt;mid-l+1) r = mid; else l = mid + 1; } return l; } }; Python class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: l, r = 1, len(nums)-1 while l &lt; r: mid = l + r &gt;&gt; 1 cnt = 0 for num in nums: if num &gt;= l and num &lt;= mid: cnt += 1 if cnt &gt; mid - l + 1: r = mid else: l = mid + 1 return l 275. H-Index II 题目描述：给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。） 分析：意思就是在一个数组中找到一个数h，使得数组中至少有h个数 &gt;= h。首先确定h的范围，h最大为n，最小为0，并且h是有二分性质的。如果h满足条件，那么h-1必然也满足...，所以小于&lt;=h的数满足答案，&gt;h的数不满足答案。用二分法找到h就行。 C++ class Solution { public: int hIndex(vector&lt;int&gt;&amp; citations) { int l = 0, r = citations.size(); while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (citations[citations.size() - mid] &gt;= mid) l = mid; else r = mid - 1; } return l; } }; Python class Solution: def hIndex(self, citations: List[int]) -&gt; int: l, r = 0, len(citations) while l &lt; r: mid = l + r +1 &gt;&gt; 1; if citations[len(citations) - mid] &gt;= mid: l = mid else: r = mid - 1; return l ","link":"https://tudouvvv.github.io/post/LeetCode暑期打卡第一周(二分法)/"},{"title":"[每日一题]-942. DI String Match","content":"升 级 打 怪 ing ~ ~ 题目地址：942. DI String Match 题目要求： 输入一个字符串S，只包含I(increase)和D(decrease)，然后A是一个从0到len(S)的数组，现在要求如果S[i] == &quot;I&quot;，那么A[i] &lt; A[i+1]；如果S[i] == &quot;D&quot;，那么A[i] &gt; A[i+1]。 思路： 必须要为后面的操作留有余地，所以遇见I的时候，拿出最小的数保证剩余的数都比它大；遇见D的时候，拿出最大的数保证剩下的数都比它小。 ---------------------- 所以我的做法是： class Solution: def diStringMatch(self, S: str) -&gt; List[int]: p = [] N = [] for i in range(len(S)+ 1): p.append(i) for char in S: if char == &quot;D&quot;: N.append(max(p)) p.remove(max(p)) else: N.append(min(p)) p.remove(min(p)) N.append(p[0]) return N 先构建一个从0到len(S)的序列(现在看来很蠢)然后遍历S，遇见D取大的，遇见I取小的，最后再把剩下的数加进去 提交后果然，Time Limit Exceeded 去讨论区看一看，我为什么要新建一个数组？？？每次取的数都是最左边或者最右边的数，直接设置两个指针指向两边即可。 class Solution: def diStringMatch(self, S: str) -&gt; List[int]: l, r, N = 0, len(S), [] for char in S: N.append(l if char =='I' else r) l, r = l +(char == 'I'), r - (char == 'D') return N + [l] 基本上大家的思路都是这样，可能写法不太一样，像我这种写法就非常的臃肿----- ","link":"https://tudouvvv.github.io/post/942-DI-String-Match/"},{"title":"[每日一题]-883. Projection Area of 3D Shapes","content":"升 级 打 怪 ing ~ ~ 题目地址：883. Projection Area of 3D Shapes 题目要求： 求一个体积为1的方块拼起来的立方体的俯视图，主视图，左视图的面积之和。 样例： 背景是一个被分为N * N 个格子的坐标轴 输入：grid = [[1, 2],[3, 4]] （输入说明：grid[0][0]表示在(0, 0)处有一个方块，grid[0][1]表示在(0, 1)处有一个方块...） 输出：17 思路： 整个面积分为三部分：top、front、left 输入的grid就相当于一个数组 top的面积就是所有非0元素的个数之和 front的面积就是每行元素的最大值之和 left的面积就是每列元素的最大值之和 top 所以top的值就需要遍历每个元素，然后统计非0元素的个数: for i in range(len(grid): for j in range(len(grid[0]): if grid[i][j] != 0: top += 1 front for i in range(len(grid)): front += max(grid[i]) left for i in range(len(grid)): left_num = 0 for j in range(len(grid[0])): left_num = max(left_num, grid[j][i]) left += left_num 完整代码： class Solution: def projectionArea(self, grid: List[List[int]]) -&gt; int: top, front, left = (0, 0, 0) for i in range(len(grid)): left_num = 0 front += max(grid[i]) for j in range(len(grid[0])): if grid[i][j] &gt; 0: top += 1 left_num = max(left_num, grid[j][i]) left += left_num return top + front + left 提交结果：48ms 48.04% 最快的解决方案： class Solution: def projectionArea(self, grid: 'List[List[int]]') -&gt; 'int': &quot;&quot;&quot; from top：grid长度之和 from front: 每行的最大值之和 from side: 每列的最大值之和 &quot;&quot;&quot; top = sum([v!=0 for row in grid for v in row]) front = sum([max(row) for row in grid]) side = [] for i in range(len(grid[0])): col = [row[i] for row in grid] side.append(max(col)) return top + front + sum(side) 思路差不多，只不过人家写的比较简洁，小技巧需要学起来呀！ ","link":"https://tudouvvv.github.io/post/883. Projection Area of 3D Shapes/"},{"title":"构建多层神经网络与初步尝试使用keras构建CNN","content":"正准备开始写这篇记录，结果发现图床坏了- -，又开始从原来的图床把之前的图片转移到新的图床，浪费了好多时间。 上次用logestic回归和梯度下降法训练了一个神经网络，用来做二分类的问题，最后精度差不多70%左右，这次主要写一个多层的神经网络，训练同样的数据集，看一看会不会对准确度有提升。 多层神经网络 多层神经网络中，也分为前向传播和后向传播，前向传播计算损失函数，后向传播通过梯度下降法来更新参数。在每一层中，先通过一个线性的激活单元Z = WX + b，然后再通过一个非线性的激活单元，这里的话由于我们做的是二分类问题，所以最后一层的激活函数选择sigmoid，其它层中选择效果比较好的Relu函数，在实际的操作中，对于一个L层的神经网络，我们需要进行L-1次Relu函数激活。 这是多层神经网络的大概结构： 前向过程就是不断的通过各层神经网络直到最后计算损失，最主要的就是后向过程，后向过程就是链式求导以便最后使用梯度下降法来更新每一层的参数 对前向过程来说： 即根据上一层的激活值通过线性单元和激活函数输出本层的激活值，其中g(Z)代表每一层的激活函数，而后向过程中，我们需要计算每一层dW和db的值以便进行后面的参数更新： 讲道理，矩阵学的不是很好，所以一旦把变量矩阵化以后进行求导操作什么的有点迷糊，这里需要再好好学习一下 这样就是整个深层神经网络的基本结构了 我们可以先把激活函数的前向和后向过程写成一个模块，以便方便调用： import numpy as np def sigmoid(Z): A = 1 / (1 + np.exp(-Z)) cache = Z return A, cache def sigmoid_backward(dA, cache): Z = cache s = 1 / (1 + np.exp(-Z)) dZ = dA * s * (1 - s) return dZ def relu(Z): A = np.maximum(0, Z) cache = Z return A, cache def relu_backward(dA, cache): Z = cache dZ = np.array(dA, copy=True) dZ[Z &lt;= 0] = 0 return dZ 接着来开始写我们的多层神经网络，第一步是对我们的数据进行预处理，由于我们输入的是64*64的图片，而且一张彩色图片有rgb三个通道，所以我们要把一张图片上三个通道的信息整合在一起作为一列，把训练集和测试集的图片的信息处理为一个矩阵，作为神经网络的输入，同时可以对输入数据进行缩小，由于像素值表示亮度，每点的像素值最大为255，我们可以每个点的像素值都除以255，使得我们的输入数据全部在[0, 1]之间。 训练集和测试集的样本数据来自已经写好的模块。 train_set_x, train_set_y, test_set_x, test_set_y, classes = load_dataset() train_set_x = train_set_x.reshape(train_set_x.shape[0], -1).T test_set_x = test_set_x.reshape(test_set_x.shape[0], -1).T train_set_x = train_set_x / 255 test_set_x = test_set_x / 255 接着应该初始化我们每一层的参数，之前对于只有一个logestic单元，初始化时可以都为0，但是对多层神经网络来说，如果W初始化为0 则对于任何X，每个隐藏层对应的每个神经元的输出都是相同的，这样即使梯度下降训练，无论训练多少次，这些神经元都是对称的，无论隐藏层内有多少个结点，都相当于在训练同一个函数，所以我们要采用随机初始化。 在多层神经网络中，每一层参数的维度都是确定的，与该层神经元的个数密切相关： 所以我们这样来初始化每一层的参数： def initialize_parameters(dims): L = len(dims) parameters = {} for l in range(1, L): parameters['W' + str(l)] = np.random.randn(dims[l], dims[l-1]) * np.sqrt(1 / dims[l - 1]) parameters['b'+ str(l)] = np.zeros((dims[l], 1)) return parameters dims为一个列表，其中包含每一层神经元的个数，比如[12288, 12, 7, 1] 这样就初始化好了每一层的变量，之前说过一个对于该多层神经网络来说，前向传播时会进行L-1次relu激活，一次sigmoid激活，每一次激活包括线性激活和激活函数激活，我们把这个操作定义成一个函数，到时候直接调用函数就可以了。 所以接下来定义每一层的线性激活部分的函数，线性激活部分主要做的就是Z = WA + B: def linear_forward(A, W, b): Z = np.dot(W, A) + b linear_cache = (A, W, b) return Z, linear_cache 这里要记得保存线性部分的参数，之后做梯度下降法的时候会用到。 然后就是定义激活函数激活的函数，激活函数做的就是A = g(Z): def activation_forward(A_pre, W, b, activation): if activation == 'relu': Z, linear_cache = linear_forward(A_pre, W, b) A, activation_cache = relu(Z) if activation == 'sigmoid': Z, linear_cache = linear_forward(A_pre, W, b) A, activation_cache = sigmoid(Z) cache = (linear_cache, activation_cache) return A, cache 在激活函数中调用之前写的线性激活函数，最后返回每一层的输出A以及参数cache。 接下来就可以进行前向过程的编写了，前向过程的输入是我们的图片信息，我们以X表示，以及每一层的参数，我们以parameters表示，这样在经过每一层的传播之后，最终得到我们的输出结果AL，我们要用它来计算损失函数的大小： def L_model_forward(X, parameters): caches = [] A = X L = len(parameters) // 2 for l in range(1, L): A_prev = A A, cache = activation_forward(A_prev, parameters['W'+str(l)], parameters['b'+str(l)], 'relu') caches.append(cache) AL, cache = activation_forward(A, parameters['W'+str(L)], parameters['b'+str(L)], 'sigmoid') caches.append(cache) return AL, caches 这样整个前向过程全部完成，接下来应该计算损失函数的大小，由于这是一个二分类问题，我们采用二元交叉熵作为我们的损失函数，它的表达式如下： def cost_compute(AL, Y): m = Y.shape[1] cost = (-1 / m) * np.sum(np.multiply(Y, np.log(AL)) + np.multiply((1 - Y), np.log(1 - AL))) cost = np.squeeze(cost) return cost 这就是整个前向过程的所有步骤了，我们以降低损失函数为目标，在后向过程中不断使用梯度下降法进行优化，逐渐逼近最低值，目前只是简单的使用梯度下降法，后面会尝试其它的优化方案，比如动量梯度下降或者mini-batch。 完成整个前向过程之后，思考一下后续的步骤，对于后向过程来说，每一个神经元先对激活函数激活的部分进行求导得到dZ，然后在对线性激活的部分求导，得到dW和db，我们首先定义线性激活的后向过程： def linear_backward(dZ, cache): A_prev, W, b = cache m = A_prev.shape[1] dW = np.dot(dZ, A_prev.T) / m db = np.sum(dZ, axis=1, keepdims=True) / m dA_prev = np.dot(W.T, dZ) return dA_prev, dW, db 接着定义激活函数激活的后向过程，我们之前已经把两个激活函数的后向求导过程定义好了，我们只要调用就好了。之前也说过，每个激活单元分为两个过程，线性激活与函数激活两个过程，我们现在调用了函数激活的后向过程，得到dZ，然后在调用上面定义的线性激活的后向过程，得到dA、dW、db： def activation_backward(dA, cache, activation): linear_cache, activation_cache = cache if activation == 'relu': dZ = relu_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) if activation == 'sigmoid': dZ = sigmoid_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) return dA_prev, dW, db 然后就可以把全部过程整合在一起，我们可以想一下这个过程，从最后一个sigmoid激活单元来说，它会经历一个上述的activation_backward过程，前提是我们需要求出损失函数对最终输出的求导就好dAL，之后调用上述函数。之后就是L-1次的relu函数的后向传播过程，这样我们就会得到每一层参数的导数，以便通过梯度下降法进行参数的更新： def L_model_backward(AL, Y, caches): grads = {} L = len(caches) m = AL.shape[1] Y = Y.reshape(AL.shape) dAL = -(np.divide(Y, AL) - np.divide((1 - Y), (1 - AL))) current_cache = caches[L - 1] grads['dA'+str(L)], grads['dW'+str(L)], grads['db'+str(L)] = activation_backward(dAL, current_cache, 'sigmoid') for l in reversed(range(L - 1)): current_cache = caches[l] grads['dA'+str(l + 1)], grads['dW'+str(l + 1)], grads['db'+str(l + 1)] = activation_backward(grads['dA'+str(l + 2)], current_cache, 'relu') return grads 现在我们来定义参数更新的函数，参数更新需要定义学习率learning_rate，它控制我们每次参数更新的步长： def up_parameters(parameters, grads, learning_rate): L = len(parameters) // 2 for l in range(L): parameters['W'+str(l+1)] = parameters['W'+str(l+1)] - learning_rate * grads['dW'+str(l+1)] parameters['b'+str(l+1)] = parameters['b'+str(l+1)] - learning_rate * grads['db'+str(l+1)] return parameters 这样所有的过程都已经全部完成了，我们现在只需调用上述的所有过程就好，我们同时还可以定义每迭代100次打印出此时的损失函数的值，同时在迭代结束后打印出损失函数的曲线，看一下我们的训练过程： def L_model(X, Y, dims, learning_rate, num_iternation, print_cost=False, isPlot=False): parameters = initialize_parameters(dims) costs = [] for i in range(num_iternation): AL, caches = L_model_forward(X, parameters) cost = cost_compute(AL, Y) grads = L_model_backward(AL, Y, caches) parameters = up_parameters(parameters, grads, learning_rate) if i % 100 == 0: costs.append(cost) if print_cost: print(&quot;第&quot;, i + 100, &quot;次迭代，成本值为:&quot;, np.squeeze(cost)) if isPlot: plt.plot(np.squeeze(costs)) plt.ylabel('cost') plt.xlabel('iterations (per tens)') plt.title(&quot;Learning rate =&quot; + str(learning_rate)) plt.show() return parameters 这样我们定义好神经网络的结构，直接调用这个函数就好，最后我们需要定义一个predict接口，以便训练好我们的神经网络以后进行测试集的预测： def predict(X, Y, parameters): m = Y.shape[1] Y_predict = np.zeros((1, m)) AL, caches = L_model_forward(X, parameters) for i in range(0, AL.shape[1]): if AL[0, i] &gt; 0.5: Y_predict[0, i] = 1 else: Y_predict[0, i] = 0 print(&quot;准确度为:&quot;, 100 - np.mean(np.abs(Y - Y_predict)) * 100, &quot;%&quot;) return Y_predict 下面是完整的代码： import numpy as np from lr_utils import load_dataset import matplotlib.pyplot as plt from c9 import sigmoid, sigmoid_backward, relu, relu_backward train_set_x, train_set_y, test_set_x, test_set_y, classes = load_dataset() train_set_x = train_set_x.reshape(train_set_x.shape[0], -1).T test_set_x = test_set_x.reshape(test_set_x.shape[0], -1).T train_set_x = train_set_x / 255 test_set_x = test_set_x / 255 def initialize_parameters(dims): L = len(dims) parameters = {} for l in range(1, L): parameters['W' + str(l)] = np.random.randn(dims[l], dims[l-1]) * np.sqrt(1 / dims[l - 1]) parameters['b'+ str(l)] = np.zeros((dims[l], 1)) return parameters def linear_forward(A, W, b): Z = np.dot(W, A) + b linear_cache = (A, W, b) return Z, linear_cache def activation_forward(A_pre, W, b, activation): if activation == 'relu': Z, linear_cache = linear_forward(A_pre, W, b) A, activation_cache = relu(Z) elif activation == 'sigmoid': Z, linear_cache = linear_forward(A_pre, W, b) A, activation_cache = sigmoid(Z) cache = (linear_cache, activation_cache) return A, cache def L_model_forward(X, parameters): caches = [] A = X L = len(parameters) // 2 for l in range(1, L): A_prev = A A, cache = activation_forward(A_prev, parameters['W' + str(l)], parameters['b' + str(l)], 'relu') caches.append(cache) AL, cache = activation_forward(A, parameters['W' + str(L)], parameters['b' + str(L)], 'sigmoid') caches.append(cache) return AL, caches def cost_compute(AL, Y): m = Y.shape[1] cost = (-1 / m) * np.sum(np.multiply(Y, np.log(AL)) + np.multiply((1 - Y), np.log(1 - AL))) cost = np.squeeze(cost) return cost def linear_backward(dZ, cache): A_prev, W, b = cache m = A_prev.shape[1] dW = np.dot(dZ, A_prev.T) / m db = np.sum(dZ, axis=1, keepdims=True) / m dA_prev = np.dot(W.T, dZ) return dA_prev, dW, db def activation_backward(dA, cache, activation): linear_cache, activation_cache = cache if activation == 'relu': dZ = relu_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) elif activation == 'sigmoid': dZ = sigmoid_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) return dA_prev, dW, db def L_model_backward(AL, Y, caches): grads = {} L = len(caches) m = AL.shape[1] Y = Y.reshape(AL.shape) dAL = -(np.divide(Y, AL) - np.divide((1 - Y), (1 - AL))) current_cache = caches[L - 1] grads['dA'+str(L)], grads['dW'+str(L)], grads['db'+str(L)] = activation_backward(dAL, current_cache, 'sigmoid') for l in reversed(range(L - 1)): current_cache = caches[l] grads['dA'+str(l + 1)], grads['dW'+str(l + 1)], grads['db'+str(l + 1)] = activation_backward(grads['dA'+str(l + 2)], current_cache, 'relu') return grads def up_parameters(parameters, grads, learning_rate): L = len(parameters) // 2 for l in range(L): parameters['W'+str(l+1)] = parameters['W'+str(l+1)] - learning_rate * grads['dW'+str(l+1)] parameters['b'+str(l+1)] = parameters['b'+str(l+1)] - learning_rate * grads['db'+str(l+1)] return parameters def L_model(X, Y, dims, learning_rate, num_iternations, print_cost=False, isPlot=False): parameters = initialize_parameters(dims) costs = [] for i in range(num_iternations): AL, caches = L_model_forward(X, parameters) cost = cost_compute(AL, Y) grads = L_model_backward(AL, Y, caches) parameters = up_parameters(parameters, grads, learning_rate) if i % 100 == 0: costs.append(cost) if print_cost: print(&quot;第&quot;, i + 100, &quot;次迭代，成本值为:&quot;, np.squeeze(cost)) if isPlot: plt.plot(np.squeeze(costs)) plt.ylabel('cost') plt.xlabel('iterations (per tens)') plt.title(&quot;Learning rate =&quot; + str(learning_rate)) plt.show() return parameters def predict(X, Y, parameters): m = Y.shape[1] Y_predict = np.zeros((1, m)) AL, caches = L_model_forward(X, parameters) for i in range(0, AL.shape[1]): if AL[0, i] &gt; 0.5: Y_predict[0, i] = 1 else: Y_predict[0, i] = 0 print(&quot;准确度为:&quot;, 100 - np.mean(np.abs(Y - Y_predict)) * 100, &quot;%&quot;) return Y_predict dims = [12288, 20, 7, 5, 1] parameters = L_model(train_set_x, train_set_y, dims, learning_rate=0.005, num_iternations=2000, print_cost=True, isPlot=True) print('训练集准确度：') Y_train_predict = predict(train_set_x, train_set_y, parameters) print('~~~~~~~~~~~~~~~~~~') print('测试集准确度：') Y_test_predict = predict(test_set_x, test_set_y, parameters) 训练结果 第 100 次迭代，成本值为: 0.6994873707865432 第 200 次迭代，成本值为: 0.6806558525294543 第 300 次迭代，成本值为: 0.6705312328121265 第 400 次迭代，成本值为: 0.6619037949674021 第 500 次迭代，成本值为: 0.6536510177438547 第 600 次迭代，成本值为: 0.6446148155840906 第 700 次迭代，成本值为: 0.634667166888006 第 800 次迭代，成本值为: 0.6221946752377217 第 900 次迭代，成本值为: 0.6056921109383494 第 1000 次迭代，成本值为: 0.5842339799894992 第 1100 次迭代，成本值为: 0.5575090729216234 第 1200 次迭代，成本值为: 0.5265284524914055 第 1300 次迭代，成本值为: 0.4923067992292893 第 1400 次迭代，成本值为: 0.45628570738509455 第 1500 次迭代，成本值为: 0.419308167347863 第 1600 次迭代，成本值为: 0.38715877890532724 第 1700 次迭代，成本值为: 0.355732703783392 第 1800 次迭代，成本值为: 0.3352978704494966 第 1900 次迭代，成本值为: 0.30310463706295426 第 2000 次迭代，成本值为: 0.29058149758066887 训练集准确度： 准确度为: 97.12918660287082 % ~~~~~~~~~~~~~~~~~~ 测试集准确度： 准确度为: 74.0 % 由于我们每次的参数都是随机初始化的，所以训练的每一次的结果都是不一样的，但是相比较上次使用logestic回归70%的准确度，这次的74%有一点点上升。(但是有的时候也有不好的情况- -) 卷积神经网络 卷积神经网络相比较全连接的神经网络，对图像更加友好。 卷积神经网络中，最重要的就是卷积核(filter)，使用卷积核在图片上移动做卷积运算，得到新的矩阵 使用不同的卷积核，我们可以得到不同的边缘特征 卷积核中的每个数都是一个参数，我们需要做的就是通过神经网络去学习这些参数 卷积以后的维度 X = (N - F) + 1，这样卷积以后有两个缺点：1、每次卷积完以后图像会缩小；2、图像的角落和边缘信息会丢失。为了解决这些问题，我们可以使用padding，在图像的边缘进行填充，这样卷积以后的维度为 X = (N + 2P - F) + 1。至于填充多少个像素，一般分为Valid 和 Same，Valid卷积不填充像素，Same卷积意味着卷积以后图片的大小不变，即 N = (N + 2P - F) + 1，此时，P = (F - 1)/2，所以卷积核的维度一般选择奇数，一方面可能是为了Padding，另一方面此时的卷积核会有一个中心点。 卷积核移动的步长也是一个参数，此时的输出维度 X = (N + 2P - F)/S + 1，【如果不是整数，向下取整】。 互相关和卷积：是否旋转镜像，但是对于卷积神经网络来说，我们把互相关的数学运算就叫做卷积 对一张图片来说，有三个通道，而卷积核的通道数必须与图片的通道数一致。比如图片是6 × 6 × 3，如果卷积核为 3 × 3 × 3，此时进行卷积时，每个通道分别卷积，然后将每个通道卷积后的结果相加，得到一个4 × 4 × 1的输出结果。这样用多个3 × 3 × 3的卷积核进行卷积，得到多个4 × 4的输出结果，相当于多个channels。 卷积以后得到4 × 4的输出结果，此时再加上偏差，相当于 Z = W*X + b，然后应用激活函数，A = g(Z)，最后把这些激活以后的结果堆叠在一起，进行下一层的卷积运算。这样做的好处就是极大的减少了参数的个数，避免过拟合。 除了卷积层，一般也经常使用池化层，来缩减模型大小，提高计算速度。池化层有两种方法，一种是Max Pooling，选取区域内的最大值，这样做可以解释为如果过滤器提取到了某个特征，那么保留其最大值。还有一种是Average Pooling，选取平均值，不过不是经常使用。池化层没有需要学习的参数，池化后通道数不会改变。池化层需要选择filter的大小和步长，一般都是取2，这种情况下会缩小一半。 卷积神经网络的优点：参数共享和稀疏连接 Keras中定义卷积神经网络 在Keras中，定义一个卷积神经网络是非常简单的： from lr_utils import load_dataset from keras import optimizers import matplotlib.pyplot as plt from keras import models from keras import layers train_set_x, train_set_y, test_set_x, test_set_y, classes = load_dataset() train_set_x = train_set_x / 255 test_set_x = test_set_x / 255 train_set_y = train_set_y.T test_set_y = test_set_y.T model = models.Sequential() model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3))) model.add(layers.MaxPooling2D((2, 2))) model.add(layers.Conv2D(64, (3, 3), activation='relu')) model.add(layers.MaxPooling2D((2, 2))) model.add(layers.Conv2D(64, (3, 3), activation='relu')) model.add(layers.Flatten()) model.add(layers.Dense(64, activation='relu')) model.add(layers.Dense(1, activation='sigmoid')) model.compile(optimizer=optimizers.sgd(lr=0.005), loss='binary_crossentropy', metrics=['accuracy']) history = model.fit(train_set_x, train_set_y, epochs=2000, batch_size=209) train_loss, train_acc = model.evaluate(train_set_x, train_set_y) test_loss, test_acc = model.evaluate(test_set_x, test_set_y) print('train_loss', train_loss, 'train_acc', train_acc) print('test_loss', test_loss, 'test_acc', test_acc) history_dict = history.history loss_values = history_dict['loss'] epochs = range(1, len(loss_values) + 1) plt.plot(epochs, loss_values, 'b', label='Train loss') plt.title('Training loss') plt.xlabel('Epochs') plt.ylabel('Loss') plt.legend() plt.show() 具体的结构是跟书上的例子一模一样，可以看一些这个卷积神经网络的结构： Using TensorFlow backend. _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_1 (Conv2D) (None, 62, 62, 32) 896 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 31, 31, 32) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 29, 29, 64) 18496 _________________________________________________________________ max_pooling2d_2 (MaxPooling2 (None, 14, 14, 64) 0 _________________________________________________________________ conv2d_3 (Conv2D) (None, 12, 12, 64) 36928 _________________________________________________________________ flatten_1 (Flatten) (None, 9216) 0 _________________________________________________________________ dense_1 (Dense) (None, 64) 589888 _________________________________________________________________ dense_2 (Dense) (None, 1) 65 ================================================================= Total params: 646,273 Trainable params: 646,273 Non-trainable params: 0 这是它的训练结果，讲道理测试集准确度竟然达到了84%，不过损失函数曲线有点不稳定： train_loss 0.17385125616520786 train_acc 0.93779904391777 test_loss 0.5197753620147705 test_acc 0.8399999928474426 后面会尝试K-折交叉验证或者加入正则项。 待续 ","link":"https://tudouvvv.github.io/post/构建深度神经网络与初步尝试使用keras构建CNN/"},{"title":"神经网络与深度学习-第二周作业","content":"学习了本周的内容，对于logistic回归和梯度下降法有了一定的了解，恰好有作业可以把学习的内容串联起来，于是动手写一下，学习过程中遇到了很多问题，感谢阿毛的友情帮助。 参考文章：Logistic Regression with a Neural Network mindset 目标：识别图片中有没有猫 步骤： 1、准备工作 下载了相关文件(数据集)，训练集共有209张图片，测试集50张图片 分类方法：有猫为1，没有猫为0 导入相关的包: import numpy as np import h5py import matplotlib.pyplot as plt import matplotlib.image as mpimg 2、数据处理 def load_dataset(): train_dataset = h5py.File('datasets/train_catvnoncat.h5', &quot;r&quot;) # h5py读取文件，要加r train_set_x_orig = np.array(train_dataset[&quot;train_set_x&quot;][:]) # 训练集数据 train_set_y_orig = np.array(train_dataset[&quot;train_set_y&quot;][:]) # 训练集标签 test_dataset = h5py.File('datasets/test_catvnoncat.h5', &quot;r&quot;) test_set_x_orig = np.array(test_dataset[&quot;test_set_x&quot;][:]) # 测试集数据 test_set_y_orig = np.array(test_dataset[&quot;test_set_y&quot;][:]) # 测试集标签 classes = np.array(test_dataset[&quot;list_classes&quot;][:]) # the list of classes train_set_y_orig = train_set_y_orig.reshape((1, train_set_y_orig.shape[0])) test_set_y_orig = test_set_y_orig.reshape((1, test_set_y_orig.shape[0])) return train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset() 这一部分代码是资料中给的，主要作用是从数据集中读取数据，直接拿来用就好。 我们可以看一下训练集中第88张图片的信息以及图片到底是什么样的： train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset() index = 88 img = train_set_x_orig[index] print(img.shape) plt.imshow(img) plt.show() &gt;&gt;&gt; (64, 64, 3) img储存的是图片信息，计算机要保存一张照片，要保存为三个独立矩阵，因为图片的像素是由三原色(R,G,B)构成的，每个矩阵保存着每个单原色在各像素处的亮度，所以img是一个维度为(64, 64, 3)的数组。 我们可以使用matplotlib这个包的image模块下的imshow函数来对图片信息进行&quot;编译&quot;,输出图片具体的样子，后面要加plt.show()来显示图片： ![](https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-10-19-88%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF.png) 编写代码来输出本次模拟的相关信息： number_train = train_set_y.shape[1] number_test = test_set_y.shape[1] number_px = train_set_x_orig.shape[1] print(&quot;训练集图片的数量:&quot;, number_train) print(&quot;测试集图片的数量:&quot;, number_test) print(&quot;每张图片的大小:&quot;, number_px, &quot;*&quot;, number_px) print(&quot;训练集数据的维数:&quot;, train_set_x_orig.shape) print(&quot;训练集标签的维数:&quot;, train_set_y.shape) print(&quot;测试集数据的维数:&quot;, test_set_x_orig.shape) print(&quot;测试集标签的维数:&quot;, test_set_y.shape) &gt;&gt;&gt; 训练集图片的数量: 209 测试集图片的数量: 50 每张图片的大小: 64 * 64 训练集数据的维数: (209, 64, 64, 3) 训练集标签的维数: (1, 209) 测试集数据的维数: (50, 64, 64, 3) 测试集标签的维数: (1, 50) 由于图片的维度是一个(64, 64, 3)的numpy数组，为了训练的方便，我们需要把一张图片上的信息整合到一起，即构造成一个(64*64*3, 1）的列向量，然后把所有的图片信息放在一个数组中，每一列储存着一张照片的信息。也就是要把训练集和数据集中的数据进行降维处理: train_x_con = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T test_x_con = test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T print(&quot;降维后训练集数据的维数:&quot;, train_x_con.shape) print(&quot;降维后测试集数据的维数:&quot;, test_x_con.shape) &gt;&gt;&gt; 降维后训练集数据的维数: (12288, 209) 降维后测试集数据的维数: (12288, 50) reshape()可以对数组进行重新构造，以训练集的数据为例，由于共有209张图片，所以我们需要得到一个列为209的数组，但是由于数据量太大，我们并不知道有多少行，reshape()方法中有一个机制，即输入负数，它会帮我们算好行数，所以我们可以这样设置 train_x_con = train_set_x_orig.reshape(-1, train_set_x_orig.shape[0])，或者我们设置行数为209，最后加.T转置数列即可：train_x_con = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T。 以前做毕设的时候有对数据进行归一化处理，因为是不同特征的数字，属于奇异样本数据，归一化以后消除不同数据量纲数字大小的影响，加快学习的速度。而在机器学习中，对数据进行标准化也是很重要的，在图片数据集中，由于每个像素点的信息最大为255，所以可以对所有数除以255，让数据集数据位于[0, 1]之间： train_set_x = train_x_con /255 test_set_x = test_x_con /255 3、记录思路 我们所需要用到的算法和函数： 我们需要做的： 1、初始化变量w,b 2、前向传播得到概率和成本值J 3、反向传播来得到成本值对w和b的导数 4、通过梯度下降法来更新变量w和b 5、重复步骤2、3、4 4、Go！ def init_variable(dim): w = np.zeros((dim, 1)) b = 0 return w, b def sigmoid(z): s = 1 / (1 + np.exp(-z)) return s 定义函数初始化变量w,b，w是每个输入特征的所占权重，所以应该是一个(64*64*3， 1)的列向量 定义前向传播函数Sigmoid的一般形式，输入参数z可以是一个numpy数组 这样，初始化工作已经完成，可以开始进行学习操作了，定义传播函数propagate得到成本值以及w和b的梯度： def propagate(w, b, X, Y): m = X.shape[1] # 前向传播 A = sigmoid(np.dot(w.T, X) + b) cost = (-1 / m) * np.sum(Y * np.log(A) + (1 - Y) * np.log(1 - A)) # 反向传播 dw = (1 / m) * np.dot(X, (A - Y).T) db = (1 / m) * np.sum(A - Y) reci = { &quot;dw&quot;: dw, &quot;db&quot;: db } return reci, cost 上面用到的公式都是视频中推导过的，np.dot()可以完成两个矩阵的乘法，np.sum()可以进行累加操作。 接下来定义梯度下降函数optimize来进行迭代，即通过最小化成本J来更新 w 和 b： def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost= False): costs = [] for i in range(num_iterations): reci, cost = propagate(w, b, X, Y) dw = reci[&quot;dw&quot;] db = reci[&quot;db&quot;] w = w - learning_rate * dw b = b - learning_rate * db if i % 100 == 0: costs.append(cost) if (print_cost) and (i % 100 == 0): print(&quot;迭代次数:%d , 误差值: %f&quot; %(i, cost)) params = { &quot;w&quot;: w, &quot;b&quot;: b } return params, costs 这里模仿参考文章，每迭代100次输出此时误差值。通过不断地迭代就完成了整个学习过程，设置迭代次数num_iterations可以决定迭代的次数，最后存储迭代结束的变量 w 和 b 用来进行预测。 预测函数predict的主要作用就是通过学习得到变量w和b进行预测得到概率，当概率大于0.5时，我们认为这张图片中有猫，设置标签值为1，当概率小于0.5时，我们认为图片中没有猫，设置标签值为0，最后将所有的标签值进行存储用来进行准确度的比较： def predict(X, Y, w, b): m = X.shape[1] Y_prediction = np.zeros((1, m)) w = w.reshape(X.shape[0], 1) A = sigmoid(np.dot(w.T, X) + b) for i in range(m): Y_prediction[0, i] = 1 if A[0, i] &gt; 0.5 else 0 return Y_prediction 最后设置main函数来调动所有的‘模块’，并通过对 训练集 和 测试集 正确标签值的比较得到本次学习过程的准确程度，将本次训练后的参数进行保存： def main(X_train, Y_train, X_test, Y_test, num_iterations, learning_rate, print_cost): w, b = init_variable(X_train.shape[0]) # 初始化变量 params, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost) # 进行学习过程 w, b = params[&quot;w&quot;], params[&quot;b&quot;] # 得到学习后的变量 Y_train_prediction = predict(X_train, Y_train, w, b) # 对训练集数据进行预测 Y_test_prediction = predict(X_test, Y_test, w, b) # 对测试集数据进行预测 print(&quot;训练集准确度:&quot;, 100 - np.mean(np.abs(Y_train - Y_train_prediction)) * 100, &quot;%&quot;) # 得到训练集准确度 print(&quot;测试集准确度:&quot;, 100 - np.mean(np.abs(Y_test - Y_test_prediction)) * 100, &quot;%&quot;) # 得到测试集准确度 data = { &quot;costs&quot; : costs, &quot;Y_prediction_test&quot; : Y_test_prediction, &quot;Y_prediciton_train&quot; : Y_train_prediction, &quot;w&quot; : w, &quot;b&quot; : b, &quot;learning_rate&quot; : learning_rate, &quot;num_iterations&quot; : num_iterations } return data # 保存相关参数 5、完整代码 import numpy as np import h5py import matplotlib.pyplot as plt def load_dataset(): train_dataset = h5py.File('datasets/train_catvnoncat.h5', &quot;r&quot;) train_set_x_orig = np.array(train_dataset[&quot;train_set_x&quot;][:]) # your train set features train_set_y_orig = np.array(train_dataset[&quot;train_set_y&quot;][:]) # your train set labels test_dataset = h5py.File('datasets/test_catvnoncat.h5', &quot;r&quot;) test_set_x_orig = np.array(test_dataset[&quot;test_set_x&quot;][:]) # your test set features test_set_y_orig = np.array(test_dataset[&quot;test_set_y&quot;][:]) # your test set labels classes = np.array(test_dataset[&quot;list_classes&quot;][:]) # the list of classes train_set_y_orig = train_set_y_orig.reshape((1, train_set_y_orig.shape[0])) test_set_y_orig = test_set_y_orig.reshape((1, test_set_y_orig.shape[0])) return train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset() # index = 88 # img = train_set_x_orig[index] # print(img) # plt.imshow(img) # plt.show() number_train = train_set_y.shape[1] number_test = test_set_y.shape[1] number_px = train_set_x_orig.shape[1] print(&quot;训练集图片的数量:&quot;, number_train) print(&quot;测试集图片的数量:&quot;, number_test) print(&quot;每张图片的大小:&quot;, number_px, &quot;*&quot;, number_px) print(&quot;训练集数据的维数:&quot;, train_set_x_orig.shape) print(&quot;训练集标签的维数:&quot;, train_set_y.shape) print(&quot;测试集数据的维数:&quot;, test_set_x_orig.shape) print(&quot;测试集标签的维数:&quot;, test_set_y.shape) train_x_con = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T test_x_con = test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T print(&quot;降维后训练集数据的维数:&quot;, train_x_con.shape) print(&quot;降维后测试集数据的维数:&quot;, test_x_con.shape) train_set_x = train_x_con /255 test_set_x = test_x_con /255 def sigmoid(z): s = 1 / (1 + np.exp(-z)) return s def init_variable(dim): w = np.zeros((dim, 1)) b = 0 return w, b def propagate(w, b, X, Y): m = X.shape[1] # 前向传播 A = sigmoid(np.dot(w.T, X) + b) cost = (-1 / m) * np.sum(Y * np.log(A) + (1 - Y) * np.log(1 - A)) # 反向传播 dw = (1 / m) * np.dot(X, (A - Y).T) db = (1 / m) * np.sum(A - Y) reci = { &quot;dw&quot;: dw, &quot;db&quot;: db } return reci, cost def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost= False): costs = [] for i in range(num_iterations): reci, cost = propagate(w, b, X, Y) dw = reci[&quot;dw&quot;] db = reci[&quot;db&quot;] w = w - learning_rate * dw b = b - learning_rate * db if i % 100 == 0: costs.append(cost) if (print_cost) and (i % 100 == 0): print(&quot;迭代次数:%d , 误差值: %f&quot; %(i, cost)) params = { &quot;w&quot;: w, &quot;b&quot;: b } return params, costs def predict(X, Y, w, b): m = X.shape[1] Y_prediction = np.zeros((1, m)) w = w.reshape(X.shape[0], 1) A = sigmoid(np.dot(w.T, X) + b) for i in range(m): Y_prediction[0, i] = 1 if A[0, i] &gt; 0.5 else 0 return Y_prediction def main(X_train, Y_train, X_test, Y_test, num_iterations, learning_rate, print_cost): w, b = init_variable(X_train.shape[0]) params, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost) w, b = params[&quot;w&quot;], params[&quot;b&quot;] Y_train_prediction = predict(X_train, Y_train, w, b) Y_test_prediction = predict(X_test, Y_test, w, b) print(&quot;训练集准确度:&quot;, 100 - np.mean(np.abs(Y_train - Y_train_prediction)) * 100, &quot;%&quot;) print(&quot;测试集准确度:&quot;, 100 - np.mean(np.abs(Y_test - Y_test_prediction)) * 100, &quot;%&quot;) data = { &quot;costs&quot; : costs, &quot;Y_prediction_test&quot; : Y_test_prediction, &quot;Y_prediciton_train&quot; : Y_train_prediction, &quot;w&quot; : w, &quot;b&quot; : b, &quot;learning_rate&quot; : learning_rate, &quot;num_iterations&quot; : num_iterations } return data if __name__ == &quot;__main__&quot;: data = main(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations=2000, learning_rate=0.005, print_cost=True) 运行结果： 训练集图片的数量: 209 测试集图片的数量: 50 每张图片的大小: 64 * 64 训练集数据的维数: (209, 64, 64, 3) 训练集标签的维数: (1, 209) 测试集数据的维数: (50, 64, 64, 3) 测试集标签的维数: (1, 50) 降维后训练集数据的维数: (12288, 209) 降维后测试集数据的维数: (12288, 50) 迭代次数:0 , 误差值: 0.693147 迭代次数:100 , 误差值: 0.584508 迭代次数:200 , 误差值: 0.466949 迭代次数:300 , 误差值: 0.376007 迭代次数:400 , 误差值: 0.331463 迭代次数:500 , 误差值: 0.303273 迭代次数:600 , 误差值: 0.279880 迭代次数:700 , 误差值: 0.260042 迭代次数:800 , 误差值: 0.242941 迭代次数:900 , 误差值: 0.228004 迭代次数:1000 , 误差值: 0.214820 迭代次数:1100 , 误差值: 0.203078 迭代次数:1200 , 误差值: 0.192544 迭代次数:1300 , 误差值: 0.183033 迭代次数:1400 , 误差值: 0.174399 迭代次数:1500 , 误差值: 0.166521 迭代次数:1600 , 误差值: 0.159305 迭代次数:1700 , 误差值: 0.152667 迭代次数:1800 , 误差值: 0.146542 迭代次数:1900 , 误差值: 0.140872 训练集准确度: 99.04306220095694 % 测试集准确度: 70.0 % 6、 learning_rate是我们的学习率α，选择学习率也是很重要的，它是我们更新变量的速率，如果太大，那么我们会错过最优解，太小的话又需要增加迭代次数，但是目前我还不知道合理的范围是什么，代码中设置的0.005是参考文章中给的，我自己尝试设置为0.5发现会出错，这方面后续会继续学习。 我们可以画图来看一下本次的成本曲线： # 画图 costs = data['costs'] plt.plot(costs) plt.ylabel('cost') plt.xlabel('iterations (per hundreds)') plt.title(&quot;Learning rate =&quot; + str(data[&quot;learning_rate&quot;])) plt.show() 可以看到伴随着迭代次数的增加，成本值在下降。 我们可以自己找一下图片，设置为64*64的，来测试一下这个的准确度： 找了8张图片，分别编号1--8，通过上面的predict函数来进行预测结果： import matplotlib.image as mpimg # 在开始处导入，主要作用是读取图片信息 img1 = mpimg.imread(&quot;test/1.jpg&quot;).reshape(-1, 1) img2 = mpimg.imread(&quot;test/2.jpg&quot;).reshape(-1, 1) img3 = mpimg.imread(&quot;test/3.jpg&quot;).reshape(-1, 1) img4 = mpimg.imread(&quot;test/4.jpg&quot;).reshape(-1, 1) img5 = mpimg.imread(&quot;test/5.jpg&quot;).reshape(-1, 1) img6 = mpimg.imread(&quot;test/6.png&quot;).reshape(-1, 1) img7 = mpimg.imread(&quot;test/7.png&quot;).reshape(-1, 1) img8 = mpimg.imread(&quot;test/8.jpg&quot;).reshape(-1, 1) img = np.hstack((img1, img2, img3, img4, img5, img6, img7, img8)) # np.hstack()主要进行拼接矩阵的作用 w = data[&quot;w&quot;] b = data[&quot;b&quot;] Y_prediction = predict(img, w, b) Y_prediction = np.squeeze(Y_prediction) # np.squeeze()主要进行矩阵降维的作用 for i in range(len(Y_prediction)): if Y_prediction[i] == 1: print(&quot;第%i张图片中有猫&quot; %(i+1)) else: print(&quot;第%i张图片中没有猫&quot; %(i+1)) 预测结果： 第1张图片中有猫 第2张图片中有猫 第3张图片中有猫 第4张图片中有猫 第5张图片中没有猫 第6张图片中有猫 第7张图片中没有猫 第8张图片中没有猫 以上!","link":"https://tudouvvv.github.io/post/神经网络与深度学习-第二周作业/"},{"title":"Python数据库学习","content":"程序员进阶之道👆 准备学习一些 进阶的知识，刚好看到这个课程，开一篇记录一下学习笔记！ 数据库，即存储数据的仓库，现在一般分为关系型数据库和非关系型数据库。 MySQL 1、在终端使用 首先学习了一些mysql的命令： 在终端中登录MySQL：mysql -u root -p mysql -V :输出版本信息并且退出 mysql -u :用户名 mysql -p :密码 回车后可以隐藏登录 mysql -P :端口号 默认3306，可不加 mysql -h :服务器名称 本地使用，默认127.0.0.1 退出 :exit；quit；\\q； 修改提示符(暂时还不知道有什么用)：prompt xxx 常用提示符：\\D--&gt;完整的日期 \\d--&gt;当前数据库 \\h--&gt;服务器名称 \\u--&gt;当前用户 MySQL语句的规范： 关键字与函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾 其它命令： 显示当前服务器版本:SELECT VERSION(); 显示当前日期时间:SELECT NOW(); 显示当前用户:SELECT USER(); 显示当前数据库:SELECT DATABASE() ; ———————————————————————————— 2、操作数据库 (Ps.{}必须输入 [] 选择输入) 1、创建数据库: CREATE {DATABASE | SCHEME} [IF NOT EXISTS] db_name; 2、设置编码方式: [DEFAULT] CHARACTER SET [=] charset_name; 3、查看Warings: SHOW WARINIGS; 4、查看创建数据库时的编码方式: SHOW CREATE DATABASE db_name; 5、查看当前服务器下的数据库列表: SHOW {DATABASES | SCHEMES}; 6、修改数据库: ALTER {DATABASE | SCHEME} [db_name] [DEFAULT] CHARACTER SET [=] charset_name； 7、删除数据库: DROP {DATABASE | SCHEME} [IF EXISTS] db_name; ———————————————————————————— 3、数据类型 数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型。 MySQL中定义数据字段的类型对数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 UNSIGNED表示无符号，一般放在数据类型的后面 ———————————————————————————— 4、数据表 数据表是数据库的最重要的组成部分之一，是其它对象的基础。 1、使用数据库: USE db_name; 2、创建数据表: CREATE TABLE [IF NOT EXISTS] table_name( Column_name(列名称） data_type(数据类型) .... , ... ); 实例：👇 ![](https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8.png) ## 3、查询数据表列表: ``` SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr] ``` ## 4、查看数据表结构: ``` SHOW COLUMNS FROM tb_name; ``` ## 5、数据插入: ``` INSERT [INTO] tbl_name [( col_name,…)] VALUES(VAL,…); ``` ## 6、修改数据: ``` UPDATE table_references SET col_name = expr1[, col_name2 = expr2…] [WHERE where_definition]; --->很重要 ``` ## 7、删除数据: ``` DELETE FROM tbl_name [WHERE where_defination]; ``` 上面都是MySQL最基础的一些知识，再往后的会慢慢学习。 ———————————————————————————— 5、用python连接mysql数据库 1、MySQLdb学习 下载了MysqlDb这个包，因为之前创建了一个数据库并且添加了一些数据： 所以会尝试连接这个数据库并对这个数据表做一些操作！！！开始用一个新包的话，官方文档有很详细的讲解 。 MySQLdb提供了connect方法来建立一个与数据库的连接，调用这个对象的close方法来关闭一个连接。通过这个连接可以创建出一个游标对象cursor，通过游标对象执行SQL语句来进行数据的增删查改。 import MySQLdb try: coon = MySQLdb.connect( host='localhost', user='root', passwd='手动打码处理', db='news', port=3306, charset='utf8' ) cursor = coon.cursor() cursor.execute('SELECT * FROM news;') rest = cursor.fetchone() cursor.close() coon.close() print(rest) except MySQLdb.Error as e: print('Error: %s' % e) &gt;&gt;&gt; (1, '丰收节后第二天 习近平考察了这个地方', 'xl', '9月25日，习近平抵达中国“最早迎接太阳的垦区', 1, datetime.datetime(2018, 9, 26, 11, 14, 44), None, '百家') 刚开始运行的时候总会报错，所以用了一个try语句来捕获错误： 查询后得知这是因为在MySQL8.0改变了认证方式，目前最新的MySQL8.0对用户密码的加密方式为caching_sha2_password, 可能MySQLdb还不支持，所以需要更改为老版本的认证方式mysql_native_password,更改方式： mysql -u root -p \\登录mysql use mysql; select user,plugin from user where user='root'; \\执行命令查看加密方式 alter user 'root'@'localhost' identified with mysql_native_password by 'yourpassword' \\执行命令修改加密方式 flush privileges \\属性权限使配置生效 反正最后成功解决错误，连接到了本地数据库输出了第一条数据(因为用了fetchone命令)，但是可以看到输出的结果是一个元组，可能会不清楚里面各个元素的含义是什么，要是想建立一种映射关系，我们需要用到cursor的description方法来查看每个字段的查询名，然后把执行sql后的结果与执行cursor.description()后的结果拼成一个字典： def get_one(self): # 准备sql sql = 'SELECT * FROM news WHERE news_type = %s ORDER BY create_at DESC' # 找到cursor cursor = self.conn.cursor() # 执行sql cursor.execute(sql, ('百家',)) print(cursor.description) # 拿到结果 rest = dict(zip([k[0] for k in cursor.description], cursor.fetchone())) # 处理数据 print(rest) print(rest['title']) # 关闭连接，cursor cursor.close() self.close_conn() return rest &gt;&gt;&gt; (('id', 2, 1, 6, 6, 0, 0), ('title', 253, 71, 600, 600, 0, 0), ('img_url', 253, 2, 600, 600, 0, 0), ('content', 253, 133, 6000, 6000, 0, 0), ('is_valid', 1, 1, 4, 4, 0, 1), ('create_at', 12, 19, 19, 19, 0, 1), ('updated_at', 12, 0, 19, 19, 0, 1), ('news_type', 253, 6, 600, 600, 0, 1)) {'id': 9, 'title': '男子3个月竟&quot;用&quot;水11吨:家中半年没人 水表自己转', 'img_url': 'xl', 'content': '近日，郑州市民刘先生向河南商报记者反映，空空如也的房子，水表却自己转起来，诡异不已。', 'is_valid': 1, 'create_at': datetime.datetime(2018, 9, 26, 11, 21, 59), 'updated_at': None, 'news_type': '百家'} 男子3个月竟&quot;用&quot;水11吨:家中半年没人 水表自己转 看到执行cursor.description()后的结果是字段的查询名和一串不知道什么意思的数字😰，第一次用了zip()和dict()两个方法，zip()可以把两个元组的对应元素一一打包，返回一个zip对象，而dict可以把两个元素组合起来变成一个字典： a = (1, 2, 3, 4) b = ('a', 'b', 'c', 'd') print(type(zip(a, b))) print(zip(a, b)) print(dict(zip(a, b))) r = ((1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')) print(dict(r)) &gt;&gt;&gt; &lt;class 'zip'&gt; &lt;zip object at 0x000001F4AADEDC88&gt; {1: 'a', 2: 'b', 3: 'c', 4: 'd'} {1: 'a', 2: 'b', 3: 'c', 4: 'd'} 还以通过fetchall()的方法获得多个数据库数据，关键是要看你的sql语句怎么写。 我们可以在sql语句中用%s，这是一种字符串格式化的语法，基本用法是将值插入到%s占位符的字符串中。 并且可以通过写sql语句和commit()来添加数据： def add(self): try: # 准备sql sql = ('INSERT INTO news (title, img_url, content, is_valid, \\ news_type) VALUES' '(%s,%s,%s,%s,%s);') # 获取连接和cursor cursor = self.conn.cursor() # 执行sql # # 提交数据到数据库 cursor.execute(sql, ('标题1', 'xl', '内容', 1, '国际')) cursor.execute(sql, ('标题2', 'xl', '内容', '你好', '国际', '123')) # 提交事务 self.conn.commit() # commit的作用是把缓存中的数据存入我们的数据库中 # 关闭cursor和连接 cursor.close() except: print('Error') self.conn.commit() # 只会提交成功的数据，失败的不会提交 # self.conn.rollback() # 如果提交的数据中出现一个错误，那么都不会被提交到数据库 self.conn.close() 在添加数据时一定要注意我们设定的数据表每个字段的类型，不能出错。 完整代码： import MySQLdb class MysqlSearch(): def __init__(self): self.get_conn() def get_conn(self): try: self.conn = MySQLdb.connect( host='127.0.0.1', user='root', passwd='mysql,,2012', db='news', port=3306, charset='utf8' ) except MySQLdb.Error as e: print('Error:%s' % e) def close_conn(self): try: if self.conn: self.conn.close() except MySQLdb.Error as e: print('Error:%s' % e) def get_one(self): # 准备sql sql = 'SELECT * FROM news WHERE news_type = %s ORDER BY create_at DESC' # 找到cursor cursor = self.conn.cursor() # 执行sql cursor.execute(sql, ('百家',)) print(cursor.description) # 拿到结果 rest = dict(zip([k[0] for k in cursor.description], cursor.fetchone())) # 处理数据 print(rest) print(rest['title']) # 关闭连接，cursor cursor.close() self.close_conn() return rest def get_more(self, page, page_size): offset = (page - 1) * page_size # 准备sql sql = 'SELECT * FROM news WHERE news_type = %s ORDER BY create_at DESC\\ LIMIT %s,%s ;' # 找到cursor cursor = self.conn.cursor() # 执行sql cursor.execute(sql, ('百家', offset, page_size)) # print(cursor.description) # 拿到结果 rest = [dict(zip([k[0] for k in cursor.description], row))for row in cursor.fetchall()] # rest = cursor.fetchall() # 处理数 # print(rest) # print(rest['title']) # 关闭连接，cursor cursor.close() self.close_conn() return rest def add(self): try: # 准备sql sql = ('INSERT INTO news (title, img_url, content, is_valid, \\ news_type) VALUES' '(%s,%s,%s,%s,%s);') # 获取连接和cursor cursor = self.conn.cursor() # 执行sql # 提交数据到数据库 cursor.execute(sql, ('标题8', 'xl', '内容', 1, '国际')) cursor.execute(sql, ('标题9', 'xl', '内容', '你好', '国际', '123')) # 提交事务 self.conn.commit() # commit的作用是把缓存中的数据存入我们的数据库中 # 关闭cursor和连接 cursor.close() except: print('Error') self.conn.commit() # 只会提交成功的数据，失败的不会提交 # self.conn.rollback() # 如果提交的数据中出现一个错误，那么都不会被提交到数据库 self.close_conn() def main(): obj = MysqlSearch() # rest = obj.get_one() rest = obj.get_more(2, 2) print(rest) # for item in rest: # print(item) # print('-------') # obj.add() if __name__ == '__main__': main() 2、ORM ORM：对象关系映射(Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换 。从效果上说，它其实是创建了一个可在编程语言里使用的--“虚拟对象数据库”。 这是百度百科里的介绍，在前面我们用mysqldb这个包的时候，它只是输出了数据库中的数据，我们还是用zip和description强行建立一种映射关系，并且还要写sql语句，而在ORM中，我们不需要关心这些东西，我们只要按照ORM的套路来就行。 常用的ORM实现方法有SqlObject、peewee、Django's ORM 、SQLAlchemy SQLAlchemy学习 https://docs.sqlalchemy.org/en/latest/orm/------&gt;官方文档地址 在MySQL中不同字符类型在sqlalchemy中都有对应的类型与之匹配，比如VARCHAR对应String，INT对应Integer。 创建一张表 如果我们想在某个数据库中创建一个表，我们首先要用到engine来与数据库建立连接，接着继承Base这个基类中的方法来同我们的数据库进行映射，接着定义数据表的每个字段的类型，最后通过下图中的方法来创建数据表： 我们可以看到Base.metadta.create_all(engine)这条语句就相当于一条sql语句，编写代码来实验一下： from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Integer, String, DateTime, Boolean # engine = create_engine('mysql://scott:tiger@localhost/foo') #官方给出的连接方法 # scott 用户名 triger 密码 foo数据库 engine = create_engine('mysql://root:手动打码此处的密码虽然没有什么卵用@localhost:3306/news_test') Base = declarative_base() # sqlalchemy定义的一个基类 class News(Base): __tablename__ = 'news' id = Column(Integer, primary_key=True) title = Column(String(200), nullable=False) img_url = Column(String(200), nullable=False) content = Column(String(2000), nullable=False) is_valid = Column(Boolean) create_at = Column(DateTime) update_at = Column(DateTime) news_type = Column(String(20)) News.metadata.create_all(engine) 可以在图形化的mysql数据库中看到，已经成功的创建了一张数据表。 新增数据 在前面学些mysqldb的时候，无论时新增数据还是删除数据，都需要借助一个游标来完成操作，而在sqlalchemy中，需要借助session： 我们来试验一下： class AddTest(): def __init__(self): self.session = Session() def add(self): news_obj = News( title='标题1', img_url='xxx/xxx/xxx.jpg', content='内容1', create_at=datetime.datetime.now(), news_type='国际' ) self.session.add(news_obj) self.session.commit() return news_obj 执行几次以后发现，数据已经被添加到数据库中了： 不过这里我有一点疑惑，因为在写sql语句的时候，我们要让id自增必须填入AUTO_INCREMENT再加主键约束才可以，不知道为什么在这里只需要标明是主键约束就可以了。 添加多条数据时，我们可以填写多个session.add()语句，也可以使用session.add_all()语句进行添加： self.session.add_all((news_obj1, news_obj2, news_obj3)) ","link":"https://tudouvvv.github.io/post/Python数据库学习/"},{"title":"猫眼电影TOP100爬取","content":"今天又是充满希望的一天 昨天刚好看了怎么把爬下来的数据存储到excle中，所以用猫眼电影TOP100拿来练手，可惜，效果不佳：构想的太过美好，以为先把一页的写好，最后加入多页的机制就好。 然后开始写爬取一页存储结果的代码，写完之后再加入爬取多页的代码，结果悲剧了，发现每次爬完一页后它存储结果的时候会把上次的结果给覆盖掉Σ(っ °Д °;)っ，找到了这个逻辑错误的地方，然后思考解决办法，纠结了半天不知道怎么修改，准备睡觉的时候灵机一动~~ 我干嘛存储的时候只存储一页啊，我为啥不设置一个空表，然后把每一页处理完的信息先存入总表，然后对总表再进行分析存储不就解决了吗。 真的是太僵硬了Σ(っ °Д °;)っ 好吧下面是所有的操作流程。 目的：爬取猫眼电影TOP100的信息 分析过程 打开猫眼电影，找到 TOP100所在的网页(http://maoyan.com/board/4) ) 每一页有十部电影，一共十页，打开开发者工具，查看我们要爬取的信息有哪些： OK，我们需要爬取电影海报链接，电影名，猫眼的ID编号，主演，上映时间，以及评分(我要吐槽一下这个评分，(╯‵□′)╯︵┻━┻为啥要分成两部分啊，好好的在一起不好吗)，每个电影的信息都在&lt;dd&gt;&lt;/dd&gt;这个节点中，然后开始写正则表达式来提取想要的信息(明明前几天才复习过正则表达式，一到用的时候就又忘记了，只能需要什么然后去翻笔记）： import requests import re import xlsxwriter as xlw import time class Movie(): root_pattern = '&lt;dd&gt;([\\s\\S]*?)&lt;/dd&gt;' # 每部电影的所有信息 pic_pattern = '&lt;img data-src=&quot;(.*?)@160w_220h_1e_1c' #海报信息 name_pattern = 'alt=&quot;(.*?)&quot; class=&quot;board-img&quot;' # 名字信息 id_pattern = 'data-val=&quot;{movieId:([\\w]*?)}&quot;' #编号信息 star_pattern = '主演：([\\s\\S]*?)&lt;/p&gt;' #主演信息 date_pattern = '&lt;p class=&quot;releasetime&quot;&gt;上映时间：([\\s\\S]*?)&lt;/p&gt;' #时间信息 score1_pattern = '&lt;i class=&quot;integer&quot;&gt;(\\d\\.)&lt;/i&gt;' #评分信息 score2_pattern = '&lt;i class=&quot;fraction&quot;&gt;(\\d)&lt;/i&gt;' 定义了一个类来复习一下类的用法，虽然并没有什么作用....这部分代码主要是定义了爬取各项信息的正则表达式。 然后先爬取整个网页的信息，用了requests这个包，也是为了复习刚看到的知识: def __get(self, url): headers = { 'User-Agent': 'Mozilla/5.0(Macintosh;Intel Mac OS X 10_13_3) \\ AppleWebKit/537.36(KHTML. like Gecko)\\ Chrome/65.0.3325.162 Safari/536.36' } response = requests.get(url, headers=headers) htmls_source = response.text return htmls_source 这里只是简单了用了request的get方法来获取网页，添加了headers来进行伪装，不然就会提示很抱歉，我们检测到您所在的网络环境存在恶意访问的信息(尴尬)...... 将网页的原始信息存储为htmls_source，然后对原始信息进行分析，也就是利用正则表达式来提取我们想要的信息： def __analysis(self, htmls_source): htmls = re.findall(Movie.root_pattern, htmls_source) anchors = [] for html in htmls: pic = re.findall(Movie.pic_pattern, html) name = re.findall(Movie.name_pattern, html) id = re.findall(Movie.id_pattern, html)[0] star = re.findall(Movie.star_pattern, html) date = re.findall(Movie.date_pattern, html) score1 = re.findall(Movie.score1_pattern, html) score2 = re.findall(Movie.score2_pattern, html) anchor = {'pic': pic, 'name': name, 'id': id, 'star': star, 'date': date, 'score1': score1, 'score2': score2} anchors.append(anchor) return anchors 首先利用findall方法和前面定义的父节点的正则表达式root_pattern来爬取单个电影的所有信息，存为一个列表htmls，每个电影的信息都是该列表中的一个元素htmls[i]，然后定义一个空表anchors准备存放爬取的信息，接着对于单个电影的信息html进行正则提取，提取以后存为一个字典命名为anchor并使用append()增加元素的方法将该字典存到我们刚才定义的空表anchors中。 因为正则提取以后的信息并不整齐，比如说'star': ['张国荣,张丰毅,巩俐\\n ']中就包括了换行符和很多的空格，我们需要处理一下： def __refine(self, anchors): return map(lambda anchor: { 'pic': anchor['pic'][0], 'name': anchor['name'][0], 'id': anchor['id'], 'star': anchor['star'][0].strip(), 'date': anchor['date'][0], 'score': anchor['score1'][0].strip() + anchor['score2'][0].strip() }, anchors) 先使用lambda表达式对每个电影信息anchor中的冗余元素进行剔除，然后用map这个类对anchors这个列表中的每个元素进行同样的操作，返回我们最终想要的信息。 接着我设置了一个展示函数将结果展示出来： def __show(self, anchors): for anchor in anchors: print('pic:', anchor['pic'], 'name:', anchor['name'], 'id:', anchor['id'], 'star:', anchor['star'], 'date:', anchor['date'], 'score:', anchor['score']) 也就是每次执行后会把结果打印出来，后来觉得还是存储起来比较好，就又定义了一个存储为excle的方法，用了xlsxwriter这个包，其实根本不了解这个包的具体操作，我也是看着别人的代码照葫芦画瓢学的： def __save_excle(self, anchors, filename): workbook = xlw.Workbook('%s.xlsx' % filename) # 这里首先对这个Workbook的类进行实例化，创建一个工作薄，然后设置存储的位置，我设置的是同级目录 sheet = workbook.add_worksheet() # 接着创建工作表 title = ['电影海报链接', '电影名', '猫眼ID编号', '主演', '上映日期', '评分'] for i in range(0, len(title)): sheet.write_string(0, i, title[i], workbook.add_format({'bold': True})) #设置表的标题，并且采用字体加粗 sheet.set_column(0, 0, 50) sheet.set_column(1, 1, 20) sheet.set_column(2, 2, 10) sheet.set_column(3, 3, 45) sheet.set_column(4, 4, 20) # 设置单独每列的单元格样式，这里我只设置了宽度 row, col = 1, 0 # row--&gt;行坐标 col--&gt;列坐标 设置写入的位置 for anchor in anchors: sheet.write_string(row, col, anchor['pic']) sheet.write_string(row, col + 1, anchor['name']) sheet.write_string(row, col + 2, anchor['id']) sheet.write_string(row, col + 3, anchor['star']) sheet.write_string(row, col + 4, anchor['date']) sheet.write_string(row, col + 5, anchor['score']) row += 1 # 写入我们爬取的数据，由于都是字符串，所以是【write_string】 workbook.close() # 关闭并保存 也是一边写，一边看别人怎么写，一边看xlsxwriter的介绍文档，写完之后发现可以用哈哈哈，然后就是定义了爬取多页的一个流程： def go(self): fin_achors = [] for i in range(10): url = 'http://maoyan.com/board/4?offset={}'.format(i*10) htmls_source = Movie.__get(self, url) anchors = Movie.__analysis(self, htmls_source) anchors = Movie.__refine(self, anchors) time.sleep(1) fin_achors.extend(anchors) # Movie.__show(self, fin_achors) Movie.__save_excle(self, fin_achors, '猫眼电影TOP100') 查看每一页的url后发现规律(吐槽斗鱼，每一页的url都相同，只能以后学了其它东西再尝试爬取了)，定义一个总的列表fin_anchors来存放爬取十页后的信息，设置一个for循环，将每一页的爬取信息利用extend()方法存放到我们定义的总表中，因为害怕爬取速度太快出现什么问题，所以增加了一个延时等待time.sleep(1)，然后对总表进行打印或者是存为excle的操作。 其实最后能解决问题也是因为看到了extend()这个方法，因为出错的时候有尝试将两个列表相加的操作，结果只是列表相加而不是元素的聚合，前面也用过append()这个方法，上网查了一下两者的区别： list.append(object) 向列表中添加一个对象object list.extend(sequence) 把一个序列seq的内容添加到列表中 music_media = ['compact disc', '8-track tape', 'long playing record'] new_media = ['DVD Audio disc', 'Super Audio CD'] music_media.append(new_media) print music_media &gt;&gt;&gt;['compact disc', '8-track tape', 'long playing record', ['DVD Audio disc', 'Super Audio CD']] 使用append的时候，是将new_media看作一个对象，整体打包添加到music_media对象中。 music_media = ['compact disc', '8-track tape', 'long playing record'] new_media = ['DVD Audio disc', 'Super Audio CD'] music_media.extend(new_media) print music_media &gt;&gt;&gt;['compact disc', '8-track tape', 'long playing record', 'DVD Audio disc', 'Super Audio CD'] 使用extend的时候，是将new_media看作一个序列，将这个序列和music_media序列合并，并放在其后面。 最终代码 import requests import re import xlsxwriter as xlw import time class Movie(): root_pattern = '&lt;dd&gt;([\\s\\S]*?)&lt;/dd&gt;' pic_pattern = '&lt;img data-src=&quot;(.*?)@160w_220h_1e_1c' name_pattern = 'alt=&quot;(.*?)&quot; class=&quot;board-img&quot;' id_pattern = 'data-val=&quot;{movieId:([\\w]*?)}&quot;' star_pattern = '主演：([\\s\\S]*?)&lt;/p&gt;' date_pattern = '&lt;p class=&quot;releasetime&quot;&gt;上映时间：([\\s\\S]*?)&lt;/p&gt;' score1_pattern = '&lt;i class=&quot;integer&quot;&gt;(\\d\\.)&lt;/i&gt;' score2_pattern = '&lt;i class=&quot;fraction&quot;&gt;(\\d)&lt;/i&gt;' def __get(self, url): headers = { 'User-Agent': 'Mozilla/5.0(Macintosh;Intel Mac OS X 10_13_3) \\ AppleWebKit/537.36(KHTML. like Gecko)\\ Chrome/65.0.3325.162 Safari/536.36' } response = requests.get(url, headers=headers) htmls_source = response.text return htmls_source def __analysis(self, htmls_source): htmls = re.findall(Movie.root_pattern, htmls_source) anchors = [] for html in htmls: pic = re.findall(Movie.pic_pattern, html) name = re.findall(Movie.name_pattern, html) id = re.findall(Movie.id_pattern, html)[0] star = re.findall(Movie.star_pattern, html) date = re.findall(Movie.date_pattern, html) score1 = re.findall(Movie.score1_pattern, html) score2 = re.findall(Movie.score2_pattern, html) anchor = {'pic': pic, 'name': name, 'id': id, 'star': star, 'date': date, 'score1': score1, 'score2': score2} anchors.append(anchor) return anchors def __refine(self, anchors): return map(lambda anchor: { 'pic': anchor['pic'][0], 'name': anchor['name'][0], 'id': anchor['id'], 'star': anchor['star'][0].strip(), 'date': anchor['date'][0], 'score': anchor['score1'][0].strip() + anchor['score2'][0].strip() }, anchors) def __show(self, anchors): for anchor in anchors: print('pic:', anchor['pic'], 'name:', anchor['name'], 'id:', anchor['id'], 'star:', anchor['star'], 'date:', anchor['date'], 'score:', anchor['score']) def __save_excle(self, anchors, filename): workbook = xlw.Workbook('%s.xlsx' % filename) sheet = workbook.add_worksheet() title = ['电影海报链接', '电影名', '猫眼ID编号', '主演', '上映日期', '评分'] for i in range(0, len(title)): sheet.write_string(0, i, title[i], workbook.add_format({'bold': True})) sheet.set_column(0, 0, 50) sheet.set_column(1, 1, 20) sheet.set_column(2, 2, 10) sheet.set_column(3, 3, 45) sheet.set_column(4, 4, 20) row, col = 1, 0 for anchor in anchors: sheet.write_string(row, col, anchor['pic']) sheet.write_string(row, col + 1, anchor['name']) sheet.write_string(row, col + 2, anchor['id']) sheet.write_string(row, col + 3, anchor['star']) sheet.write_string(row, col + 4, anchor['date']) sheet.write_string(row, col + 5, anchor['score']) row += 1 workbook.close() def go(self): fin_achors = [] for i in range(10): url = 'http://maoyan.com/board/4?offset={}'.format(i*10) htmls_source = Movie.__get(self, url) anchors = Movie.__analysis(self, htmls_source) anchors = Movie.__refine(self, anchors) time.sleep(1) fin_achors.extend(anchors) # Movie.__show(self, fin_achors) Movie.__save_excle(self, fin_achors, '猫眼电影TOP100') movie = Movie() movie.go() 最终结果 目录信息 我这里设置的是同级目录，也可以在__save_excle中修改成别的目录 爬取信息 明天尝试爬一下豆瓣的TOP250哈哈哈哈哈 爬取豆瓣后续： 本来以为是改几个变量的值就可以了 = = 没想到还是遇到了点儿问题 分析正则表达式的时候使用排名第一的肖申克的救赎进行分析的，按照流程，一切都很正常，然后我准备储存进excle的时候出现了问题： 噢，看来是存储主演姓名的时候出错了，出错原因并不清楚，然后百度了一下： Python不支持dict的key为list或dict类型，因为list和dict类型是unhashable（不可哈希）的。 虽然不知道啥叫不可哈希，但是也差不多清楚了，可能是我的star名的key值没有转换过来，去看了一下，果然： 数据精炼的时候，我的star还是列表，应该取列表里的元素的，于是我在后面加入了[0],以为这下可以成功了，结果又出错了： 这又是什么错误？？？列表超出范围？？？什么鬼？？？于是我又百度了一下，找到了原因： 这个错误出现大约有两种情况： 第1种可能情况 list[index]index超出范围 第2种可能情况 list是一个空的 没有一个元素 进行list[0]就会出现该错误 嗯？？？难道是我的star是空的？？？不可能啊，当时还打印出anchors[0]看过的啊，有值啊，难道是别的电影？？？于是我打开豆瓣TOP250，看了一下： 果然，我发现有一部电影的star有一点不一样，这什么鬼啊，导演名字这么长？？？为什么后面三个点...以后就没东西了啊，除非你点进这部电影的详情页，否则你是看不到主演姓名的(暂时发现是这样)，所以又遇到了一个问题： 爬虫有的时候会匹配到空值，这个时候应该怎么处理？？ 最后我写了一个if语句来判断如果star值为空，那么强行给star赋值为None，额，好像有点儿奇怪，反正先这样吧： star = re.findall(star_pattern, html) if star == []: star = 'None' 就这样，成功的解决了问题，并且这一次我是把每个部分的函数拆个一个一个模块来写的: 最后成功获得了豆瓣TOP250的详细名单： ","link":"https://tudouvvv.github.io/post/猫眼电影TOP100爬取/"},{"title":"Python学习日记","content":"复试完之后就一直没有整理当时做的笔记，正好这几天学习爬虫相关知识的时候有些知识点都忘记了，便索性重新看一遍学习python的视频，把笔记好好整理一下( •̀ ω •́ ）。 Python学习日记 日记一 数字与字符串 1、数字 1、整形与浮点数 数字：一般为整形与浮点数 整数用int表示，浮点数用float表示 通过type函数来查元素看类型: print(type(float(0.1))) &gt;&gt;&gt; &lt;class 'float'&gt; 两个整形相除得到浮点数: print(type(1/1)) &gt;&gt;&gt; &lt;class 'float'&gt; 如果想得到整形，可以这样： print(type(1//1)) &gt;&gt;&gt; &lt;class 'int'&gt; //即整除，只保留整数位 2、各种进制的表示与转换 表示的方法： ob表示二进制，比如说0b10就是十进制的2： print(0b10) &gt;&gt;&gt; 2 0o表示八进制，比如说0o10就是十进制的8： print(0o10) &gt;&gt;&gt; 8 0x表示十六进制，比如说0x10就是十进制的16： print(0x10) &gt;&gt;&gt; 16 转换的方法： bin可以把其它进制的数字转换为二进制： print(bin(2)) &gt;&gt;&gt; ob10 int可以把其他进制的数字转换为十进制： print(int(0xa)) &gt;&gt;&gt; 10 oct可以把其他进制的数字转换为八进制： print(oct(8)) &gt;&gt;&gt; 0o10 hex可以把其他进制的数字转换为十六进制： print(hex(15)) &gt;&gt;&gt; 0xf 3、布尔类型 Number：数字，不仅包括整形和浮点数，还有布尔型和复数。 bool布尔类型：表示真、假，一般用True、False表示（首字母大写）： print(int(True)) &gt;&gt;&gt; 1 print(int(False)) &gt;&gt;&gt; 0 所以说布尔类型属于数字。 一般来说，bool(非0）表示真，bool（0）表示假： print(bool(0)) &gt;&gt;&gt; False 拓展： bool('字符串'）表示真 bool(' ')表示假 bool(None)表示假 2、字符串 1、字符串简介 字符串一般形式为'abc'，单引号表示字符串(双引号也可以)，需成对出现，如果元素中有引号，为避免歧义，可以用反斜杠 \\ ，也可以用双引号加单引号混合： print('let\\'s go') print(&quot;let's go&quot;) &gt;&gt;&gt; let's go &gt;&gt;&gt; let's go 如果需要输入或者输出多行字符串，需要用三引号： print('''abc def xyz''') &gt;&gt;&gt; abc def xyz 也可以在每行字符串的末尾添加反斜杠 \\ 来进行换行操作： print('abc\\ def\\ xyz') &gt;&gt;&gt; abcdefxyz 在字符串前加r(大小写都行)，可以抵消转义字符，变成原始字符串： print(r'hello \\n world') &gt;&gt;&gt; hello \\n world 本来 \\n 是换行符，输出结果应该是这样的： hello world 但是加r以后，转义字符\\n就不起作用了 2、字符串运算 字符串可以进行加法和乘法运算，比如: print('hello'+' '+'world') print(('hello'+' ')*3) &gt;&gt;&gt; hello world hello hello hello 对于一个字符串，可以把它看作一个数组，用[ ]来访问字符串的元素，下标从0开始: print('hello world'[0]) &gt;&gt;&gt; h 负数从最末尾开始，-1是最右边的元素： print('hello world'[-1]) &gt;&gt;&gt; d 字符串截取一组字符，也就是切片操作，需要一个起点加一个终点: print('hello world'[0:5]) &gt;&gt;&gt; hello ps:终点的数字是截取的元素的下一位的下标。 而负数（-x）代表步长，即末尾往回数x个字符： print('hello world'[0:-7]) &gt;&gt;&gt; hell 所以说，我们如果想要截取hello world里的world时，现在有两种方法： print('hello world'[6:11]) print('hello world'[-5:]) &gt;&gt;&gt; world world 第一种方法中，第11个字符是不存在的，所以在[m:n]中，当n大于字符串的所有长度时，会取到最后一个字符，即： print('hello world'[6:100]) &gt;&gt;&gt; world 第二种方法中，n为空，空代表会截取到末尾最后一个字符，当字符串非常长时，可以用这中方法，即： print('hello world'[-5:]) &gt;&gt;&gt; world “组”的概念与定义 Python中表示组的方式有很多 1、列表(list) 1、列表的定义 python中列表用[ ] 表示，列表中的元素用逗号分隔： print(type([1,2,3,4])) &gt;&gt;&gt; &lt;class 'list'&gt; 列表中的元素类型可以多样(数字，字符串，布尔类型以及其它类型）: print(type([1,2,'hello','python',True,False])) &gt;&gt;&gt; &lt;class 'list'&gt; 列表中可以嵌套列表，即二维数组： print(type([[1,2],[3,4],['hello',True]])) &gt;&gt;&gt; &lt;class 'list'&gt; 2、列表的基本操作 访问列表中的元素时，我们可以用索引的方式，以游戏中的技能为例，施放一个技能时： print(['技能一','技能二','技能三','技能四'][2]) &gt;&gt;&gt; 技能三 如果我们想用连招时，可以用切片的方式： print(['技能一','技能二','技能三','技能四'][1:3]) &gt;&gt;&gt; ['技能二', '技能三'] 索引访问时，访问得到的元素是字符串，但是切片访问时，得到的是一个列表，即使这个列表只有一个元素。（很重要） 列表同样可以进行加法和乘法操作： print(['技能一','技能二','技能三','技能四']+['被动技能']) print(['技能一']*3) &gt;&gt;&gt; ['技能一', '技能二', '技能三', '技能四', '被动技能'] ['技能一', '技能一', '技能一'] 2、元组(tuple) python中元组用( )表示，同样地各元素用逗号分隔，同列表一样，元组中的元素种类多样，可以进行索引和切片访问，可以进行加法和乘法操作： print(type((1,2,'hello',True))) print((1,2,3,'peace',False)[-1]) print((1,2,3)+('world',)) &gt;&gt;&gt; &lt;class 'tuple'&gt; False (1, 2, 3, 'world') 这里需要注意一点，当元组中只有一个元素时，会引起歧义，所以一般情况下，我们定义只有一个元素的元组时，在元素后面加一个逗号(上面第三个print),避免歧义。 3、序列总结 在python中，list，str，tuple都是序列，序列共有的操作： 1、获取元素，序列中每个元素都将分配一个序号： print('hello world'[1]) &gt;&gt;&gt; e 2、切片: print('hello world'[1:3]) &gt;&gt;&gt; el 三个数字时，[m:n:x]，x代表步长： print('abcdefg'[1:7:2]) &gt;&gt;&gt; bdf 3、序列可以加和乘 4、in可以判断某个元素是否在序列中,not in 可以判断是否不在序列中: print('a' in 'a hello world') print('a' not in 'a hello world') &gt;&gt;&gt; True False 5、len()可以得到序列中元素的个数: print(len([1,2,3,4,5,6,7,8])) &gt;&gt;&gt; 8 max()可以得到序列中元素的最大值,同理min()可以得到序列中的最小值: print(min('hello world')) &gt;&gt;&gt; 这里并不是什么都没有，而是输出了空格' '，在对字母进行大小比较时，比较的是各自的Ascll码， ord()可以得到元素的ascll码: print(ord(' ')) &gt;&gt;&gt; 32 即空格的Ascll码为32，在上述比较操作中是最小的。 Ps.在python中，列表和元组的区别就是，列表是可变的，因为列表可以添加或者是删除元素，而元组一旦定义，就不可变了，这也在一定程度上提高了代码的安全性，所以能用元组的时候一定要用元组。 4、集合(set) 1、集合(set)的特性 集合用{ }来定义,相邻元素用逗号隔开： print(type({True,2,3})) &gt;&gt;&gt; &lt;class 'set'&gt; 集合是无序的(与序列的区别），内部元素没有序号，不能进行索引和切片操作。 集合内部元素不会重复： print({1,1,2,2,3,3,4,'a','a'}) &gt;&gt;&gt; {1, 2, 3, 4, 'a'} 集合可以用len()来看长度，可以用 in 和 not in 来判断某个元素是否在其中。 2、集合(set)特殊的操作 个人感觉python中的集合与数学中的集合概念差不多，所以对于集合来说，可以求差集，并集以及交集。 求两个集合的差集，用 - 来实现，即A-AB： A = {1,2,3,4,5,6} B = {3,4,7} print(A-B) &gt;&gt;&gt; {1, 2, 5, 6} 求两个集合的交集，用 &amp; 来实现： A = {1,2,3,4,5,6} B = {3,4,7} print(A&amp;B) &gt;&gt;&gt; {3，4} 把两个集合合并，用 | 来实现： A = {1,2,3,4,5,6} B = {3,4,7} print(A|B) &gt;&gt;&gt; {1, 2, 3，4，5，6，7} 定义空集合，要用set() 5、字典(dict) 字典(dict)相当于集合，是无序的，字典元素包括关键字key和值value，用{ }来定义： print(type({'a':1,'b':2})) &gt;&gt;&gt; &lt;class 'dict'&gt; 我们可以通过key来访问value，比如说： print({ 'Q':'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}['Q']) &gt;&gt;&gt; 新月打击 字典中不允许有重复的key出现，每次访问元素可以通过key来进行访问 value可以取任意一种数据类型（str，int，lit，dict...) 但是字典中的key为不可变类型，所以说key目前不能取序列，可以取元组。 空字典用{ }来定义： print(type({})) &gt;&gt;&gt; &lt;class 'dict'&gt; 基本数据类型总结 日记二 变量与运算符 1、变量 变量就是一个名字。 定义一个变量： A = [1,2,3] print(A) &gt;&gt;&gt; [1, 2, 3] 上式中的等号为赋值符号 命名时一定要知道意义，命名可读性要好，用原生地道的英文命名，尽量不要用汉语拼音来命名。 1、变量的命名规则 变量名只能使用字母，数字，下划线，可以任意组合但是首字母不能是数字 系统保留的关键字不能用作变量名 变量名区分大小写，变量没有类型限制，前面学过的数据类型都可以成为变量 2、值类型和引用类型 在python中，int、str、tuple是值类型，它们的值不可变。list、dict、set是引用类型，它们的值可变。 id（）可以显示变量在内存中的地址 3、列表的可变与元组的不可变 列表(list)值可变，可以增加元素，通过x.apppend()来增加元素: A = [1,2,3] A.append('a') print(A) &gt;&gt;&gt; [1, 2, 3, 'a'] 元组不可变，也不能增加元素。 编码保持代码的稳定性，在多人完成的项目中，代码之间的调用中，不可变类型的优势比较好。 2、运算符 1、运算符号 算数运算符：+ - * / ``//代表整除 %代表求余 **代表平方 赋值运算符:= += .... 比较（关系）运算符:&gt; &lt; != ... 逻辑运算符:and or not 成员运算符:in not in 身份运算符:is is not 位运算符 运算符有很多，上面只是罗列了一些，需要记住这些大的分类，具体的可以等用的时候再去查询。 2、赋值运算符 赋值运算符的意义就是赋值，包括=、+=、-=、*=、%=、**=、/=、//=，它所进行的操作就是在运算的基础上再赋值： a = 2 b = 3 b*=a print(b) &gt;&gt;&gt; 6 即b = b*a Python中没有i++，i--这种自增运算符 3、比较运算符 关系运算符(比较运算符)不仅仅限于数字，包括：==，！=，&gt;，&lt;，&gt;=，&lt;=,操作完成后返回布尔值： print('a'&gt;'b') &gt;&gt;&gt; False 字符串、列表、元组都可以进行比较（通过Ascll码），从第一个元素开始，只要第一个元素比较出结果则立即返回结果，字典不能相互比较。 b = 2 b+=b&lt;1 print(b) &gt;&gt;&gt; 2 在上面的代码中，主体是赋值运算符，所以先进行b&lt;1的判断，结果是False,所以变成b+=False,而前面学过，False=0，所以最后结果是2 4、逻辑运算符 逻辑运算符，操作类型为布尔类型，返回类型也为布尔类型。 and（与），两个都为真时返回True,一个为假即为假： print(1 and False) &gt;&gt;&gt; False or（或），一个为真时就可以返回True not（非），not True&gt;&gt;&gt;False 对于整数和浮点数来说，0被认为False，非0的数被认为True 对字符串，列表，元组，集合，字典来说空为False 要理解三个逻辑运算符的判断规则 5、成员运算符 成员运算符判断一个元素是否在一组元素内，包括in\\not in 字典(dict)的成员运算符在判断时只判断key的值而不是value的值： print('a' in {3:'a'}) print('a' in {'a':3}) &gt;&gt;&gt; False True 6、身份运算符 身份运算符比较身份（内存地址）是否相同，返回结果为布尔值 is 和 == 的区别： a = 1 b = 1.0 print(a==b) print(a is b) &gt;&gt;&gt; True False 关系运算符只比较值的大小，而身份运算符比较身份，即内存地址，可用id()来查看 思考题 题目一： a = {1,2,3} b = {2,1,3} print(a == b) print(a is b) &gt;&gt;&gt; True False 题目二： c = (1,2,3) d = (2,1,3) print(c==d) print(c is d) &gt;&gt;&gt; False False 原因是：集合是无序的，所以进行关系运算时，a和b的值相同，得到True。但a和b在内存中的地址不同，所以进行身份运算时，得到False 第二题，元组是有序的，所以a和b是不同的 7、如何判断变量的值、身份与类型 对象的特征：值、身份、类型 类型判断，可以用type()加关系运算符来进行： a = 'abc' print(type(a)==str) &gt;&gt;&gt; True 也可以用 isinstance()函数来进行判断,它有两个参数，一个是我们要判断的变量，一个是我们要判断的类型: a = 'abc' print(isinstance(a,str)) &gt;&gt;&gt; True isinstance()函数的第二个参数可以取元组，判断时只要是元组里任意一个元素就可以： a = 'abc' print(isinstance(a,(str,int,dict))) print(isinstance(a,(float,int,dict))) &gt;&gt;&gt; True False 8位运算符 位运算符，包括按位与 &amp; 、按位或 | 等，它在运算时把参与的数字当作二进制数进行运算，按位与比较时同一为一，按位或比较时只要有一个一就是一 分支、循环、条件和枚举 1、表达式 表达式是运算符与操作数所构成的序列，各运算符是有顺序的 思考题 a = 1 b = 2 c = 3 print(a+b*c) print(a or b and c) &gt;&gt;&gt; 7 1 表达式是有优先级的，比如* /的优先级比+ -高，and的优先级比or高，所以会出现上面的结果 运算符同级时，从左往右依次解析，属于左结合，但有一个特例就是赋值运算符，它是右结合 分析一个表达式的优先级时，先看有没有 =，有的话右结合，没有的话左结合 逻辑运算符的优先级： 2、条件语句 PS.Python中靠缩进来区分代码块，个人喜欢用Tab键 在VS Code中注释语句时，单行注释用#(快捷键Crtl+/),多行注释用'''(快捷键：Alt+Shift+a) 高中的时候就已经学过if else语句： mood = 'happy' if mood=='happy': print('go to home') else: print('go to school') &gt;&gt;&gt; go to home python中建议用下划线_来分隔两个组合的单词（变量命名的时候） 练习： account = 'python' password ='123456' print('please input account:') user_account = input() print('please input password:') user_password = input() if user_account == account : if user_password == password : print('登录成功') else: print('账户名或密码错误') else: print('账户名或密码错误') snippet片段，帮助即时构建代码片段，即IDE会帮你把函数的主体片段显示出来： if condition: pass else: pass 用pass来占位，来保证代码的完整性 切换上一个代码写入区域：shift+tab、下一个代码写入区域：tab 如果if/else嵌套太多，最好把内部嵌套提取成一个函数 elif是if/else的简写，但不能单独使用，需要和if一起使用： a = input() print('a is ' + a) if a == 1: print('apple') elif a == 2: print('banana') elif a == 3: print('pear') else: print('go shopping') 这样使用简化了代码，Python中没有switch函数，而上述代码运行失败的原因是：键盘输入的数字不是数字，是字符串，所以输入时要转换格式： a = int(input())，其实在执行print('a is ' + a)时就应该明白，a此时是字符串而不是数字，因为字符串才可以合并 3、循环语句 python中循环语句主要有while循环和for循环： counter = 2 \\#条件判断↓ while counter &lt;= 4: counter += 1 print('Python') &gt;&gt;&gt; Python Python python 循环是解决问题的基本思维模式，为避免死循环，条件判断语句不能使用常量，代码块内有影响条件判断的语句，while循环可以和else一起使用，使用Crtl+C可以退出循环 for循环主要是用来遍历\\循环 序列、集合或字典,也可以和else搭配使用，这是它的snippet片段： for target_list in expression_list: pass 把expression_list内的元素一行打印出来而不是换行输出：print(x，end=' ') 跳出循环：break，终止当前循环，以后循环也不会被执行，并且else语句块也会被终止，但是如果是嵌套的for循环，break跳出的是内部循环 继续循环：continue（只会终止当前循环): a = [['apple', 'banana', 'pear', 'orange'], (1, 2, 3, 4, 5, 6, 7)] for x in a: for y in x: if y == 'banana': continue if y == 2: break print(y, end=' ') else: print('fruit is gone') &gt;&gt;&gt; apple pear orange 1 fruit is gone python中没有i++ i--这种运算符，如果我们想要某段代码重复，就要使用range函数： for x in range(0, 10): print(x, end='') &gt;&gt;&gt; 0123456789 range(0, 10)是指从零开始，偏移量为10，加入第三个数字可以改变步长，正数是正序，负数是反序： for x in range(0, 10, 2): print(x, end=' ') for x in range(10, 0, -2): print(x, end=' ') &gt;&gt;&gt; 0 2 4 6 8 10 8 6 4 2 包与模块 组织结构：包（最顶级）、模块(.py文件)、类、函数和变量(属于类本身的一个特性) 一个包包括多个模块，一个模块包括多个类 包的内部可以有子包，一个包通俗来讲就是一个文件夹，但是需要注意的是，这个文件夹里面必须要有__init__.py文件才能被Python识别变成包，同时这个文件也是一个模块，你可以在里面写入内容，也可以空白。 1、模块的导入 公用的东西可以共享引用，导入python的语法： 1、import关键字，import后跟模块名 假设我们现在在模块c8中，我们需要使用c7模块中的变量a： import c7 print(c7.a) 打印出c7模块中的变量a python是解释型的语言，所以要先定义，再调用。 如果不是同一文件夹下的模块，导入时要用命名空间，import 文件夹名.模块名。 import T.c7 print(T.c7.a） import只能导入模块，可以用 as 关键字来简化代码 。 import T.c7 as k print(k.a） 2、使用from来进行变量或者是模块的导入 from module import 变量/函数或是from package import module: from T.c7 import a print(a) from简化了代码（命名） 如果要引用所有变量，加*（不推荐） from T.c7 import \\* 如果只想引用个别变量，在被引用的文件开头部分加入：__all__ = ['a','c']，括号内为要引用的变量名。 可以用逗号分隔，引用多个变量。 from c7 import a,b,c (建议一行不超过80个字符)换行时加入 \\ 来进行换行（不推荐） from c7 import a,b,\\ c 可以加括号来进行换行 from c7 import (a,b, c) 2、init.py的用法 init.py的作用： 导入包时会自动执行__init__.py里面的代码，即使是包下面的某一个模块，也会执行里面的代 可以通过__all__来选择导入哪个模块 from t import *虽然*是导入所有的模块，但是由于已经通过__all__来选择，所以只会导入特定的模块 利用它作批量导入库，当我们引用包时，包会自动导入我们要用到的系统库 3、包与模块的常见错误 1、包和模块是不会重复导入的 2、避免循环导入。（关键是避免闭环循环） 3、import导入模块时，会执行模块中的代码。 4、模块内置变量 dir（）函数可以打印出该模块中所有的变量: a = 1 b = 2 info = dir() print(info) &gt;&gt;&gt; ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b'] &gt;``` 结果返回一个列表，其中包含我们定义的变量以及其它变量，双下划线变量是系统自己定义的。 建包的时候一定要记得创建__init__.py 文件 name指的是模块名t.t1.c9 package指的是模块所属的包的名字t.t1 doc指的是文件的注释(前提是模块里面有注释) file指的是文件的物理路径 ps.终端错误提示： Traceback：错误的堆栈信息，描述位置\\路径 TypeError：错误的详细信息，错误最直接的错误 ### 1、入口文件和普通模块内置变量的区别 ps.可在变量名前加类型名强制转换类型 `NoneType 相当于 False` - 如果一个 .py 文件被当作一个应用程序的入口文件，那么name打印出来的值就不是本来的模块名，而是会被强制更改为`__main__` - 入口文件不属于任何包（用cd可以切换下一级文件夹，cd ..可以回到上一级文件夹） - python入口文件和普通导入的模块是有区别的。 - file与你执行时所在的目录是有关系的。 ### 2、__name__的经典应用 dir()：括号内没有参数就会显示出当前模块所有的变量，如果想指定模块或者特定类的变量，可以将名称写入括号。 ```python if __name__ == '__main__': print(' This is app') print('This is module') 上面代码的意义：一个模块可以被调用，也可以成为入口文件被执行，但是如果一个模块既被调用又是一个可执行文件的话，两者代码的逻辑处理是有区别的，那就需要进行判断这个模块是否是一个入口文件，则输入上述代码，这也是__name__的经典应用。 把可执行文件(入口文件)当作一个模块来执行时，可以使用-m命令，即 python -m 命名空间.文件名 也可以使用路径名：python 命名空间\\文件名.py 但是前提是要成为一个模块，这个文件必须在一个包下面。 5、相对导入与绝对导入 与入口文件main.py在同一级的包就是该包下所有模块的顶级包。 绝对导入\\路径：从顶级包开始到导入模块的完整路径： import package.module 相对路径：一个.表示当前目录，两个..表示上一级目录，以此类推。从当前目录开始输入，相当于文件系统的相对路径与绝对路径，使用from开始导入 入口文件可以使用绝对路径导入，但是不能使用相对路径导入。如果想用相对路径导入，就必须把入口文件当作一个模块来执行，用python -m指令执行，但必须必须返回上一级： python -m demo.main.py 日记三 函数 首先先介绍一下round()函数(内置函数)： a = 1.12386 result = round(a, 2) #保留小数点后两位 print(result) &gt;&gt;&gt; 1.12 Ps.round()函数会四舍五入 小彩蛋：查看Python之禅，在python的终端中输入import this 综上所述，从round()函数可以看出函数的特性： 功能性 隐藏细节 避免编写重复的代码 1、函数的定义 def funcname(parameter_list): pass 这是定义函数的snippet片段，使用def关键字定义函数，函数的特点是： 参数列表可以没有，有的话用括号括起来。 在函数体中可以使用return value来返回函数值,否则返回None。 自定义函数名不要和python系统内置的函数名或者变量名重复。 改变程序递归的次数： import sys sys.setrecursionlimit(xxxx) 编写函数--实现两个数字的相加： def add(x, y): result = x + y return result a = add(1, 2) print(a) &gt;&gt;&gt; 3 上面的代码块中，在调用add函数时，函数的参数按顺序进行赋值 2、让函数返回多个结果 需要注意的是，return后面的语句是不会执行的 return返回多个值时，用逗号隔开就行，类型为元组。 因为返回结果为元组，所以会想到用元组索引的方式去的结果，但是通过序号取值非常不好(下面代码的第一个print()函数)，建议可以通过变量名来进行接收(下面代码的第二个print()函数)。 def damage(skill1, skill2): damage1 = skill1 * 3 damage2 = skill2 * 4 + 9 return damage1, damage2 damages = damage(11, 23) print(damages[0], damages[1]) skill1_damage, skill2_damage = damage(11, 23) print(skill1_damage, skill2_damage) &gt;&gt;&gt; 33 101 33 101 3、序列解包 把一个tuple拆开，就叫做序列解包，比如说 d = 1,2,3 此时 d 是一个tuple， a,b,c = d 这样就会给给a,b,c赋值，这就叫做序列解包： d = 1, 2, 3 a, b, c = d print(a, b, c) &gt;&gt;&gt; 1,2,3 但是要注意元素的个数要相等。 链式赋值： a=b=c=1 4、必须参数与关键字参数 必须参数：函数的参数列表定义的参数（形参）是必须要求的，调用函数时输入的参数叫做实际参数。 关键字参数：直接明确指定哪个实参赋值给形参（可读性强），不一定按照形参的顺序。比如： def add(x, y): result = x + y return result ans = add(y=3, x=2) \\# -----&gt;可读性好 print(ans) &gt;&gt;&gt; 5 定义了多少个形参就要传递多少个实参。 5、默认参数 默认参数：不必每次输入大家都相同的参数，比如学校，年龄。 实现方法：在形参中直接赋值，实现默认参数，不一样的增加实参就行。 def print_student_files(name, age=18, gender='男', college='人民路小学'): print('我叫' + name) print('我今年' + str(age) + '岁') print('我是' + gender + '生') print('我在' + college + '上学') print_student_files('石头') print('~~~~~~~~~~~~~~~~~~~~~~~~~~~') print_student_files('小红', gender='女') &gt;&gt;&gt; 我叫石头 我今年18岁 我是男生 我在人民路小学上学 ~~~~~~~~~~~~~~~~~~~~~~~~~~~ 我叫小红 我今年18岁 我是女生 我在人民路小学上学 注意事项： 必须参数(即没有赋值的形参，如上例中的name)必须放在默认参数的前面，否则会报错。 参数顺序要一致，如果顺序不一致，则可以使用关键参数标明想要赋值的实参。关键字参数可以不遵守形参的顺序。 调用时不能把默认参数和必须参数混合在一起调用。 6、可变参数 可变参数：在参数列表前加一个*，输出一个元组： def demo(*param): print(param) print(type(param)) demo(1, 2, 3, 4, 5, 6) &gt;&gt;&gt;(1, 2, 3, 4, 5, 6) &lt;class 'tuple'&gt; *的作用是把每个元素拿出来平铺输出，如果我们在输入参数的时候也输入了一个元组，那么为了防止生成二维元组，可以在调用的时候，也带一个*，比如： def demo(*param): print(param) demo((1, 2, 3, 4, 5, 6)) print('----------------------') a = (1, 2, 3, 4, 5, 6) demo(*a) &gt;&gt;&gt; ((1, 2, 3, 4, 5, 6),) ---------------------- (1, 2, 3, 4, 5, 6) 可变参数可以用for循环来进行遍历调用： def squsum(*param): sum = 0 for i in param: sum += i*i print(sum) squsum(1, 2, 3) &gt;&gt;&gt; 14 参数列表类型还是越简单越好 7、关键字可变参数 关键字可变参数的格式(参数列表的参数加两个*): def demo(**param): pass 这样在传递时会传递多个关键字参数，并将其转换为字典类型dict。若实参想传递字典类型而不是数组，则要在参数列表前加两个* def city_temp(**param): print(param) print(type(param)) city_temp(bj='32c', sh='40c', xa='43c') print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~') a = {'bj': '32c', 'sh': '40c', 'xa': '43c'} city_temp(**a) &gt;&gt;&gt; {'bj': '32c', 'sh': '40c', 'xa': '43c'} &lt;class 'dict'&gt; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {'bj': '32c', 'sh': '40c', 'xa': '43c'} &lt;class 'dict'&gt; 字典遍历,需要使用字典的item()方法： def city_tmp(**param): for key, value in param.items(): print(key, &quot;|&quot;, value) city_tmp(bj='23c', sh='21c', gz='30c') &gt;&gt;&gt; bj | 23c sh | 21c gz | 30c 8、变量的作用域 变量作用域：函数内部的变量仅仅局限于函数的内部，不影响外部的变量，是局部变量。函数外部的变量叫做全局变量，覆盖整个代码。 c = 10 def add(x, y): c = x + y print(c) add(1, 2) print(c) &gt;&gt;&gt; 3 10 在上例中，首先定义的c是全局变量，函数内部的c是局部变量，所以打印结果不同 局部是一个相对概念，要看相对于谁 函数内部优先使用局部变量，作用域逐级寻找： c = 1 def func1(): c = 2 def func2(): c = 3 print(c) func2() func1() &gt;&gt;&gt; 3 9、global关键字 全局变量不是只局限于此模块中，而是可以整个程序调用，通过import()命令。 访问函数内部的局部变量可以加入global关键字，使得内部的局部变量变成全局变量使其可以在外部访问： def demo(): global c c = 2 demo() print(c) &gt;&gt;&gt; 2 并且通过global变成的全局变量可以导入其它模块，是真正的全局变量。 10、小作业---五行石的合成是否划算 题目描述如下，请编写程序看购买合算还是合成合算： ''' 购买一级石头 ''' l1_value = 0.75 #一颗1级石头消耗0.75金 l1_value_diamond = 8 #一颗1级石头同时还要消耗8个钻石 ''' 1级合成3级 ''' l1_to_l3 = 12 #一颗1级石头变成一颗3级石头，需要消耗12颗1级石头 l1_to_l3_gold = 0.39 #同时还要消耗0.39金 l1_to_l3_vit = 10 #同时还要消耗10点体力 ''' 3级合成4级 ''' l3_to_l4 = 16 #1颗3级石头变成1颗4级石头需要消耗16颗一级石头 l3_to_l4_gold = 0.897 #同时还要消耗0.897金 l3_to_l4_vit = 10 #同时还要消耗10点体力 l3_to_l4_rate = 0.4878 #1颗3级石头变成一颗4级石头的成功的概率是0.4878 #如果失败将扣除本次消耗的一级石头和花费，但是不扣除体力和三级石头 ''' 4级合成6级 ''' l4_to_l6 = 12 #1颗4级石头变成6级石头，概率为100%，但是要消耗12颗4级石头 l4_to_l6_gold = 19.75 #需要消耗19.75金 l4_to_l6_vit = 10 ''' 已知1颗六级石头的市场售价为750金，请问是购买合算还是自己合成合算 其他数据： 一颗钻石diamond 0.05金 一点体力vit 1金 ''' 答案： class Shop(): dimond = 0.05 vit = 1 l1_materies = Shop() l1_cost = 0.75 def l1(num): l1_price = num * (l1_cost + 8 * l1_materies.dimond) return l1_price l3_materies = Shop() l3_cost = 0.39 def l3(num): l3_prcie = num * (l1(12) + l3_cost + 10 * l3_materies.vit) return l3_prcie l4_materies = Shop() l4_cost = 0.897 l3_to_l4_rate = 0.4878 def l4(num): # 直接除以概率 l4_price = num * ((l1(16) + l4_cost)/l3_to_l4_rate + l3(1) + 10 * l4_materies.vit) # 数学期望计算,这种解法是看别人写的，没有太懂 # l4_price_E = (l1(16)+l4_cost+l3(1)+10*l4_materies.vit)*l3_to_l4_rate + (l1(16)+l4_cost)*(1-l3_to_l4_rate) # l4_price = num * (l4_price_E/l3_to_l4_rate) return l4_price l6_materies = Shop() l6_cost = 19.75 def l6(num): l6_price = num * (l4(12) + l6_cost + 10 * l6_materies.vit) return l6_price l6_shop_buy = 750 print('合成1级五行石花费：', round(l1(1), 2), '金') print('合成3级五行石花费：', round(l3(1), 2), '金') print('合成4级五行石花费：', round(l4(1), 2), '金') print('合成6级五行石花费：', round(l6(1), 2), '金') if l6(1) &gt; l6_shop_buy: print('购买划算') else: print('合成划算') &gt;&gt;&gt; 合成1级五行石花费： 1.15 金 合成3级五行石花费： 24.19 金 合成4级五行石花费： 73.75 金 合成6级五行石花费： 914.74 金 购买划算 面向对象 1、类的定义 使用关键字class来定义类 类的命名规则：类的第一个字母大写，不建议使用下划线，两个单词的话，两个首字母都大写 class Student（）: pass 在类的内部可以定义变量，也可以定义函数： class Student(): name = '鸡小萌' age = 2 def print_file(self): print('名字:' + self.name) print('年龄:' + str(self.age)) student = Student() student.print_file() &gt;&gt;&gt; 名字:鸡小萌 年龄:2 使用类就要先把类实例化，比如student = Student（），这就是实例化，实例化以后才可以调用类内部的变量和方法。 类下面的函数，叫做方法，注意！要在参数列表里写入self,方法内部如果引用类的变量时要在变量前加self. 类的最基本的作用就是封装代码。 类只负责去定义，去描述，而不会去执行。 调用或者执行这个类只能放在类的外部。 真正的项目中，类的定义放在一个模块，类的调用放在另一个模块中(推荐)： from (模块名) import （类名) 实例化这个类 调用该类的方法及变量 行为与特征是类的特点，行为要找对主体！！！ 类是一个抽象的概念，类被实例化就变成了一个具体的对象。 类就像一个模板，可以产生多个对象。 2、构造函数 构造函数：让对象实例化后不同 def __init__（self）： pass 构造函数的调用会自动进行 与其它函数不同，构造函数只能返回None，不能返回其它的值 通过在参数列表里增加新的变量，可以生成不同的对象 一般在构造函数的内部，初始化对象的属性（特征） name = name 把构造函数的参数赋值给类定义的变量，名字可以一样 访问一个对象下的变量用 . 来进行访问 参数列表里的self可以是其它值，比如this、that等等，python推荐使用self class Student(): name = '' age = 0 def __init__(self, name, age): name = name age = age student1 = Student('tu', 18) print(student1.name) &gt;&gt;&gt; 上面代码运行结果为空以为是局部与全局的关系，因为以前学过局部变量不会覆盖全局变量，这是不正确的，不能把模块下面的全局变量等同于类下面定义的变量，要区分模块变量与类变量，类变量是和类相关联在一起的，实例变量是和对象相关连在一起的： class Student(): name = '类变量名' age = 0 #此处定义的就是类变量 def __init__(self, name, age): self.name = name self.age = age #此处定义的就是实例变量，它只和对象有关系而和类没有关系，推荐使用`self`关键字 student1 = Student('对象1名字', 18) student2 = Student('对象2名字', 19) print(student1.name) print(student2.name) print(Student.name) &gt;&gt;&gt; 对象1名 对象2名 类变量名 __dict__保存着当前对象下所有的变量： print(student1.__dict__) 访问一个实例变量，如果对象实例列表没有，会继续在类变量里去寻找，所以前面会输出空字符。 类下面定义的函数叫做实例方法，要默认固定的放入一个self，调用时不需要给self赋值。 哪个对象调用了这个方法，self就和这个对象有关系，就代表这个实例，与类没有关系。 方法需要对变量做一系列运算，然后去改变类的特征。 实例方法与构造函数的调用方法不一样，构造函数的调用，是通过类名（变量）来调用，比如：student1 = Student('xixi',18)来进行，而实例方法是通过对象来调用的，比如：student1.do_homework()来进行的。 实例方法与构造函数的意义不同，实例方法主要是来描述类的行为，而构造函数主要是初始化类的各种特征。 在实例方法中访问类变量： 通过类名.变量名来进行访问。 通过self.__class__.变量名来进行访问 在类的外部访问类变量，也可以通过类名.变量名来进行访问。比如：Student.name 3、类方法 定义类方法的格式： @classmethod def fuc(cls): #cls可以为其它，推荐使用cls pass @classmethod是装饰器，是类方法的特征。类方法操作与类相关的一些变量，即类方法只与类相关，与对象关系不大。 调用类方法： 直接用类来调用： Student.plus_sum() 用对象来调用类的方法： student1.plus_sum() 建议还是用类来调用: class Student(): sum = 0 @classmethod def plus_sum(cls): cls.sum += 1 print(cls.sum) student1 = Student() student1.plus_sum() student2 = Student() student2.plus_sum() student3 = Student() Student.plus_sum() &gt;&gt;&gt; 1 2 3 4、静态方法 定义静态方法的格式： @staticmethod def add(x,y): pass 需要@staticmethod装饰器。 类和对象都可以调用这个静态方法： class Student(): sum = 0 @staticmethod def add(x, y): print(x + y) print('this is staticmethod') student1 = Student() student1.add(1, 2) Student.add(2, 3) &gt;&gt;&gt; 3 this is staticmethod 5 this is staticmethod 静态方法/类方法可以调用类变量，但是不能调用实例变量。在日常使用中，推荐使用类方法。 5、成员的可见性：公开和私有 为了保证数据的安全，可以让这个数据只在类的内部可以进行操作，而不能在类的外部被操作。 如果一个变量或者函数是公开的(public)，那么就可以在类的外部进行访问，有时候为了避免被公开访问，可以进行私有化(private)设置,这样在外部就不能进行访问。 变成私有的方法： 变量或者方法前加双下划线：__ PS.构造函数除外，因为后面也有双下划线:__init__ 私有变量尽管已经私有化了，但是如果你想访问的话，还是可以的，当类里面定义一个私有变量后，Python会自动帮你把该私有变量的名字换掉，比如你定义了一个私有变量：__score，这个时候Python会把私有变量的名字改为：_Student__score,同时依然支持在类外进行访问（囧）。 但是私有方法在外部是不可以进行访问的。 6、继承 面向对象的三大特性：继承性，封装性，多态性 继承性：避免定义 重复的方法 和 重复的变量 建议：一个模块只写一个类，可以看下面c2.py中的调用方法 c1.py class Human(): sum = 0 def __init__(self, name, age): self.name = name self.age = age def get_name(self): print(self.name) 在c1.py中，我们定义了一个父类Human，它包括一个类变量sum,一个构造函数__init__,一个方法get_name c2.py from c1 import Human class Student(Human): def __init__(self, school, name, age): self.school = school Human.__init__(self, name, age) student1 = Student('人民路小学', '鸡小萌', 11) print(student1.sum) print(Student.sum) print(student1.name) print(student1.age) student1.get_name() &gt;&gt;&gt; 0 0 鸡小萌 11 鸡小萌 在c2.py中，我们定义了一个类Student,它继承了父类Human，子类里也包括了一个构造函数，并且它还调用了父类的构造函数，此时，在子类构造函数的参数列表中要传入父类的参数，并且，在调用时，必须传入self关键字，即：Human.__init__(self, name, age)，从结果来看，我们成功的调用了父类文件中的类变量sum、实例变量name age以及方法。 那为什么我们在调用子类的构造函数的时候不需要传入self关键字呢，因为我们在实例化Student这个类的时候，Python会自动的调用构造函数，此时Python会帮我们补全self，而如果我们在子类中调用父类的构造函数，相当于用类调用了一个实例方法，在这种情况下，就是一个普通方法的调用，所以参数列表的参数都必须传入。 一般来说，通过对象调用函数或者方法，Python知道self是谁，会自动帮你补全self，而你通过类去调用一个方法，就必须把所有的参数补全，所以实例化一个对象以后，明智的操作是通过这个对象去调用方法 。 一般情况下，不推荐在子类的方法中使用父类名.父类方法的这种方式去调用父类的方法，推荐使用super关键字： super(子类名，self).__init__(参数) from c1 import Human class Student(Human): def __init__(self, school, name, age): self.school = school super(Student, self).__init__(name, age) student1 = Student('人民路小学', '鸡小萌', 11) print(student1.school) print(student1.name) print(student1.age) &gt;&gt;&gt; 人民路小学 鸡小萌 11 子类方法和父类方法同名的话，优先调用子类方法。 Python中可以进行多继承，即一个子类继承多个父类，但是这样略显混乱，建议单继承。 日记四 正则表达式与JSON 1、初识正则表达式 正则表达式是一个特殊的字符序列，可以检测一个字符串是否与我们所设定的这样的字符序列相匹配。 匹配的话可以快速检索文本、实现文本替换。 import re a = 'Python|C++|C#|JS|Java' print(re.findall('Python', a)) &gt;&gt;&gt; ['Python'] 结果返回一个列表。 2、元字符与普通字符 在上面的代码块中，我们要查找的Python就是一个普通字符，它是具体的，而元字符呢，就是正则表达式的精华所在，比如： import re a = 'a1b2c3d4e5f6g7h8i9j0' print(re.findall('\\d', a)) print(re.findall('\\D', a)) &gt;&gt;&gt; ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'] ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'] 在上面的代码中，\\d与\\D就是元字符，其中\\d表示所有的数字，\\D表示所有的非数字，元字符有很多，后面的学习过程会用到一些。 3、字符集 import re a = 'abc, acc, adc, afc, agc, ahc' print(re.findall('a[cf]c', a)) print(re.findall('a[^cf]c', a)) print(re.findall('a[c-f]c', a)) &gt;&gt;&gt; ['acc', 'afc'] ['abc', 'adc', 'agc', 'ahc'] ['acc', 'adc', 'afc'] 字符集[]，即元字符与普通字符的混用，一般情况下，普通字符起着定界的作用！ 上面的代码块有三条print语句: 第一个print语句中，使用了a[cf]c,它的作用是找出字符串中所有的acc和afc，即括号中的[cf]表示的是或的关系。 第二个print语句，使用了a[^cf]c,此时括号中的[^cf]表示的是非的关系，即找出不是acc和afc的所有元素。 第三个print语句，使用了a[c-f]c，代表的是匹配所有从c到f的元素。 4、概括字符集 前面学过的\\d,\\D就属于概况字符集，它们比普通字符集更加的简洁，下面是一些常用的概括字符集： \\d -----&gt; [0-9] 所有的数字 \\D -----&gt; [^0-9] 所有的非数字 \\w -----&gt; [A-Za-z0-9_] 所有的数字和字母和下划线 \\W -- --&gt; 非单词字符，比如&amp;,空格，回车 \\s------&gt; 空白字符，比如回车，换行，空格 \\S -----&gt; 非空白字符 5、数量词 先来看一段示例： import re a = 'python 1111 java666 php' r = re.findall('[a-z]', a) print(r) &gt;&gt;&gt; ['p', 'y', 't', 'h', 'o', 'n', 'j', 'a', 'v', 'a', 'p', 'h', 'p'] 由于匹配时采用的是字符匹配，所以我们可以看到结果全是单个的字母，如果我们想匹配完整的单词，就需要用到数量词，它的作用是重复设定的匹配规则： import re a = 'python1111java666php' r = re.findall('[a-z]{3,6}', a) print(r) &gt;&gt;&gt; ['python', 'java', 'php'] 在上面的代码块中，我们加入了数量词{3,6}，它用{}表示，里面的3,6表示的是匹配3-6个连续的字母，所以同理{3}就表示连续3个字母 6、贪婪与非贪婪 在上面的代码中，我们规定了数量词{3,6},理论上来讲，当匹配到连续三个字母时就应该输出才对，那为什么最后结果中会有python、java呢，因为数量词规定一个范围后。比如说{3，6}，python会倾向于尽可能大的去取，匹配到三个时，还会尽可能的往后去取，直到不满足条件，这就是贪婪。 非贪婪的表示：在数量词的后面加一个？ import re a = 'python1111java233php' r = re.findall('\\D{3,6}?',a) print(r) &gt;&gt;&gt;['pyt', 'hon', 'jav', 'php'] 7、匹配0次或无限次 import re a = 'pytho0python1pythonn' print(re.findall('python*', a)) print(re.findall('python+', a)) print(re.findall('python?', a)) &gt;&gt;&gt; ['pytho', 'python', 'pythonn'] ['python', 'pythonn'] ['pytho', 'python', 'python'] 在上面我们用到了三种匹配方式： * 匹配它前面的字符0次或无限多次，即n出现0次的时候也可以匹配 + 匹配它前面的字符1次或无限多次，由于至少匹配一次，而pytho中一个n都没有 ? 匹配它前面的字符0次或者1次，当?前面是数量词时，它表示非贪婪，这两者是有区别的 8、边界匹配符 ^从字符串开始开始匹配 $从字符串末尾开始匹配 import re a = '100000001' r = re.findall('^\\d{4,8}$', a) print(r) &gt;&gt;&gt; [] 关于上面的边界匹配符，我是这样理解的，^首先从开始匹配，匹配结果应该是10000000,$从末尾匹配，匹配结果应该是00000001,它们两个是不相同的，所以最终匹配为空。 9、组 用括号把一系列字符括起来就成为了一个组，组后面可以加一个花括号，花括号里面的数字表示该组字符出现的次数。 import re a = 'PythonPythonPythonPython' r = re.findall('(Python){3}',a) #Python出现三次才可以匹配 print(r) &gt;&gt;&gt;['Python'] 这里只出现了一个Python不代表它只匹配了一个，我个人理解它的含义应该是次数，因为我们匹配时用的正则表达式是(Python){3}，字符串中有四个Python，它可以匹配到一次，所以输出一个Python 10、匹配模式参数 re.findall 函数第三个参数的意义：匹配的模式 下面介绍两个常用的匹配模式： re.I ——&gt;忽略字母大小写的区别 import re a = 'pythonC#javaphpswift' r1 = re.findall('c#', a) r2 = re.findall('c#', a, re.I) print(r1) print(r2) &gt;&gt;&gt; [] ['C#'] 从上面的代码可以看出，当没有使用re.I时，我们用小写的c#是匹配不到C#的，使用以后成功匹配。 多个模式用 | 来连接 Ps.补充概括字符集：. ——&gt; 匹配除换行符\\n之外其它所有字符 re.S ——&gt;匹配所有字符包括换行符 import re a = 'pythonC#\\njavaphpswift' r1 = re.findall('c#.{1}', a, re.I) r2 = re.findall('c#.{1}', a, re.I | re.S) print(r1) print(r2) &gt;&gt;&gt; [] ['C#\\n'] 第一种情况下，由于不会匹配换行符\\n，所以输出为空，第二种下，re.S会强制抵消掉概括字符集.的作用，所以可以匹配到换行符。 11、 re.sub()正则替换 re.sub()方法有五个参数，分别是re.sub(pattern, repl, string, count = 0, flags = 0) import re a = 'JavaC#PythonC#PHPC#' r1 = re.sub('C#', 'Go', a) r2 = re.sub('C#', 'Go', a, 1) print(r1) print(r2) &gt;&gt;&gt; JavaGoPythonGoPHPGo JavaGoPythonC#PHPC# 默认情况下，count的数值为0，表示会无限的替换下去，数值为1，表示只替换第一个 其实还可以用Python的内置函数replace方法： a = 'JavaC#PythonC#PHPC#' r = a.replace('C#', 'Go') print(r) &gt;&gt;&gt; JavaGoPythonGoPHPGo re.sub()第二个参数还可以是一个函数，此时匹配到的字符就是该函数的参数,但是不是简单的一个字符，而是一个对象，可以通过group方法得到所匹配的字符，最后返回该函数的return结果。因为有时候要根据不同的匹配结果作出不同的操作，所以还是挺有用的。 import re a = 'JavaC#PythonPHP' def convert(value): print(value) matched = value.group() return ('!!这是:' + matched + '!!') r = re.sub('C#', convert, a) print(r) &gt;&gt;&gt; &lt;_sre.SRE_Match object; span=(4, 6), match='C#'&gt; Java!!这是:C#!!PythonPHP 练习题： # 匹配下面字符串中的数字，将大于等于50的替换成100，小于50的替换成囧 import re a = 'A45B78C7D66E789F90' def convert(value): matched = value.group() if int(matched) &gt;= 50: return '100' else: return '囧' r = re.sub('\\d{1,9}', convert, a) print(r) &gt;&gt;&gt; A囧B100C囧D100E100F100 其中，在与给定数字作比较的时候要记得，我们字符串中的数字是字符，是不可以和整形作比较的，必须更改格式，最后返回时也要返回字符。同时，上面这块代码可以更清楚的明白如果re.sub()第二个参数传入一个函数的话，会很方便的完成我们的要求。 12、re.match()与re.search() import re a = 'a1b2c3d4e5f6g7' r1 = re.match('\\d', a) r2 = re.search('\\d', a) print(r1) print(r2) &gt;&gt;&gt; None &lt;_sre.SRE_Match object; span=(1, 2), match='1'&gt; re.match() 从字符开始处开始匹配，如果第一位就不匹配，返回None。 re.search() 从开始处开始搜索，搜索整个字符串，如果匹配，立即返回第一个对象，否则返回None。 与findall的区别： findall()返回结果为list，而match()与search()返回为对象（如果需要获取对象内容，需要用到group()方法，如果需要返回位置，可以使用span()方法）。 match与search只会匹配一次，无论成功与否，都会返回结果。 13、group()的用法 # 输出life和python之间的字符串 # 输出两个pytohn之间的字符串 import re a = 'life is short, i use python, i love python' r1 = re.search('life.*python', a) r2 = re.search('life(.*)python(.*)python', a) r3 = re.findall('life(.*)python(.*)python', a) print(r1.group()) print(r2.group(0)) print(r2.group(1)) print(r2.group(2)) print(r2.groups()) print(r3) &gt;&gt;&gt; life is short, i use python, i love python life is short, i use python, i love python is short, i use , i love (' is short, i use ', ', i love ') [(' is short, i use ', ', i love ')] 因为re.match()匹配结果是一个对象，所以可以通过group()访问这个对象，一般情况下，group()和group(0)永远记录的是字符串完整的匹配结果，而要访问内部的分组，要从1开始。所以正则表达式内部有组的话，可以通过group方法来进行访问。 如果用groups方法，只会输出分组的情况而不是完整的匹配结果。 14、Json Json是一种轻量级的数据交换格式。 同xml相比，它确实时轻量级的，但最重要的时，它是一种数据交换格式，它的载体是字符串，符合Json格式的字符串叫做Json字符串。 优势：易于阅读、解析，网络传输效率高。可以跨语言进行数据交换。 15、反序列化与序列化 那么怎么把json格式的字符串转换为相应语言下的数据格式呢，在python中，有json模块，可以对json数据进行处理。 import json json_str = '{&quot;name&quot;:&quot;stone&quot;, &quot;age&quot;:18, &quot;bool&quot;:false}' j1 = json.loads(json_str) print(type(j1)) print(j1) json_array = '[{&quot;name&quot;:&quot;stone&quot;, &quot;age&quot;:18}, {&quot;name&quot;:&quot;stone&quot;, &quot;age&quot;:18}]' j2 = json.loads(json_array) print(type(j2)) print(j2) &gt;&gt;&gt; &lt;class 'dict'&gt; {'name': 'stone', 'age': 18, 'bool': False} &lt;class 'list'&gt; [{'name': 'stone', 'age': 18}, {'name': 'stone', 'age': 18}] json.loads()可以把json的数据格式转换为对应语言下的格式，json字符串对于json来说是一个对象，但是在上面的代码块中可以看到，在Python中它被转换为dict类型，json字符串中的bool值(小写)被转换为Python中的bool值(大写)。json数组被转换为了list。 下表是把json数据格式转换为python数据格式的具体对应情况： ![](https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-08-22-json_to_python.jpg) Ps.要注意Json字符串的表示方法，它与Python中的字典有些许不同，内部要用双引号，数字不用引号，外部要用单引号。 而这种把json字符串转换为其他语言的数据格式叫做反序列化. 那顾名思义，序列化就是把python中的数据格式转为json字符串，要用到json模块下的json.dumps方法: import json python_dict = {'name': 'TheRang', 'age': 18} json_str = json.dumps(python_dict) print(json_str) &gt;&gt;&gt; {&quot;name&quot;: &quot;TheRang&quot;, &quot;age&quot;: 18} 高级语法与用法 1、枚举 枚举就是Python提供给我们的一个类，我们所用的任何枚举类型其实是这个类的子类。 from enum import Enum class VIP(Enum): YELLOW = 1 GREEN = 2 RED = 3 BALCK = 4 print(VIP.YELLOW) &gt;&gt;&gt; VIP.YELLOW 枚举中的标识最好大写。 枚举的意义在于标签而不是数字，这也是枚举的意义所在，所以我们打印VIP.YELLOW结果是VIP.YELLOW而不是1，这也是枚举类型同其它类的区别。 1、枚举和普通类相比的区别 一般情况下，我们枚举一件事物，会想到用字典或者用普通类来进行： {'YELLOW':1, 'GREEN':2} class TypeDimond(): YELLOW = 1 GREEN = 2 但是这样做有缺点： 可变，可以轻易的在代码中改变标签的值 没有防止相同标签的功能 而枚举就会有相应的保护措施 2、枚举类型，枚举值，枚举名称 from enum import Enum class VIP(Enum): YELLOW = 1 GREEN = 2 RED = 3 BALCK = 4 print(VIP.GREEN) print(type(VIP.GREEN)) print(VIP.GREEN.name) print(type(VIP.GREEN.name)) print(VIP.GREEN.value) print(type(VIP.GREEN.value)) &gt;&gt;&gt; VIP.GREEN &lt;enum 'VIP'&gt; GREEN &lt;class 'str'&gt; 2 &lt;class 'int'&gt; print(VIP.GREEN)返回VIP.GREEN，是枚举类型（枚举下面的类型）。 print(VIP.GREEN.name)返回GREEN，是枚举名称。 print(VIP.GREEN.value)返回2，是对应的值类型。 对枚举来说，是可以遍历的，可以获得枚举下面的每一种枚举类型： from enum import Enum class VIP(Enum): YELLOW = 1 GREEN = 2 RED = 3 BALCK = 4 for dimond in VIP: print(dimond) &gt;&gt;&gt; VIP.YELLOW VIP.GREEN VIP.RED VIP.BALCK 3、枚举注意事项 枚举类型之间是可以进行等值==比较的，但是不支持大小比较。不同枚举类的枚举类型进行等值比较后都会返回False. 枚举下不能有相同的标签名，但是标签下的数值可以相同，这个情况下第二个名称是第一个的别名。 遍历时，数值相同的标签，只会打印第一个。 如果想遍历所有标签，可以使用__members__方法： from enum import Enum class VIP(Enum): YELLOW = 1 RED = 2 GREEN = 3 BLACK = 4 ORANGE = 1 print(VIP.ORANGE) print('~~~~~~~~~~~~~~~~') for i in VIP.__members__: print(i) &gt;&gt;&gt;VIP.YELLOW ~~~~~~~~~~~~~~~~ YELLOW RED GREEN BLACK ORANGE 4、枚举小结 前面所导入的Enum类不会强制限制枚举类型的值，我们用数字和字符都可以，如果我们想要限制枚举类型的值只能用数字的话，可以导入enum模块下的IntEnum类，如果我们想要限制两个不同的枚举类型不能用相同的数值，可以导入装饰器unique来进行： from enum import IntEnum, unique @unique class VIP(IntEnum): YELLOW = 1 ORANGE = 1 RED = 2 GREEN = 3 BLACK = 'abc' &gt;&gt;&gt; ValueError: invalid literal for int() with base 10: 'abc' ValueError: duplicate values found in &lt;enum 'VIP'&gt;: ORANGE -&gt; YELLOW 可以看到如果我们继续用字符串和相同数值的话会报错。 2、闭包 函数以及定义时的环境变量叫做闭包。 函数可以作为一个返回结果被返回。 可以把函数赋值给变量。 def curve_pre(): def curve(): print('This is curve') return curve # 不加括号返回的是一个没有调用的函数，加括号是直接执行了函数，然后把函数的结果返回了回去 # curve_pre()的返回结果为一个函数 f = curve_pre() #把curve_pre()的返回结果赋值给一个变量，此时，变量f就是curve函数 print(type(f)) f() &gt;&gt;&gt;&lt;class 'function'&gt; This is curve 一旦形成闭包，外部的变量不会影响内部的变量，闭包的环境变量可以用__closure__来查看，具体可以用__closure__[0].cell_contents来查看： def curve_pre(): a = 25 def curve(x): return a * x * x return curve a = 10 f = curve_pre() print(f(2)) print(f.__closure__) print(f.__closure__[0].cell_contents) &gt;&gt;&gt; 100 (&lt;cell at 0x000001C009DF81F8: int object at 0x0000000067F46F40&gt;,) 25 我们给a赋值10以后，它输出的结果依然是100，也就是说一旦形成闭包，外部变量的值不会影响内部的变量。 闭包的意义：保存一个环境，如果没有闭包，很容易被外部变量所影响。环境变量指函数定义时的外部变量，但不是全局变量。 分析闭包时要从最外层向最里层逐层分析。 局部不会影响外部。 闭包内的函数，内部函数的变量不能被赋值。 小作业 一个旅行者，从原点x=0出发，每次移动若干步，请求出每次移动后的新位置 先尝试用闭包解决一下： origin = 0 def travler(step): global origin # 用global关键字使得我们的变量origin变成全局变量来实时的修改每次移动后的坐标 position = origin + step origin = position return position print(travler(2)) print(travler(3)) print(travler(5)) &gt;&gt;&gt; 2 5 10 再尝试用闭包来实现： origin = 0 def traveler(pos): def go(step): nonlocal pos new_pos = pos + step pos = new_pos return new_pos return go travel = traveler(origin) print(travel(2)) print(travel(3)) print(travel(5)) &gt;&gt;&gt; 2 5 10 由于在闭包内部我们给环境变量赋值，pos = new_pos,Python会默认此时的pos不是环境变量而是局部变量，这样的话运行报错：在没有定义的时候使用局部变量，Python中提供了一个nonlocal关键字可以强制使pos变成环境变量。 由于闭包内部的封闭性，使我们的程序更加的安全，整个问题解决之后我们的环境变量origin依然没变，如果我们用非闭包的方式，虽然用加global关键字的方式解决了问题，但是此时的环境变量origin也发生了改变，如果其它函数也要使用这个变量就会很混乱。 3、lambda表达式 匿名函数：定义函数时不需要命名 定义匿名函数时需要用到lambda关键字： lambda parameter_list: expression parameter_list————&gt;参数列表 expression ————&gt;只能是简单的表达式而不能是代码块 def add(x, y): return x + y f = lambda x, y: x + y print(add(1, 2)) print(f(1, 2)) &gt;&gt;&gt; 3 3 虽然把一个对lambda表达式进行赋值是非常奇怪的，但是上面这个代码库还是很直观的显示了匿名函数与普通函数的区别 4、三元表达式 在其它的编程语言中，三元表达式的一般形式为：x &gt; y ? x : y，即x&gt;y为真时返回x，否则返回y 在Python中，三元表达式的形式为：条件为真时返回的结果 if 条件判断 else 条件为假时的返回结果 验证一下： x = 2 y = 1 r = x if x &gt; y else y print(r) &gt;&gt;&gt; 2 三元表达式常用于lambda表达式中 5、map map是一个类 ，有两个参数，第一个参数是一个函数，第二个参数是一个序列或者集合，map会把集合中的每个元素都进行函数操作，最后返回map object，可以通过list将结果转化为列表。 list_x = (1, 2, 3, 4, 5, 6, 7, 8) def square(x): return x * x r = map(square, list_x) print(r) print(type(r)) print(list(r)) &gt;&gt;&gt; &lt;map object at 0x0000019EDF2129E8&gt; &lt;class 'map'&gt; [1, 4, 9, 16, 25, 36, 49, 64] map可以结合lambda表达式一起使用，并且参数列表可以传入多个参数： list_x = (1, 2, 3, 4, 5, 6, 7, 8) list_y = (2, 4, 6, 8, 10) r = map(lambda x, y: x*x+y, list_x, list_y) print(list(r)) &gt;&gt;&gt; [3, 8, 15, 24, 35] 如果传入多个参数列表，会返回参数个数较少的那个。 6、reduce reduce使用，必须先从functools这个包中调用。 reduce参数列表中的函数必须要有两个参数。 reduce在做一个连续的计算，每次将计算结果作为下一次的一个参数。 reduce第三个参数是初始值，默认情况下是0。 from functools import reduce list_x = [1, 2, 3, 4, 5, 6, 7, 8] r = reduce(lambda x, y: x + y, list_x) print(r) &gt;&gt;&gt; 36 运行机制：先取1和2赋值给x,y进行x+y的运算，将结果3作为下次计算的x，然后y取3，继续相加，以此类推。（lambda内部定义的是相加，其他计算也可以） 这样的话我们可以对上次写的旅行者代码做一次修改，我们输入每次移动的x值和y值，表示前后左右(前进为正，向右为正)，最后求旅行结束的坐标： from functools import reduce position = [(1, 2), (3, 4), (-2, -1), (3, -1)] r = reduce(lambda x, y: (x[0]+y[0], x[1]+y[1]), position) print(r) &gt;&gt;&gt; (5, 4) 7、filter filter，过滤一些不需要或者不符合规则的元素。 返回一个集合，需要用list转换一下。 判断语句的返回为布尔类型,靠真或假来进行过滤。 list_x = [1, 2, 0, 3, 0, -2, 1, 5, -1] r = filter(lambda x: True if x &gt; 0 else False, list_x) print(r) print(list(r)) &gt;&gt;&gt;&lt;filter object at 0x04C228B0&gt; [1, 2, 3, 1, 5] 上面这个代码块的作用就是：保留列表中大于0的数字 我们可以编写一个程序，只保留一个字母列表中的大写字母： #考虑用ASCII码来解决问题，首先查看大写字母的ASCII码范围 print(ord('A')) print(ord('a')) list_letter = ('U', 'x', 'S', 'm', 'T', 'a', 'B', 'n') r = filter(lambda x: True if ord(x) &gt;64 and ord(x) &lt;97 else False, list_letter) print(r) print(list(r)) &gt;&gt;&gt; 65 97 &lt;filter object at 0x000001F9E53B26D8&gt; ['U', 'S', 'T', 'B'] 8、装饰器 装饰器的意义是：在不改变原有代码逻辑的情况下，增加函数的功能 Ps.打印当前时间： import time print(time.time()) &gt;&gt;&gt; 1537147395.672728 #Unix时间戳 总秒数 装饰器的定义需要定义一个嵌套函数，而它的调用才是最神奇的地方： import time def decorator(func): def wrapper(): print(time.time()) func() return wrapper #定义了一个装饰器decorator，嵌套函数wrapper无参 @decorator def f1(): print('This is a function') f1() &gt;&gt;&gt; 1537149412.160813 This is a function 在Python中我们可以接受定义复杂，而不能接受调用复杂 在我们定义好装饰器以后，使用@进行调用，这样并没有改变原有函数内部的逻辑，也没有改变该函数的调用。 如果我们的函数是有参数的，并且个数不定，那么调用装饰器时，需要在装饰器的主体使用可变参数： import time def decorator(func): def wrapper(*args): #传入可变参数*args print(time.time()) func(*args) return wrapper @decorator def f1(func): print('This is a function', func) f1('func1') &gt;&gt;&gt; 1537164370.3236895 This is a function func1 如果我们的函数有关键字参数，那么同理，在装饰器的主体使用关键字参数：**kw，并且在装饰器内部函数调用时需要传入。 如果我们在定义装饰器时不知道函数的参数到底有几个，到底是什么，我们可以直接传入可变参数*args和关键字参数**kw来满足所有的条件。 一个函数可以有多个装饰器。 9、字典映射代替switch case语句 在其它语言中有switch这个条件分支语句： switch(expression){ case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s); } 意思是当匹配到case后面的表达式时，会输出当前case下的结果，如果都不匹配，那么输出default下的语句，在python中是没有switch语句的，我们可以编写if\\else语句来代替，但是这样写比较麻烦，可以通过写一个字典的方法来代替： day = 0 switcher = { 0: 'Sunday', 1: 'Monday', 2: 'Tuesday' } day_name = switcher[day] print(day_name) &gt;&gt;&gt; Sunday 这是字典映射的最简单的一个示例，但是存在bug，在switch语句中，没有匹配到相应的case时，会输出default中的内容，但是在字典映射时，就不能这样，不过我们可以不采用下标的方法来访问字典，而是使用字典内置的get方法，它有两个参数，第一个还是key值，第二个是匹配不到时输出的结果： day = 6 switcher = { 0: 'Sunday', 1: 'Monday', 2: 'Tuesday' } day_name2 = switcher.get(day, 'None') print(day_name2) &gt;&gt;&gt; None 并且强大的是！！！字典的value值可以取一个函数： day = 6 def get_sunday(): return 'Sunday' def get_monday(): return 'Monday' def get_tuesday(): return 'Tuesday' def get_default(): return 'None' switcher = { 0: get_sunday, 1: get_monday, 2: get_tuesday } day_name2 = switcher.get(day, get_default)() # 这里要注意，由于get返回的结果是一个函数，所以后面再加一对括号表示调用 print(day_name2) &gt;&gt;&gt; None 10、列表推导式 列表推导式，就是根据现有的列表，创建一个新的列表： a = [1, 2, 3, 4, 5, 6, 7, 8] b = [i**2 for i in a] print(b) &gt;&gt;&gt; [1, 4, 9, 16, 25, 36, 49, 64] 根据现有的列表a，把a中每个元素的平方输出为新的列表，虽然这种问题也可以通过for循环或者是map表达式来完成 ，但是当我们要根据列表中元素的值做出不同的操作时，列表推导式就比较实用，比如在上面这个例子中，我们只需要输出大于4的数字的平方： a = [1, 2, 3, 4, 5, 6, 7, 8] b = [i**2 for i in a if i &gt; 4] print(b) &gt;&gt;&gt; [25, 36, 49, 64] 同样的，字典也可以进行同样的推导： student = { '一一': 12, '二二': 15, '三三': 18 } b1 = [key for key, values in student.items()] b2 = {values: key for key, values in student.items()} print(b1) print(b2) &gt;&gt;&gt; ['一一', '二二', '三三'] {12: '一一', 15: '二二', 18: '三三'} 遍历字典时需要用到items()这个方法，第一个print提取了字典的key值，第二个print颠倒了key和values的值。 而由于元组是不可变的，所以如果你想生成一个新的元组，会得到一个generator对象。 11、迭代器与生成器 凡是可以被for/in循环遍历的数据结构都是可迭代对象(iterable)，比如说列表，元组，集合。 迭代器(iterator)是一个对象(class),它是一个可迭代对象，反过来说肯定是错误的。一般情况下，普通的class肯定是不能遍历，如果我们想遍历一个class，那就需要把它变成一个迭代器，通过在类中实现__iter__()和__next__()这个两个方法，for/in循环的实质是它会不断地调用__next__()方法来实现遍历。 class BookCollection: def __init__(self): self.data = ['《往事》', '《只能》', '《回味》'] self.cur = 0 def __iter__(self): return self def __next__(self): if self.cur &gt;= len(self.data): raise StopIteration() # 如果遍历到最后一个时，抛出迭代错误，停止迭代 r = self.data[self.cur] self.cur += 1 return r books = BookCollection() for book in books: print(book) # print(next(books)) &gt;&gt;&gt; 《往事》 《只能》 《回味》 使用next()方法同样可以进行一个一个的从迭代器中取出结果，但是不能对列表等使用next()方法。 生成器是对一个函数来说的，比如说像打印1---10000，如果用列表推导式，它会生成1---10000的一个列表，这样是非常占用计算机内存的。如果我们能一边生成，一边使用的话，就需要借助生成器了： def gen(max): i = 0 while i &lt; max: i += 1 yield i r = gen(10) print(r) print(next(r)) print('~~~~') for x in r: print(x) &gt;&gt;&gt; &lt;generator object gen at 0x0000017D54B9B830&gt; 1 ~~~~ 2 3 4 5 生成器同样可以使用for\\in循环或者next()来进行遍历。 生成器既保证了函数的功能性，又保证了函数的性能。 yield与return的区别就是，当执行到return语句时，整个函数的调用都会结束，而使用yiled，它会保留上次被调用时的返回结果，再次调用时会从上一次的结果开始而不是初始值。 12、None None的意思不是空，无论是从类型还是值来说都不等同于空字符串、空列表、0、False... None本身就是一个Nonetype对象： print(type(None)) &gt;&gt;&gt; &lt;class 'NoneType'&gt; 所以说，if not a 和 if a is None是不一样的意思，前者进行布尔运算，后者进行类型比较： a = [] if not a: print('S') else: print('F') if a is None: print('S') else: print('F') &gt;&gt;&gt; S F 如果想要进行判空操作，可以用if a和if not a来进行，这样不论a是None还是空字符串或是其它，都可以得到我们想要的结果。 13、对象存在不一定是True 我们前面进行判空操作时都是使用了变量，尝试对一个对象来进行判空操作： class Test1(): pass class Test2(): def __len__(self): return 0 test1 = Test1() test2 = Test2() if test1: print('S') else: print('F') if test2: print('S') else: print('F') &gt;&gt;&gt; S F 从示例可以看出，可以对对象进行判空操作，但是对象存在不一定就是True。 当调用len()函数来传递自己编写的类作为参数时，会自动调用类中定义的__len__()方法(必须在类中有定义，否则报错)。 并且__bool__()会覆盖__len__()的结果。总之自定义对象是否会被视作False是由对象内部的__bool__()和__len__()决定。 class Test1(): def __bool__(self): return False def __len__(self): return True class Test2(): def __len__(self): return True print(bool(Test1())) print(bool(Test2())) &gt;&gt;&gt; True False ","link":"https://tudouvvv.github.io/post/Python学习之路/"},{"title":"用Python爬取斗鱼TV-LOL版块的主播人气","content":"刚好学完这个，就拿来练一练手Σ(っ °Д °;)っ 觉得爬虫最重要的还是要理清思路，先爬什么，然后怎么筛选，我们想要输出怎样的格式... 然后就是最重要的正则表达式了，至少我现在用的就是这个，至于各种爬虫框架还要继续学习，刚开始爬斗鱼的时候，竟然弹出403错误，本来都想换熊猫了，结果过了一会儿就好了 - - 不知道为什么 还有，现在还没有学习关于数据库的知识，不知道怎么储存爬下来的数据，也只会爬取首页(lll￢ω￢) 慢慢来吧，接下来这一周要出去找调剂了，希望有个好结果吧，不过我觉得非全也比错φ(゜▽゜*)♪，等一切都结束可以写一篇记录考研的文章，嘎巴得！ import re from urllib import request class Spider(): url = 'https://www.douyu.com/directory/game/LOL' root_pattern = '&lt;p&gt;([\\s\\S]*?)&lt;/p&gt;' name_pattern = '&lt;span class=&quot;dy-name ellipsis fl&quot;&gt;([\\s\\S]*?)&lt;/span&gt;' number_pattern = '&lt;span class=&quot;dy-num fr&quot; &gt;([\\s\\S]*?)&lt;/span&gt;' def __fetch_content(self): r = request.urlopen(Spider.url) htmls = r.read() htmls = str(htmls,encoding = 'utf-8') return htmls def __analisis(self,htmls): root_html = re.findall(Spider.root_pattern,htmls) anchors = [] for html in root_html: name = re.findall(Spider.name_pattern,html) number = re.findall(Spider.number_pattern,html) anchor = {'name':name,'number':number} anchors.append(anchor) return anchors def __refine(self,anchors): l = lambda anchor: { 'name':anchor['name'][0], 'number':anchor['number'][0]} return map(l,anchors) def __sort(self,anchors): anchors = sorted(anchors,key=self.__sort_seed,reverse=True) return anchors def __sort_seed(self,anchor): r = re.findall('\\d*',anchor['number']) number = float(r[0]) if '万' in anchor['number']: number*=10000 return number def __show(self,anchors): for anchor in anchors: print(anchor['name']+ '-----' + anchor['number']+'人') def go(self): htmls = self.__fetch_content() anchors = self.__analisis(htmls) anchors = list(self.__refine(anchors)) anchors = self.__sort(anchors) self.__show(anchors) spider = Spider() spider.go() 只爬取了一页，因为我还不知道怎么爬取多页- - 爬取结果：（2018/3/18 22：52） 英雄联盟官方赛事-----130万人 东北大鹌鹑-----127万人 冯提莫-----115万人 洞主丨歌神洞庭湖-----46.6万人 叫我久哥哥-----25.8万人 叶音符-----19.7万人 赏金术士2018-----14.2万人 小子y-----12.3万人 三笠ackerman丶1-----10.7万人 胖胖灬-----10.5万人 余小C真的很强-----10.2万人 lol大表哥丶-----9.2万人 黑白锐雯-----8.3万人 LoveAcFun包子-----8.1万人 心态很不好的momo-----7.4万人 14德莱文-----7.2万人 你的大湿胸丶-----5.7万人 教练JoKer-----5.5万人 凉风亚索yasuo-----4.7万人 冷爷行妹-----4.6万人 狗康Bfate丶-----3.8万人 跳跳武器二师兄-----3.5万人 熙宝兒-----3.3万人 一拳超人King丶-----3.2万人 解小亮-----3万人 douyu丶松子-----3万人 Tumi111-----2.9万人 Douyu若雨-----2.8万人 林瑜有鱼aa-----2.5万人 暴风工作室丶-----2.4万人 小熊和你-----1.9万人 成都二傻子丶骚特-----1.8万人 芜湖灬王导-----1.8万人 青蛙ob-----1.8万人 张海彬丶-----1.6万人 作作金克丝-----1.6万人 泰迪日了哈士奇-----1.5万人 西关龙-----1.5万人 内涵段子丶朵朵-----1.5万人 羽毛发条丶31969-----1.5万人 小祖zmy-----1.5万人 特工小琪琪-----1.4万人 我有一条小尾巴吖-----1.4万人 乌鸦c丶叫我大马哥-----1.3万人 污妖王丶扎男-----1.3万人 老实巴交的残梦-----1.3万人 土豆女王驾到-----1.3万人 小丫头丶乖乖-----1.2万人 刘刘刘毛豆-----1.2万人 叫我Keep哥-----1.2万人 叫我天神x-----1.2万人 国服第一洛冷眸-----1.2万人 西瓜酱G-----1.2万人 许悟空Goku-----1.1万人 你也可以叫我花仔啊-----1.1万人 凌飞Sniperking-----1.1万人 海浪摄长-----1.1万人 渝万丶阿哲-----1.1万人 尔雅超星服务中心-----1.1万人 qq_s6oI4T-----1万人 内涵段子丶渣渣涛-----1万人 吃货丶权爷-----1万人 一只奶酪啊-----1万人 二哈蛮王-----9889人 傲娇筱筱灬-----9875人 屠殺-----9590人 像最初ch-----9485人 娇羞的糖糖啦-----9095人 烁烁and小炮-----8821人 美少女秀秀-----8709人 陈陈陈陈港-----8412人 小崔丶xc-----8374人 zz小龙男枪c-----8300人 Eliza丶梓淇-----8176人 渝万丶小棉花-----8102人 辉哥飞呀挥-----8031人 粉红AD契约喵-----7928人 铁头乌迪尔-----7898人 小诸葛Zz-----7873人 小红集团丶红茶-----7858人 叶晚r-----7858人 肥螳螂老无名-----7830人 寻练-----7792人 会翻滚的阿冰-----7476人 主播丶C罗-----7136人 静儿家的苏麻瓜-----7087人 国服第一小鸡雞-----7034人 659019丶Lux峰-----6956人 三岁喵Meow-----6922人 天才小橙汁-----6848人 偷人大叔玩安妮-----6816人 mm丶小小酥-----6798人 NaiDiiiiii-----6792人 我就是蘑菇阿i-----6528人 中年人的钻石梦-----6451人 杨少爷与黄公子-----6373人 宅兔兔-----6364人 田间一牧牛小童-----6355人 杀神红名-----6205人 丑角乌拉拉-----6185人 小生不才丶y-----6106人 渝万丶阿新哥-----6024人 赛事专用直播间-----5982人 开水铺阿亮-----5970人 nu儿哈哈哈-----5936人 美腻哈-----5878人 青岛声优娜阿-----5785人 丶小雪兔儿-----5763人 ","link":"https://tudouvvv.github.io/post/用Python爬取斗鱼TV的LOL-版块的主播人气/"},{"title":"终于完成了φ(゜▽゜*)♪","content":"做了好几天 终于完成了主要内容 开心 本来很早以前就想做一个的 感觉非常的酷 之前做的那个找的模板太搞笑 完全不知道怎么操作 以为还要学习html和css就放弃了 考完研又网上看了一些 结果发现竟然如此简单 - - 刚开始时把 npm 命令 认成 nmp 被卡在第一步 简直要笑死 幸好还是搞成了 那么 以后请多多指教！ ","link":"https://tudouvvv.github.io/post/终于完成了/"}]}