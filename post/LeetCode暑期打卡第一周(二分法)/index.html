<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>LeetCode暑期打卡第一周(二分法) | Tudouvvv</title>
<meta name="description" content="人生还长，慢慢来">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://tudouvvv.github.io//favicon.ico?v=1563366891084">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://tudouvvv.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://tudouvvv.github.io/">
        <img src="https://tudouvvv.github.io//images/avatar.png?v=1563366891084" class="site-logo">
        <h1 class="site-title">Tudouvvv</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/tudouvvv" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://www.instagram.com/gu_lo__/" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
          <a class="social-link" href="https://weibo.com/u/303731603" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      人生还长，慢慢来
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/tudouvvv" target="_blank">Tudouvvv</a> | <a class="rss" href="https://tudouvvv.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">LeetCode暑期打卡第一周(二分法)</h2>
            <div class="post-date">2019-07-15</div>
            
              <div class="feature-container" style="background-image: url('https://tudouvvv.github.io//post-images/LeetCode暑期打卡第一周(二分法).jpg')">
              </div>
            
            <div class="post-content">
              <!--more-->
<p>二分的知识点就是每次把备选答案的空间缩小一半，但是整数二分一个很蛋疼的问题就是边界问题。</p>
<h3 id="二分思想">二分思想：</h3>
<p>答案是在一个区间之中，L-----R，通过中点的情况来判断答案的所处位置，然后删掉另外一边，缩小一半备选空间，然后再继续判断新的中点的情况，直到L==R找到答案。</p>
<p>70% 的二分题目都跟单调性有关(其余的题目虽然可以用二分但是不一定具有单调性)<br>
95% 的题目存在两段性的性质（左边一段成立，右边一段不成立），就可以找到一个边界点。</p>
<h3 id="时间复杂度logn">时间复杂度：logN</h3>
<h3 id="二分模板">二分模板</h3>
<h4 id="模板一">模板一：</h4>
<p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid]</code>和<code>[mid + 1, r]</code>时，其更新操作是<code>r = mid</code>或者<code>l = mid + 1</code>;，计算<code>mid</code>时不需要加1。</p>
<pre><code>int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;    // 向下取整
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
</code></pre>
<h4 id="模板二">模板二</h4>
<p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid - 1]</code>和<code>[mid, r]</code>时，其更新操作是<code>r = mid - 1</code>或者<code>l = mid</code>;，此时为了防止死循环，计算<code>mid</code>时需要加1。</p>
<pre><code>int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;    // 向上取整
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h3 id="二分的流程">二分的流程：</h3>
<ol>
<li>先考虑二分的区间;</li>
<li>编写二分的代码框架;</li>
<li>设计一个check（性质）;</li>
<li>判断一下区间如何更新;</li>
<li>如果更新方式写的是l = mid，r = mid - 1，那么就在算mid的时候加上1</li>
</ol>
<h3 id="习题练习">习题练习</h3>
<h5 id="69-sqrtx"><a href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x)</a></h5>
<p>题目描述：计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：首先二分的区间是[0, x]，然后确定一下判断的性质，我们想要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">mid^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>&lt;=x，那么就应该用第二个模板。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        int l=0, r=x;
        while (l &lt; r)
        {
            int mid = l + (long long)r + 1 &gt;&gt; 1;   // 防止mid溢出，所以用long long 型
            if (mid &lt;= x / mid)  l=mid;   //并且为了防止陷入死循环，需要+1向上取整
            else r = mid -1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def mySqrt(self, x: int) -&gt; int:
        l, r = 0, x
        while l&lt;r:
            mid = l + r + 1 &gt;&gt; 1
            if mid &lt;= (x / mid):
                l = mid
            else:
                r = mid -1
        return l
</code></pre>
<p>当然也可以选择另一个判断方式，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">mid^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>&gt;x，此时在[0, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><msqrt><mi>x</mi></msqrt><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left \lfloor\sqrt{x }\right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>]内是不满足的，在[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><msqrt><mi>x</mi></msqrt><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left \lfloor\sqrt{x }\right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>+1, x]内是满足的，所以最后返回l-1或者r-1即可</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        if (x==1) return 1;
        if (x==0) return 0;
        int l=0, r=x;
        while (l &lt; r) {
            int mid = l + (long long)r &gt;&gt; 1;
            if (mid &gt; x/mid)   r = mid;
            else l = mid + 1;
        }
        return l-1;
    }
};
</code></pre>
<h4 id="35-search-insert-position"><a href="https://leetcode.com/problems/search-insert-position/">35. Search Insert Position</a></h4>
<p>题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>
你可以假设数组中无重复元素。</p>
<p>分析：首先可二分的边界条件就是数组的大小，即[0, nums.size()]，我们确定的check条件是：nums[mid] &gt;= target，那就说明target在mid的左边，需要改变 右边界<code>r = mid</code>，如果nums[mid] &lt; target，就说明target在mid右边，需要改变左边界，<code>l = mid + 1</code>。当然check条件也可以改为nums[mid]&lt;target，这样区间更新策略换一下就行。</p>
<p>确定一下边界条件：如果数组为空，那么应该返回0；如果target&gt;nums.back()，返回数组的长度。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty() || target &gt; nums.back()) return nums.size();
        int l=0, r = nums.size()-1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r=mid;
            else  l = mid+1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchInsert(self, nums: List[int], target: int) -&gt; int:
        if len(nums) == 0 or target &gt; nums[-1]:
            return len(nums)
        l = 0
        r = len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target:
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="34-find-first-and-last-position-of-element-in-sorted-array"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></h4>
<p>题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>
你的算法时间复杂度必须是 O(log n) 级别，如果数组中不存在目标值，返回 [-1, -1]。<br>
示例：</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
</code></pre>
<p>分析：因为要返回两个位置，所以应该要用两次二分法，一次返回开始位置的索引，一次返回结束位置的索引。首先是开始位置，nums[mid] &gt;= target，然后是结束位置，nums[mid] &lt;= target。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty()) return {-1, -1};
        int l =0, r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) return {-1, -1};
        int start = l;
        l = 0, r = nums.size() - 1;
        while(l &lt; r)
        {
            int mid = l + r  + 1 &gt;&gt; 1;
            if (nums[mid] &lt;= target) l = mid;
            else r = mid - 1;
        }
        int end = r;
        return {start, end};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
        if len(nums) == 0: return [-1, -1]
        l, r = 0, len(nums)-1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target:
                r = mid
            else: l = mid + 1
        if nums[l] != target: return [-1, -1]
        else: start = l
        l, r = 0, len(nums)-1
        while l &lt; r:
            mid = l + r + 1 &gt;&gt; 1
            if nums[mid] &lt;= target:
                l = mid
            else: r = mid - 1
        end = r
        return [start, end]
</code></pre>
<h4 id="74-search-a-2d-matrix"><a href="https://leetcode.com/problems/search-a-2d-matrix/">74. Search a 2D Matrix</a></h4>
<p>题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。<br>
示例：</li>
</ul>
<pre><code>输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true
</code></pre>
<p>分析：如果展成一列的话，那么是单调递增的，这样就可以把整个空间分成两部分，check的性质是nums[mid] &gt;= target，需要了解到的是，数组的长度是：<code>n * m</code>(n为矩阵的行数，n为矩阵的列数)，然后还需要把mid还原为i和j，<code>i = mid // m</code>，<code>j = mid % m</code>。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) return false;
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = m * n - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (matrix[mid / m][mid % m] &gt;= target) r = mid;
            else l = mid + 1;
        }
        return matrix[r / m][r % m] == target;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        if len(matrix) == 0 or len(matrix[0]) == 0: return False
        n = len(matrix)
        m = len(matrix[0])
        l = 0
        r = m * n - 1
        while l &lt; r:
            mid  = l + r &gt;&gt; 1
            if matrix[mid // m][mid % m] &gt;= target:
                r = mid
            else: l = mid + 1
        return matrix[l // m][l % m] == target
</code></pre>
<h4 id="153-find-minimum-in-rotated-sorted-array"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></h4>
<p>题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
<code>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</code>请找出其中最小的元素，你可以假设数组中不存在重复元素。</p>
<p>分析：题目就是说把一个升序数组的一部分移到了数组的前面，如果用二分法来做的话，就首先应该找到一个二段性，可以把整个区间分成两部分。<br>
<img src="https://tudouvvv.github.io//post-images/1563356609008.png" alt=""><br>
如图，整个数组的分布相当于这个样子，我们想找的就是红色的这个点，判断的条件就是：<code>nums[mid] &lt;= nums.back()</code>，nums.back()就是蓝色的这个点，这样就把整个数组分成了两部分。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int l = 0, r = nums.size();
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt;= nums.back()) r = mid;
            else l = mid + 1;
        }
        return nums[r];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findMin(self, nums: List[int]) -&gt; int:
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &lt;= nums[-1]:
                r = mid
            else: l = mid + 1
        return nums[l]
</code></pre>
<h4 id="33-search-in-rotated-sorted-array"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></h4>
<p>题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
<code>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )</code><br>
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>
你可以假设数组中不存在重复的元素，你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>分析：虽然这道题没有明显的二分性，但是可以曲线救国，首先可以找到数组的最小值，把整个数组分成两块儿，然后再通过与<code>nums.back()</code>的比较来查看target是属于哪一块儿，再到该块儿进行二分。那第一步找到数组的最小值可以直接复用上一道题。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty()) return -1;
        int l = 0, r = nums.size() - 1;
        // 找到最小值的位置
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt;= nums.back()) r = mid;
            else l = mid + 1;
        }
	// 判断target属于哪一块儿
        if (target &gt; nums.back()) l = 0, r --;
        else r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r + 1&gt;&gt; 1;
            if (nums[mid] &lt;= target) l = mid;
            else r = mid - 1;
        }
        if (nums[l] == target) return l;
        return -1;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def search(self, nums: List[int], target: int) -&gt; int:
        if not nums: return -1;
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &lt;= nums[-1]:
                r = mid
            else: l = mid + 1
        if target &gt; nums[-1]: 
            l = 0
            r -= 1
        else: r = len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target: r = mid
            else: l = mid + 1
        if target == nums[l]: return l
        else: return -1
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://tudouvvv.github.io//tag/leetcode" class="tag">
                    Leetcode
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://tudouvvv.github.io//post/942-DI-String-Match">
                  <h3 class="post-title">
                    [每日一题]-942. DI String Match
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
