<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tudouvvv.github.io/</id>
    <title>Tudouvvv</title>
    <updated>2019-12-18T01:46:32.470Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tudouvvv.github.io/"/>
    <link rel="self" href="https://tudouvvv.github.io//atom.xml"/>
    <subtitle>人生还长，慢慢来</subtitle>
    <logo>https://tudouvvv.github.io//images/avatar.png</logo>
    <icon>https://tudouvvv.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Tudouvvv</rights>
    <entry>
        <title type="html"><![CDATA[做作的日常②]]></title>
        <id>https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang2</id>
        <link href="https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang2">
        </link>
        <updated>2019-12-17T03:46:53.000Z</updated>
        <content type="html"><![CDATA[<h4 id="179-largest-number"><a href="https://leetcode.com/problems/largest-number/">179. Largest Number</a></h4>
<p>题目描述：<br>
Given a list of non negative integers, arrange them such that they form the largest number.</p>
<pre><code>Example 1:
Input: [10,2]
Output: &quot;210&quot;
</code></pre>
<pre><code class="language-c++">class Solution {
public:
    
    static bool cmp(int a, int b){
        string as = to_string(a), bs = to_string(b);
        return as + bs &gt; bs + as;
    }
    
    string largestNumber(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end(), cmp);
        string res;
        for (auto x : nums) res += to_string(x);
        int k = 0;
        while (res[k] == '0') k ++;
        return k == res.size() ? &quot;0&quot; : res.substr(k, res.size());
    }
};
</code></pre>
<pre><code class="language-python">from functools import cmp_to_key

class Solution:
    def largestNumber(self, nums: List[int]) -&gt; str:
        if not nums: return ''
        nums = map(str, nums)
        nums = sorted(nums, key = cmp_to_key(lambda a, b : int(a + b) - int (b + a)), reverse=True)
        return &quot;&quot;.join(nums).lstrip('0') or '0'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week7]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week7</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week7">
        </link>
        <updated>2019-11-12T01:23:56.000Z</updated>
        <content type="html"><![CDATA[<h4 id="80-骰子的点数">80. 骰子的点数</h4>
<p>题目描述：将一个骰子投掷n次，获得的总点数为s，s的可能范围为n~6n。<br>
掷出某一点数，可能有多种掷法，例如投掷2次，掷出3点，共有[1,2],[2,1]两种掷法。<br>
请求出投掷n次，掷出n~6n点分别有多少种掷法。</p>
<pre><code>样例1
输入：n=1
输出：[1, 1, 1, 1, 1, 1]
解释：投掷1次，可能出现的点数为1-6，共计6种。每种点数都只有1种掷法。所以输出[1, 1, 1, 1, 1, 1]。
</code></pre>
<p>思路:</p>
<ol>
<li>递归方法来做，我们用次数n和总和sum作为状态，sum的取值为n--6n.</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; numberOfDice(int n) {
        vector&lt;int&gt; res;
        for (int i = n; i &lt;= 6 * n; i ++) res.push_back(dfs(n, i));
        return res;
    }
    
    int dfs(int n, int sum){
        if (sum &lt; 0) return 0;
        if (n == 0) return !sum;
        int res = 0;
        
        for(int i = 1; i &lt;= 6; i ++){
            res += dfs(n - 1, sum - i);
        }
        return res;
    }
};
</code></pre>
<p>但是由于计算的状态太多，超时了。<br>
2. 动态规划</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; numberOfDice(int n) {
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(6 * n + 1));
        f[0][0] = 1;
        for (int i = 1; i &lt;= n; i ++)  // 表示次数
            for (int j = i; j &lt;= 6 * i; j ++) // 表示sum的取值
                for (int k = 1; k &lt;= min(j ,6); k ++){
                    f[i][j] += f[i - 1][j - k];  // 状态转移
                }
        vector&lt;int&gt; res;
        for (int i = n; i &lt;= 6 * n; i ++) res.push_back(f[n][i]);
        return res;
    }
};
</code></pre>
<h4 id="79-滑动窗口的最大值">79. 滑动窗口的最大值</h4>
<p>题目描述：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。<br>
例如，如果输入数组[2, 3, 4, 2, 6, 2, 5, 1]及滑动窗口的大小3,那么一共存在6个滑动窗口，它们的最大值分别为[4, 4, 6, 6, 6, 5]。<br>
注意：<br>
数据保证k大于0，且k小于等于数组长度。</p>
<pre><code>样例
输入：[2, 3, 4, 2, 6, 2, 5, 1] , k=3
输出: [4, 4, 6, 6, 6, 5]
</code></pre>
<p>思路：我们维护一个双向单调队列，队列放的是元素的下标。我们假设该双端队列的队头是整个队列的最大元素所在下标，至队尾下标代表的元素值依次降低。初始时单调队列为空。随着对数组的遍历过程中，每次插入元素前，首先需要看队头是否还能留在队列中，如果队头下标距离i超过了k，则应该出队。同时需要维护队列的单调性，如果nums[i]大于或等于队尾元素下标所对应的值，则当前队尾再也不可能充当某个滑动窗口的最大值了，故需要队尾出队。始终保持队中元素从队头到队尾单调递减。依次遍历一遍数组，每次队头就是每个滑动窗口的最大值所在下标。<br>
时间复杂度分析：每个元素最多入队出队一次，复杂度为O(n)</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; maxInWindows(vector&lt;int&gt;&amp; nums, int k) {
        deque&lt;int&gt; q;
        vector&lt;int&gt; res;
        for (int i = 0; i &lt; nums.size(); i ++){
            while (q.size() &amp;&amp; nums[i] &gt; nums[q.back()]) q.pop_back();  // 维护单调性
            if (q.size() &amp;&amp; i - q.front() &gt;= k) q.pop_front();  // 如果队头元素与下标距离超过k，则应该出队
            q.push_back(i);
            if (i - k + 1 &gt;= 0) res.push_back(nums[q.front()]);
        }
        return res;
    }
};
</code></pre>
<h4 id="81-扑克牌的顺子">81. 扑克牌的顺子</h4>
<p>题目描述：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。<br>
2～10为数字本身，A为1，J为11，Q为12，K为13，大小王可以看做任意数字。<br>
为了方便，大小王均以0来表示，并且假设这副牌中大小王均有两张。</p>
<pre><code>样例1
输入：[8,9,10,11,12]
输出：true
</code></pre>
<p>思路：<br>
1.<br>
首先要计算出给定的数组中0的个数<br>
其次需要知道不是顺子的条件：1）如果给定的牌中有对子，那么肯定不是顺子；2）如果两个牌之间的差值超过了0的个数，那么肯定也不是。</p>
<pre><code class="language-c++">class Solution {
public:
    bool isContinuous( vector&lt;int&gt; numbers ) {
        int n = numbers.size();
        if (n &lt; 5) return false;
        sort(numbers.begin(), numbers.end());
        int cnt = 0;
        for (int i = 0; i &lt; n - 1; i ++){
            if (numbers[i] == 0) cnt ++;
            else
            {
                if (numbers[i + 1] == numbers[i]) return false;
                if (numbers[i + 1] - numbers[i] - 1 &gt; cnt) return false;
                cnt -= numbers[i + 1] - numbers[i] - 1;
            }
        }
        return true;
    }
};
</code></pre>
<ol start="2">
<li>一个总和为5的顺子，那么最大值与最小值之间的差距一定是5</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    bool isContinuous( vector&lt;int&gt; numbers ) {
        if (numbers.empty()) return false;
        sort(numbers.begin(), numbers.end());
        int k = 0;
        while (! numbers[k]) k ++;
        for (int i = k + 1; i &lt; numbers.size();i ++){
            if (numbers[i] == numbers[i - 1]) return false; 
        }
        return numbers.back() - numbers[k] &lt;= 4;
    }
};
</code></pre>
<h4 id="82-圆圈中最后剩下的数字">82. 圆圈中最后剩下的数字</h4>
<p>题目描述：0, 1, …, n-1这n个数字(n&gt;0)排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。<br>
求出这个圆圈里剩下的最后一个数字。</p>
<pre><code>样例
输入：n=5 , m=3
输出：3
</code></pre>
<p>思路: 每次需要计算出删除元素的索引值，然后删除即可。</p>
<pre><code class="language-c++">class Solution {
public:
    int lastRemaining(int n, int m){
        if (n == 0 || m == 0) return -1;
        vector&lt;int&gt; res;
        for (int i = 0; i &lt; n; i ++) res.push_back(i);
        int pos = 0;
        while (res.size() &gt; 1){
            pos = (pos + m - 1) % res.size();
            res.erase(res.begin() + pos);
        }
        return res[0];
    }
};
</code></pre>
<pre><code class="language-python">class Solution(object):
    def lastRemaining(self, n, m):
        &quot;&quot;&quot;
        :type n: int
        :type m: int
        :rtype: int
        &quot;&quot;&quot;
        if n == 0 or m == 0: return -1;
        res = [i for i in range(n)]
        pos = 0
        while len(res) &gt; 1:
            pos = (pos + m - 1) % len(res)
            res.pop(pos)
        return res[0]   
</code></pre>
<h4 id="83-股票的最大利润">83. 股票的最大利润</h4>
<p>题目描述：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 一次 该股票可能获得的利润是多少？<br>
例如一只股票在某些时间节点的价格为[9, 11, 8, 5, 7, 12, 16, 14]。<br>
如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。</p>
<pre><code>样例
输入：[9, 11, 8, 5, 7, 12, 16, 14]
输出：11
</code></pre>
<p>思路:</p>
<ol>
<li>构建一个数组，每个位置存的是当前元素之前的min(自己，自己之前的最小值)，最后算最大值的时候只需要遍历一次该数组就可以了。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxDiff(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int n = nums.size();
        vector&lt;int&gt; minnum(n);
        minnum[0] = nums[0];
        for (int i = 1; i &lt; n; i ++){
            if (nums[i] &lt; minnum[i - 1]) minnum[i] = nums[i];
            else minnum[i] = minnum[i - 1];
        }
        int res = 0;
        for (int i = 0; i &lt; n; i ++) res = max(res, nums[i] - minnum[i]);
        return res;
    }
};
</code></pre>
<ol start="2">
<li>也可以只维护一个最小值的变量就可以了。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxDiff(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int res = 0;
        for (int i = 1, minv = nums[0]; i &lt; nums.size(); i ++){
            res = max(res, nums[i] - minv);
            minv = min(minv, nums[i]);
        }
        return res;
    }
};
</code></pre>
<h4 id="84-求12n">84. 求1+2+…+n</h4>
<p>题目描述：求1+2+…+n,要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<pre><code>样例
输入：10
输出：55
</code></pre>
<p>思路: 求和运算可以通过递归的方式来做，主要的问题就是我们的终止条件是什么，可以通过判断n是否为0来进行终止。</p>
<pre><code class="language-c++">class Solution {
public:
    int getSum(int n) {
        int sum = n;
        n &amp;&amp; (sum += getSum(--n));
        return sum;
    }
};
</code></pre>
<h4 id="85-不用加减乘除做加法">85. 不用加减乘除做加法</h4>
<p>题目描述：写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷ 四则运算符号。</p>
<pre><code>样例
输入：num1 = 1 , num2 = 2
输出：3
</code></pre>
<p>思路:<br>
1、两个整数做异或^，得到各位相加不进位的运算结果；<br>
2、两个整数做与&amp;，然后再左移一位，即得到进位的运算结果；<br>
3、将上面两个结果相加，即重复步骤1,2，直至进位的运算结果为0；</p>
<pre><code class="language-c++">class Solution {
public:
    int add(int num1, int num2){
        while (num2){
            int sum = num1 ^ num2;
            int carry = (num1 &amp; num2) &lt;&lt; 1;
            num1 = sum, num2 = carry;
        }
        return num1;
    }
};
</code></pre>
<h4 id="86-构建乘积数组">86. 构建乘积数组</h4>
<p>题目描述：给定一个数组A[0, 1, …, n-1]，请构建一个数组B[0, 1, …, n-1]，其中B中的元素B[i]=A[0]×A[1]×… ×A[i-1]×A[i+1]×…×A[n-1]。<br>
<strong>不能使用除法。</strong></p>
<pre><code>样例
输入：[1, 2, 3, 4, 5]
输出：[120, 60, 40, 30, 24]
</code></pre>
<p>思考题：<br>
能不能只使用常数空间？（除了输出的数组之外）<br>
思路：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week6]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week6</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week6">
        </link>
        <updated>2019-11-08T08:46:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="68-0到n-1中缺失的数字">68. 0到n-1中缺失的数字</h4>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。<br>
在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<pre><code>样例
输入：[0,1,2,4]
输出：3
</code></pre>
<p>思路:</p>
<ol>
<li>第一眼看到这道题就想到用前n个数字的和去求。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int getMissingNumber(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int count = n * (n + 1) &gt;&gt; 1;
        int res = 0;
        for (x : nums) res += x;
        return count - res;
    }
};
</code></pre>
<ol start="2">
<li>可是谁又能想到这道题竟然也可以用二分的方式来做呢。❓❓❓因为数组下标的关系，所以正常的序列当前值就是下标的值，同通过这个判断条件进行判断。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int getMissingNumber(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int l = 0, r = nums.size() - 1;
        while (l &lt; r){
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] == mid) l = mid + 1;
            else r = mid;
        }
        if (nums[l] == l) l ++;  // 当所有数都满足的时候，缺失就是n
        return l;
    }
};
</code></pre>
<h4 id="69-数组中数值和下标相等的元素">69. 数组中数值和下标相等的元素</h4>
<p>题目描述：假设一个单调递增的数组里的每个元素都是整数并且是唯一的。<br>
请编程实现一个函数找出数组中任意一个数值等于其下标的元素。<br>
例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。</p>
<pre><code>样例
输入：[-3, -1, 1, 3, 5]
输出：3
注意:如果不存在，则返回-1。
</code></pre>
<p>思路：</p>
<ol>
<li>直接遍历，复杂度O(n);</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int getNumberSameAsIndex(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return -1;
        for (int i = 0; i &lt; nums.size(); i ++){
            if (nums[i] == i) return i;
        }
        return -1;
    }
};
</code></pre>
<ol start="2">
<li>又一次没想到这道题可以用二分来做，由于给的数组是单调递增的，所以在答案的左边，肯定所有的元素都小于下标，右边所有的元素都大于下标。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int getNumberSameAsIndex(vector&lt;int&gt;&amp; nums) {
        int l = 0, r = nums.size() - 1;
        while (l &lt; r){
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= mid) r = mid;
            else l = mid + 1;
        }
        if (nums[l] - l == 0) return nums[l];
        return -1;
    }   
};
</code></pre>
<h4 id="70-二叉搜索树的第k个结点">70. 二叉搜索树的第k个结点</h4>
<p>题目描述：给定一棵二叉搜索树，请找出其中的第k小的结点。<br>
你可以假设树和k都存在，并且1≤k≤树的总结点数。</p>
<pre><code>样例
输入：root = [2, 1, 3, null, null, null, null] ，k = 3

    2
   / \
  1   3

输出：3
</code></pre>
<p>思路: 中序遍历该树即可，然后每次pop的时候记得k--，当k为0的时候就说明这就是我们要找的第k小的节点。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* kthNode(TreeNode* root, int k) {
        stack&lt;TreeNode*&gt; stk;
        auto p = root;
        while (p || stk.size()){
            while (p){
                stk.push(p);
                p = p-&gt;left;
            }
            if (stk.size()){
                p = stk.top();
                stk.pop();
                k --;
                if (! k) return p;
                else {
                    p = p -&gt; right;
                }
            }
        }
        return NULL;
    }
};
</code></pre>
<h4 id="71-二叉树的深度">71. 二叉树的深度</h4>
<p>题目描述：输入一棵二叉树的根结点，求该树的深度。<br>
从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<pre><code>样例
输入：二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：
    8
   / \
  12  2
     / \
    6   4

输出：3
</code></pre>
<p>思路：</p>
<ol>
<li>遍历的时候，每次可以成功遍历的时候，深度 + 1, 存储一个全局的最深深度。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int treeDepth(TreeNode* root) {
        if (! root) return 0;
        dfs(root, 1);
        return ans;
    }
    
    void dfs(TreeNode* root, int d){
        if (root-&gt;left) dfs(root-&gt;left, d + 1);
        if (root-&gt;right) dfs(root-&gt;right, d + 1);
        ans = max(ans, d);
    }
};
</code></pre>
<ol start="2">
<li>可以用自己递归来做, 分别找到左节点和右节点的最大深度，然后max一下取最大值即可。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int treeDepth(TreeNode* root) {
        if (! root) return 0;
        return max(treeDepth(root-&gt;left) + 1, treeDepth(root-&gt;right) + 1);
    }
};
</code></pre>
<h4 id="72-平衡二叉树">72. 平衡二叉树</h4>
<p>题目描述: 输入一棵二叉树的根结点，判断该树是不是平衡二叉树。<br>
如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br>
注意：<br>
规定空树也是一棵平衡二叉树。</p>
<pre><code>样例
输入：二叉树[5,7,11,null,null,12,9,null,null,null,null]如下所示，
    5
   / \
  7  11
    /  \
   12   9
输出：true
</code></pre>
<p>思路: 分别求出左右子树的深度，然后进行判断。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    bool ans = true;
    
    bool isBalanced(TreeNode* root) {
        dfs(root);
        return ans;
    }
    
    int dfs(TreeNode* root){
        if (! root) return 0;
        auto left = dfs(root-&gt;left);
        auto right = dfs(root-&gt;right);
        if (abs(left-right) &gt; 1) ans = false;
        return max(left, right) + 1;
    }
};
</code></pre>
<h4 id="73-数组中只出现一次的两个数字">73. 数组中只出现一次的两个数字</h4>
<p>题目描述：一个整型数组里除了<strong>两个数字</strong>之外，其他的数字都出现了<strong>两次</strong>。<br>
请写程序找出这两个只出现一次的数字。<br>
你可以假设这两个数字一定存在。</p>
<pre><code>样例
输入：[1,2,3,3,4,4]

输出：[1,2]
</code></pre>
<p>思路：</p>
<ol>
<li>创一个hash存每个元素出现的次数，最后再遍历一遍，把次数为1的存起来就好了。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findNumsAppearOnce(vector&lt;int&gt;&amp; nums) {
        unordered_map &lt;int, int&gt; hash;
        vector&lt;int&gt; res;
        for (auto x : nums) hash[x] ++;
        for (item : hash){
            if (item.second == 1) res.push_back(item.first);
        }
        return res;
    }
};
</code></pre>
<ol start="2">
<li>因为异或运算中，两个相同的数异或结果肯定为0，所以整个数组的异或结果就是两个不同的数的异或结果，寻找这个结果中为1的那位，根据这位为1，将数组分为两部分，这样两个不同的数就属于不同的集合，然后在每个集合中进行异或运算得到结果。</li>
</ol>
<pre><code>c++
class Solution {
public:
    vector&lt;int&gt; findNumsAppearOnce(vector&lt;int&gt;&amp; nums) {
        int sum = 0;
        for (auto x : nums) sum ^= x;
        int k = 0;
        while (!(sum &gt;&gt; k &amp; 1)) k ++;
        int first = 0;
        for (auto x : nums){
            if (x &gt;&gt; k &amp; 1) first ^= x;
        }
        return vector&lt;int&gt; {first, sum^first};
   
</code></pre>
<h4 id="74-数组中唯一只出现一次的数字">74. 数组中唯一只出现一次的数字</h4>
<p>题目描述：在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。<br>
请找出那个只出现一次的数字。<br>
你可以假设满足条件的数字一定存在。<br>
思考题：<br>
如果要求只使用 O(n) 的时间和额外  O(1)  的空间，该怎么做呢？</p>
<pre><code>样例
输入：[1,1,1,2,2,2,3,4,4,4]
输出：3
</code></pre>
<p>思路: 由于是int型数，所有共有32位，我们统计每个位上0和1的个数，最后再模3，如果是1就说明出现一次的这个数该位是1，反之则是0，最后拼起来就好了。</p>
<pre><code class="language-c++">class Solution {
public:
    int findNumberAppearingOnce(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; sum(32);
        for (auto x : nums){
            for (int i = 0; i &lt; 32; i ++){
                int p = (x &gt;&gt; i &amp; 1);
                sum[i] += p;
            }
        }
        
        int res = 0;
        for (int i = 0; i &lt; 32; i ++){
            res += (sum[i] % 3 == 0 ? 0 : 1) &lt;&lt; i;
        }
        return res;
    }
};
</code></pre>
<h4 id="75-和为s的两个数字">75. 和为S的两个数字</h4>
<p>题目描述：输入一个数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。<br>
如果有多对数字的和等于s，输出任意一对即可。<br>
你可以认为每组输入中都至少含有一组满足条件的输出。</p>
<pre><code>样例
输入：[1,2,3,4] , sum=7
输出：[3,4]
</code></pre>
<p>思路: 和leetcode的第一题一样，不同的是那道题存放的是索引，这道题可以存放每个数本身，然后进行判断即可。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findNumbersWithSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hash;
        for (int i = 0; i &lt; nums.size(); i ++){
            if (hash.count(target - nums[i])) return {hash[target - nums[i]], nums[i]};
            hash[nums[i]] = nums[i];
        }
    }
};
</code></pre>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findNumbersWithSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_set&lt;int&gt; hash;
        for (int i = 0; i &lt; nums.size(); i ++){
            if (hash.count(target - nums[i])) return {target - nums[i], nums[i]};
            hash.insert(nums[i]);
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week5(1道没有做)]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week5</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week5">
        </link>
        <updated>2019-11-06T12:13:03.000Z</updated>
        <content type="html"><![CDATA[<h4 id="57-数字序列中某一位的数字">57. <a href="https://www.acwing.com/problem/content/52/">数字序列中某一位的数字</a></h4>
<p>题目描述：数字以0123456789101112131415…的格式序列化到一个字符序列中。<br>
在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。<br>
请写一个函数求任意位对应的数字。</p>
<pre><code>样例
输入：13
输出：1
</code></pre>
<p>思路：</p>
<ol>
<li>首先确定它是几位数</li>
<li>确定是几位数的第几个数</li>
<li>确定是那个数的第几位</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int digitAtIndex(int n) {
        long long i = 1, s = 9, base = 1;
        // i 表示几位数，s表示该位共有几个数字，base表示该位的起始数字是几
        while (n &gt; i * s){
            n -= i * s;
            i ++;
            s *= 10;
            base *= 10;
        }
        int number = base + (n + i - 1) / i - 1;
        // 这里应该n/i上取整，但是c++中没有上取整，所以用n+i-1代替
        int r = n % i ? n % i : i;
        for (int j = 0; j &lt; i - r; j ++) number /= 10;
        // 已经知道是哪个数字，并且也知道是哪一位，只需要把后面的删掉就可以了
        // 比如number=23432，r=2，我们要求的就是3，把后三位删掉，即i-r位删掉
        return number % 10;
    }
};
</code></pre>
<pre><code class="language-python">class Solution:
    def findNthDigit(self, n: int) -&gt; int:
        i, s, base = 1, 9, 1
        while n &gt; i * s:
            n -= i * s
            i += 1
            s *= 10
            base *= 10
        number = base + int ((n + i - 1) / i ) - 1
        r = n % i if n % i else i;
        for j in range(i - r):
            number /= 10
        return int (number % 10)
</code></pre>
<p>ps. leetcode400</p>
<h4 id="58-把数组排成最小的数">58. 把数组排成最小的数</h4>
<p>题目描述：<br>
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>
例如输入数组[3, 32, 321]，则打印出这3个数字能排成的最小数字321323。</p>
<pre><code>样例
输入：[3, 32, 321]
输出：321323
</code></pre>
<p>注意：输出数字的格式为字符串。<br>
思路：这道题本来想的是先寻找所有可能的取值，然后在进行大小的比较，后来超时了。<br>
看到的做法是定义一个新的排序规则，str(a) + str(b) &lt; str(b) + str(a)，这样的话就会使得最小的数排在前面，然后拼起来就好了。</p>
<pre><code class="language-c++">class Solution {
public:
    
    static bool cmp(int a, int b){
        string as = to_string(a), bs = to_string(b);
        return as + bs &lt; bs + as;
    }
        
    string printMinNumber(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end(), cmp);
        string res;
        for (auto x : nums) res += to_string(x);
        return res;
    }
};
</code></pre>
<h4 id="59-把数字翻译成字符串">59. 把数字翻译成字符串</h4>
<p>题目描述：给定一个数字，我们按照如下规则把它翻译为字符串：<br>
0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。<br>
一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。<br>
请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
<pre><code>样例
输入：&quot;12258&quot;
输出：5
</code></pre>
<p>思路：这道题之前做过，可以用动态规划来做。<br>
f[i]表示前i位数字有多少种不同的表示方式，</p>
<pre><code class="language-python">class Solution:
    def getTranslationCount(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        n = len(s);
        f = [0 for _ in range(n + 2)]
        f[0] = 1
        for i in range(1, n + 1):
            f[i] = f[i - 1]
            t = int(s[i - 1]) + int(s[i - 2]) * 10
            if (t &gt;= 10 and t &lt;= 25): f[i] += f[i - 2]
        return f[i]
</code></pre>
<pre><code class="language-c++">class Solution {
public:
    int getTranslationCount(string s) {
        int n = s.size();
        vector&lt;int&gt; f(n + 1);
        f[0] = 1;
        for (int i = 1; i &lt;= n; i ++){
            f[i] = f[i - 1];
            if (i &gt; 1){
                int t = (s[i - 1] - '0') + (s[i - 2] - '0') * 10;
                if (t &gt;= 10 &amp;&amp; t &lt;= 25) f[i] += f[i - 2];
            }
        }
        return f[n];
    }
};
</code></pre>
<h4 id="60-礼物的最大价值">60. 礼物的最大价值</h4>
<p>题目描述：一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。<br>
你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。<br>
给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？<br>
注意：<br>
m, n &gt; 0</p>
<pre><code>样例：
输入：
[
  [2,3,1],
  [1,7,1],
  [4,6,1]
]
输出：19
解释：沿着路径 2→3→7→6→1 可以得到拿到最大价值礼物。
</code></pre>
<p>思路：因为只能向右或者向下走，所以每个点的状态只能通过它上面的格子或者左边的格子转移过来。</p>
<pre><code class="language-c++">class Solution {
public:
    int getMaxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size(), m = grid[0].size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt; (m + 1));
        for (int i = 1; i &lt;= n; i ++)
            for (int j = 1; j &lt;= m; j ++)
            {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + grid[i - 1][j - 1];
            }
        return f[n][m];
    }
};
</code></pre>
<h4 id="61-最长不含重复字符的子字符串">61. 最长不含重复字符的子字符串</h4>
<p>题目描述：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>
假设字符串中只包含从’a’到’z’的字符。</p>
<pre><code>样例
输入：&quot;abcabc&quot;
输出：3
</code></pre>
<p>思路: 两个指针，一个一直往前走，用字典存储它里面每个字母出现的次数，如果遇见了之前遇见的，那么另一个指针就往前走，直到该字母的出现次数再度变为一。</p>
<pre><code class="language-c++">class Solution {
public:
    int longestSubstringWithoutDuplication(string s) {
        unordered_map &lt;char, int&gt; hash;
        int res = 0;
        for (int i = 0, j = 0; i &lt; s.size(); i ++){
            hash[s[i]] ++;
            while (hash[s[i]] &gt; 1) hash[s[j ++]] --;
            res = max(res, i - j + 1);
        }
        return res;
    }
};
</code></pre>
<h4 id="62-丑数">62. 丑数</h4>
<p>题目描述：我们把只包含质因子2、3和5的数称作丑数（Ugly Number）。<br>
例如6、8都是丑数，但14不是，因为它包含质因子7。<br>
求第n个丑数的值。</p>
<pre><code>样例
输入：5
输出：5
</code></pre>
<p>注意：习惯上我们把1当做第一个丑数。<br>
思路: 用三个指针指向1，三个指针分别代表2， 3， 5，每次让它们与它们指向的元素相乘，取最小的添加到我们的丑数序列中，然后指针向后移一位。</p>
<pre><code class="language-c++">class Solution {
public:
    int getUglyNumber(int n) {
        vector&lt;int&gt; q(1, 1);
        int i = 0, j = 0, k = 0;
        while (-- n){
            int t = min(q[i] * 2, min(q[j] * 3, q[k] * 5));
            q.push_back(t);
            if (t == q[i] * 2) i ++;
            if (t == q[j] * 3) j ++;
            if (t == q[k] * 5) k ++;
        }
        return q.back();
    }
};
</code></pre>
<h4 id="63-字符串中第一个只出现一次的字符">63. 字符串中第一个只出现一次的字符</h4>
<p>题目描述: 在字符串中找出第一个只出现一次的字符。<br>
如输入&quot;abaccdeff&quot;，则输出b。<br>
如果字符串中不存在只出现一次的字符，返回#字符。</p>
<pre><code>样例：
输入：&quot;abaccdeff&quot;
输出：'b'
</code></pre>
<p>思路: 用一个字典来储存每个元素出现的次数，然后再遍历这个字典，发现次数为一的直接返回，否则返回#，因为遍历字典的时候就是按照从前往后的顺序。</p>
<pre><code class="language-c++">class Solution {
public:
    char firstNotRepeatingChar(string s) {
        unordered_map&lt;char, int&gt; hash;
        for (auto x : s) hash[x] ++;
        for (c : s)
        {   
            if (hash[c] == 1) return c;
        }
        return '#';
    }
};
</code></pre>
<h4 id="64-字符流中第一个只出现一次的字符">64. 字符流中第一个只出现一次的字符</h4>
<p>题目描述: 请实现一个函数用来找出字符流中第一个只出现一次的字符。<br>
例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。<br>
当从该字符流中读出前六个字符”google”时，第一个只出现一次的字符是’l’。<br>
如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<pre><code>样例
输入：&quot;google&quot;
输出：&quot;ggg#ll&quot;
解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。
</code></pre>
<p>思路：创建一个队列存放单独元素，创建一个hash存放每个元素出现的次数。如果发现次数大于一，那么就进行判断是否是队头元素，是队头元素的就pop掉直到队头元素次数为1。</p>
<pre><code class="language-c++">class Solution{
public:

    unordered_map &lt;char, int&gt; hash;
    queue&lt;int&gt; q;
    
    //Insert one char from stringstream
    void insert(char ch){
        if (++ hash[ch] &gt; 1){
            while (q.size() &amp;&amp; hash[q.front()] &gt; 1) q.pop();
        }
        else q.push(ch);
    }
    //return the first appearence once char in current stringstream
    char firstAppearingOnce(){
        if (q.empty()) return '#';
        else return q.front();
    }
};
</code></pre>
<h4 id="66-两个链表的第一个公共结点">66. 两个链表的第一个公共结点</h4>
<p>之前做过这道题，Leetcode链表那节。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *findFirstCommonNode(ListNode *headA, ListNode *headB) {
        auto p = headA, q = headB;
        while (p != q){
            if (p) p = p-&gt;next;
            else p = headB;
            if (q) q = q-&gt;next;
            else q = headA;
        }
        return p;
    }
};
</code></pre>
<h4 id="67-数字在排序数组中出现的次数">67. 数字在排序数组中出现的次数</h4>
<p>题目描述：统计一个数字在排序数组中出现的次数。<br>
例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。</p>
<pre><code>样例
输入：[1, 2, 3, 3, 3, 3, 4, 5] ,  3
输出：4
</code></pre>
<p>思路：第一次看到准备用字典统计次数，然后输出即可。但是谁又能想到用两次二分呢。</p>
<pre><code class="language-c++">class Solution {
public:
    int getNumberOfK(vector&lt;int&gt;&amp; nums , int k) {
        if (nums.empty()) return 0;
        int l = 0, r = nums.size() - 1;
        while (l &lt; r){
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= k) r= mid;
            else l = mid + 1;
        }
        if (nums[l] != k) return 0;
        int start = l;
        l = 0, r = nums.size() - 1;
        while (l &lt; r){
            int mid = l + r + 1 &gt;&gt; 1;
            if (nums[mid] &lt;= k) l = mid;
            else r = mid - 1;
        }
        int end = r;
        return end - start + 1;
    }
};
</code></pre>
<pre><code class="language-python">class Solution {
public:
    int getNumberOfK(vector&lt;int&gt;&amp; nums , int k) {
        unordered_map&lt;int, int&gt; hash;
        for (auto x : nums) hash[x] ++;
        return hash[k];
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week4（1道不会做）]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week4</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week4">
        </link>
        <updated>2019-11-04T02:27:34.000Z</updated>
        <content type="html"><![CDATA[<h4 id="46-二叉搜索树的后序遍历序列">46. 二叉搜索树的后序遍历序列</h4>
<p>题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。<br>
如果是则返回true，否则返回false。<br>
假设输入的数组的任意两个数字都互不相同。</p>
<pre><code>样例
输入：[4, 8, 6, 12, 16, 14, 10]
输出：true
</code></pre>
<p>思路：后序遍历的顺序是左右根，所以输入的最后一位肯定是根节点，然后输入的前面一部分小于根节点，是左子树；后面一部分大于跟节点，是右子树。先找到这个分界点，然后看后面这部分是否满足要求&gt;root，然后对左子树和右子树进行迭代即可。</p>
<pre><code class="language-c++">class Solution {
public:
    bool verifySequenceOfBST(vector&lt;int&gt; sequence) {
        if (sequence.empty()) return true;
        int l = 0, r = sequence.size() - 1;
        return dfs(sequence, l, r);
    }
    
    bool dfs(vector&lt;int&gt; &amp;sequence, int l, int r){
        if (l &gt;= r) return true;
        auto root = sequence[r];
        int k = 0;
        while (k &lt; r &amp;&amp; sequence[k] &lt; root) k++;
        for (int i = k; i &lt; r; i ++){
            if (sequence[i] &lt; root) return false;
        }
        return dfs(sequence, l, k - 1) &amp;&amp; dfs(sequence, k, r - 1);
    }
};
</code></pre>
<h4 id="47-二叉树中和为某一值的路径">47. 二叉树中和为某一值的路径</h4>
<p>题目描述：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>
从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<pre><code>样例
给出二叉树如下所示，并给出num=22。
      5
     / \
    4   6
   /   / \
  12  13  6
 /  \    / \
9    1  5   1
输出：[[5,4,12,1],[5,6,6,5]]
</code></pre>
<p>思路：遍历一棵树，不同的是遍历的时候加了一些限制条件，需要找到一个从根节点开始到叶节点的路径，需要记录这个路径。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;

    vector&lt;vector&lt;int&gt;&gt; findPath(TreeNode* root, int sum) {
        dfs(root, sum);
        return ans;
    }
    
    void dfs(TreeNode* root, int sum){
        if (! root) return;
        path.push_back(root-&gt;val);
        sum -= root-&gt;val;
        if (! root-&gt;left &amp;&amp; ! root-&gt;right &amp;&amp; !sum) ans.push_back(path);
        dfs(root-&gt;left, sum);
        dfs(root-&gt;right, sum);
        path.pop_back();
        sum += root-&gt;val;
    }
};
</code></pre>
<h4 id="48-复杂链表的复刻leecode138">48. 复杂链表的复刻（Leecode138）</h4>
<p>题目描述：请实现一个函数可以复制一个复杂链表。<br>
在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者null。<br>
注意：<br>
函数结束后原链表要与输入时保持一致。<br>
思路：题意就是让我们把一个复杂链表复制再返回，因为有额外指针的关系，我们可以这样来做：<br>
<img src="https://tudouvvv.github.io//post-images/1572873769602.png" alt=""><br>
首先每个节点可以在后面复制一个它，再接到下一个节点上，本来可能是1-&gt;2-&gt;3，现在变成了1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3，假如1.random = 3，那么现在，1.next.random = 1.random.next，之后再把下面这些多加的节点拿出来就好了。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list with a random pointer.
 * struct ListNode {
 *     int val;
 *     ListNode *next, *random;
 *     ListNode(int x) : val(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *copyRandomList(ListNode *head) {
        for (auto p = head; p;){
            auto np = new ListNode(p-&gt;val);
            auto next = p-&gt;next;
            p-&gt;next = np;
            np-&gt;next= next;
            p = next;
        }
        
        for (auto p = head; p; p = p-&gt;next-&gt;next){
            if (p-&gt;random) p-&gt;next-&gt;random = p-&gt;random-&gt;next;
        }
        auto dummy = new ListNode(-1);
        auto cur = dummy;
        for (auto p = head; p; p = p-&gt;next){
            cur-&gt;next = p-&gt;next;
            cur = cur-&gt;next;
            p -&gt; next = p-&gt;next-&gt;next;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<h4 id="49-二叉搜索树与双向链表">49. 二叉搜索树与双向链表</h4>
<p>题目描述: 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>
要求不能创建任何新的结点，只能调整树中结点指针的指向。<br>
注意：<br>
需要返回双向链表最左侧的节点。<br>
例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。<br>
<img src="https://tudouvvv.github.io//post-images/1572919419174.png" alt=""><br>
思路:</p>
<ol>
<li>二叉搜索树的中序遍历就是双向链表的顺序，唯一不同的是，在中序遍历的时候需要把当前节点的左指针指向前一个点，前一个点的右指针指向当前点。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* convert(TreeNode* root) {
        stack&lt;TreeNode*&gt; q;
        if (! root || (! root-&gt;left &amp;&amp; ! root-&gt;right)) return root;
        auto dummy = new TreeNode(0);
        auto head = dummy;
        while (root || q.size()){
            if (root) q.push(root), root = root-&gt;left;
            else{
                root = q.top();
                q.pop();
                auto cur = root;
                cur-&gt;left = dummy;
                dummy-&gt;right = cur;
                dummy = cur;
                root = root-&gt;right;
            }
        }
        head-&gt;right-&gt;left = NULL;
        return head-&gt;right;
    }
};
</code></pre>
<ol start="2">
<li>也可以通过递归的方式，设定一个pair，它存的是当前节点的子树的最左边的点和最右边的点，左子树需要把左子树的pair.second-&gt;right = root，root-&gt;left = pair.second，右子树同理。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* convert(TreeNode* root) {
        if (! root) return NULL;
        auto sides = dfs(root);
        return sides.first;
    }
    
    pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode * root){
        if (!root-&gt;left &amp;&amp; !root-&gt;right) return {root, root};
        if (root-&gt;left &amp;&amp; root-&gt;right){
            auto lside = dfs(root-&gt;left), rside = dfs(root-&gt;right);
            lside.second-&gt;right = root, root-&gt;left = lside.second;
            rside.first-&gt;left = root, root-&gt;right = rside.first;
            return {lside.first, rside.second};
        }
        if (root-&gt;left){
            auto lside = dfs(root-&gt;left);
            lside.second-&gt;right = root, root-&gt;left = lside.second;
            return {lside.first, root};
        }
        if (root-&gt;right){
            auto rside = dfs(root-&gt;right);
            rside.first-&gt;left = root, root-&gt;right = rside.first;
            return {root, rside.second};
        }
        
    }
};
</code></pre>
<h4 id="50-序列化二叉树">50. 序列化二叉树</h4>
<p>题目描述：请实现两个函数，分别用来序列化和反序列化二叉树。<br>
您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。</p>
<pre><code>样例
你可以序列化如下的二叉树
    8
   / \
  12  2
     / \
    6   4

为：&quot;[8, 12, 2, null, null, 6, 4, null, null, null, null]&quot;
</code></pre>
<p>思路：</p>
<ol>
<li>序列化按照中序遍历的顺序，从根开始，遇见空的就添加'#,'，否则就添加'root.val' + ','。<br>
比较困难的是反序列化的步骤，需要判断各种情况：</li>
</ol>
<ul>
<li>遇见了'#'，那么返回NULL，向后跳两个字符 u += 2；</li>
<li>遇见了'-'，那么需要标记一下这是个负数，然后对字符进行恢复，比如从'123'恢复成123，在 c++ 中，可以这样: <code>int t = 0, t = t * 10 + str[i]</code>，最后在根据正负号确定节点的val</li>
<li>迭代</li>
</ul>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string res;
        dfs_1(root, res);
        return res;
    }
    
    void dfs_1(TreeNode* root, string &amp;res){
        if(!root) 
        {
            res += &quot;#,&quot;;
            return;
        }
        res += to_string(root-&gt;val) + ',';
        dfs_1(root-&gt;left, res);
        dfs_1(root-&gt;right, res);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs_2(data, u);
    }
    
    TreeNode* dfs_2(string data, int &amp;u){
        if (data[u] == '#'){
            u += 2;
            return NULL;
        }
        int t = 0;
        bool is_minus = false;
        if (data[u] == '-'){
             u ++;
             is_minus = true;
        }
        while (data[u] != ','){
            t = t * 10 + data[u] - '0';
            u ++;
        }
        u ++;
        if (is_minus) t = -t;
        auto root = new TreeNode(t);
        root-&gt;left = dfs_2(data, u);
        root-&gt;right = dfs_2(data, u);
        return root;
    } 
};
</code></pre>
<ol start="2">
<li>使用python来写的话，可以用split函数把节点值都给分开。</li>
</ol>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:

    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        &quot;&quot;&quot;
        if not root:
            return 'None';
        return str(root.val) + ',' +  self.serialize(root.left) + ',' + self.serialize(root.right);
        

    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        &quot;&quot;&quot;
        self.i = -1
        data = data.split(',')
        return self.dfs(data);
        
    def dfs(self, data):
        if self.i &gt;= len(data): 
            return
        self.i += 1
        root = None
        if data[self.i] != 'None':
            root = TreeNode(int(data[self.i]))
            root.left = self.dfs(data)
            root.right = self.dfs(data)
        return root       
</code></pre>
<h4 id="51-数字排列">51. 数字排列</h4>
<p>题目描述：输入一组数字（可能包含重复数字），输出其所有的排列方式。</p>
<pre><code>样例
输入：[1,2,3]
输出：
      [
        [1,2,3],
        [1,3,2],
        [2,1,3],
        [2,3,1],
        [3,1,2],
        [3,2,1]
      ]
</code></pre>
<pre><code class="language-c++">class Solution {
public:

    int n ;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    vector&lt;bool&gt; st;
    
    vector&lt;vector&lt;int&gt;&gt; permutation(vector&lt;int&gt;&amp; nums) {
        n = nums.size();
        path = vector&lt;int&gt;(n);
        st = vector&lt;bool&gt;(n);
        sort(nums.begin(), nums.end());
        dfs(nums, 0, 0);
        return ans;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int u, int start){
        if (u == n){
            ans.push_back(path);
            return ;
        }
        
        for (int i = start; i &lt; n; i ++){
            if (! st[i]){
                st[i] = true;
                path[i] = nums[u];
                dfs(nums, u + 1, nums[u] == nums[u + 1] ? i + 1 : 0);
                st[i] = false;
            }
        }
    }
};
</code></pre>
<h4 id="52-数组中出现次数超过一半的数字">52. 数组中出现次数超过一半的数字</h4>
<p>题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>
假设数组非空，并且一定存在满足条件的数字。<br>
思考题：<br>
假设要求只能使用 O(n) 的时间和额外 O(1) 的空间，该怎么做呢？</p>
<pre><code>样例
输入：[1,2,1,1,3]
输出：1
</code></pre>
<p>思路：</p>
<ol>
<li>开心消消乐：首先取第一个元素为标记元素，记录次数n = 1，然后和后面的元素进行比较，一样的时候，次数加一，不一样的时候次数减一，当次数为0的时候，换标记元素为当前元素，记录次数n归一，继续，因为题目中告诉我们一定存在这样一个数字超过一半，所以这样消消乐下来，剩下的一定就是我们想要的。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int moreThanHalfNum_Solution(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return NULL;
        if (nums.size() == 1) return nums[0];
        
        int res = nums[0];
        int n = 1;
        for (int i = 1; i &lt; nums.size(); i ++){
            if (nums[i] == res) n ++;
            else n --;
            if (n == 0){
                res = nums[i];
                n = 1;
            }
        }
        return res;
    }
};
</code></pre>
<ol start="2">
<li>排序然后输出中间元素就是的，但是这样时间复杂度就不满足要求了。</li>
</ol>
<h4 id="53-最小的k个数">53. 最小的k个数</h4>
<p>题目描述:输入n个整数，找出其中最小的k个数。<br>
注意：<br>
数据保证k一定小于等于输入数组的长度;<br>
输出数组内元素请按从小到大顺序排序;</p>
<pre><code>样例
输入：[1,2,3,4,5,6,7,8] , k=4
输出：[1,2,3,4]
</code></pre>
<p>思路：创建一个大根堆，遍历输入元素，push进堆里，如果发现堆里元素超过了k，那么就pop掉，这样就能保证堆内元素一定是最小的k个。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; getLeastNumbers_Solution(vector&lt;int&gt; input, int k) {
        priority_queue&lt;int&gt; heap;
        for (auto c : input){
            heap.push(c);
            if (heap.size() &gt; k) heap.pop();
        }
        
        vector&lt;int&gt; res;
        while (heap.size()){
            res.push_back(heap.top());
            heap.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
</code></pre>
<h4 id="54-数据流中的中位数">54. 数据流中的中位数</h4>
<p>题目描述：如何得到一个数据流中的中位数？<br>
如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>
如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<pre><code>样例
输入：1, 2, 3, 4
输出：1,1.5,2,2.5
解释：每当数据流读入一个数据，就进行一次判断并输出当前的中位数。
</code></pre>
<p>思路: 构建一个对顶堆，上面是一个小根堆，存的是比较大的数，下面是一个大根堆，存的是比较小的数，保证小根堆最多只比大根堆多一个数，这样两个堆的top处存的就是中间的两个数，然后再判断奇偶就可以了。</p>
<pre><code class="language-c++">class Solution {
public:

    priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;
    priority_queue &lt;int&gt; down;
    
    void insert(int num){
        if (down.empty() || num &gt; down.top()) up.push(num);
        else{
            down.push(num);
            up.push(down.top());
            down.pop();
        }
        if (up.size() &gt; down.size() + 1){
            down.push(up.top());
            up.pop();
        }
    }

    double getMedian(){
        if ((down.size() + up.size()) % 2 == 1) return up.top();
        else return (down.top() + up.top()) / 2.;
    }
};
</code></pre>
<h4 id="55-连续子数组的最大和">55. 连续子数组的最大和</h4>
<p>题目描述：输入一个 非空 整型数组，数组里的数可能为正，也可能为负。<br>
数组中一个或连续的多个整数组成一个子数组。<br>
求所有子数组的和的最大值。<br>
要求时间复杂度为O(n)。</p>
<pre><code>样例
输入：[1, -2, 3, 10, -4, 7, 2, -5]
输出：18
</code></pre>
<p>思路：</p>
<ol>
<li>只有前面的和对我是有益的（大于0），我才会去加它，否则就抛弃前面的所有数字。遍历整个数组，如果前面的数字大于0，那么就加上，相当于求一个前缀和，但是不同的是只看是否大于0，这样整个数组中最大的元素就是连续子数组的最大和；</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans = INT_MIN;
        for (int i = 1; i &lt; nums.size(); i ++){
            if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1];
        }
        for (auto x : nums){
            ans = max(ans, x);
        }
        return ans;
    }
};
</code></pre>
<ol start="2">
<li>设定一个s表示前面n - 1位数字的和，每次加元素之前判断一下s是否大于0，如果小于0，那么归零s，从现在开始重新加。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int s = 0, ans = INT_MIN;
        for (auto x : nums){
            if (s &lt; 0) s = 0;
            s += x;
            ans = max(ans, s);
        }
        return ans;
    }
};
</code></pre>
<h4 id="56-从1到n整数中1出现的次数">56. 从1到n整数中1出现的次数</h4>
<p>题目描述：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。<br>
例如输入12，从1到12这些整数中包含“1”的数字有1，10，11和12，其中“1”一共出现了5次。</p>
<pre><code>样例
输入： 12
输出： 5
</code></pre>
<p>思路:</p>
<ol>
<li>暴力搜索(❌)TLE了</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int numberOf1Between1AndN_Solution(int n) {
        if (n == 1) return 1;
        int cnt = 0;
        for (int i = 1; i &lt;= n; i ++){
            auto tmp = to_string(i);
            for (auto x : tmp){
                if (x == '1') cnt ++;
            }
        }
        return cnt;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week3]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week3</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week3">
        </link>
        <updated>2019-10-31T08:34:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="35-反转链表">35. 反转链表</h4>
<p>题目描述：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<pre><code>样例
输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>思路:之前做过这道题，每次反转两个，然后向后移一位，指导翻转完所有的，这个时候让尾部指向NULL, 即head -&gt; next = NULL, 然后设定新的头结点。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (! head) return head;
        auto a = head, b = head -&gt; next;
        while (b){
            auto c = b -&gt; next;
            b -&gt; next = a;
            a = b, b = c;
        }
        head -&gt; next = NULL;
        head = a;
        return head;
    }
};
</code></pre>
<h4 id="36-合并两个排序的链表">36. 合并两个排序的链表</h4>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<pre><code>样例
输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5
输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5
</code></pre>
<p>思路: 设定一个新的空结点，每次l1和l2比较完，就在后面接上小的，最后比完后有可能两个链表还有一个不为空，把它接在后面即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* merge(ListNode* l1, ListNode* l2) {
        auto dummy = new ListNode(-1);
        auto cur = dummy;
        while (l1 != NULL &amp;&amp; l2 != NULL){
            if (l1-&gt;val &lt; l2-&gt;val){
                cur -&gt; next = l1;
                l1 = l1 -&gt; next;
            }
            else {
                cur -&gt; next = l2;
                l2 = l2 -&gt; next;
            }
            cur = cur -&gt; next;
        }
        if (l1 == NULL) cur -&gt; next = l2;
        else cur -&gt; next = l1;
        return dummy -&gt; next;
    }  
};
</code></pre>
<h4 id="37-树的子结构">37. 树的子结构</h4>
<p>题目描述: 输入两棵二叉树A，B，判断B是不是A的子结构。<br>
我们规定空树不是任何树的子结构。</p>
<pre><code>样例
树A：

     8
    / \
   8   7
  / \
 9   2
    / \
   4   7
树B：

   8
  / \
 9   2
返回 true ,因为B是A的子结构。
</code></pre>
<p>思路：通过递归的方式来做，首先看根节点，不行就看左子树或者右子树；判断的时候要判断左右是否都能匹配。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if (! pRoot1 || ! pRoot2) return false;
        if (isPart(pRoot1, pRoot2)) return true;
        return hasSubtree(pRoot1-&gt;left, pRoot2) || hasSubtree(pRoot1-&gt;right, pRoot2);
    }
    
    bool isPart(TreeNode* p, TreeNode* q){
        if (! q) return true;
        if (! p || p-&gt;val != q-&gt;val) return false;
        return isPart(p-&gt;left, q-&gt;left) &amp;&amp; isPart(p-&gt;right, q-&gt;right);
    }
};
</code></pre>
<h4 id="38-二叉树的镜像">38. 二叉树的镜像</h4>
<p>输入一个二叉树，将它变换为它的镜像。</p>
<pre><code>样例
输入树：
      8
     / \
    6  10
   / \ / \
  5  7 9 11

 [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] 
输出树：
      8
     / \
    10  6
   / \ / \
  11 9 7  5

 [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]
</code></pre>
<p>思路：镜像就是从上往下，交换左右节点即可。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void mirror(TreeNode* root) {
        if  (! root) return ;
        swap(root-&gt;left, root-&gt;right);
        mirror(root-&gt;left);
        mirror(root-&gt;right);
    }
};
</code></pre>
<h4 id="39-对称的二叉树">39. 对称的二叉树</h4>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。<br>
如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<pre><code>样例
如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：
    1
   / \
  2   2
 / \ / \
3  4 4  3

如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：
    1
   / \
  2   2
   \ / \
   4 4  3
</code></pre>
<p>思路：之前做过这道题，关于树的题，一般都是通过递归的方式，不断地深入直到叶节点为止。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (! root) return true;
        return dfs(root-&gt;left, root-&gt;right);
    }
    
    bool dfs(TreeNode* p, TreeNode* q){
        if (!p || !q) return !p &amp;&amp; !q;
        if (p-&gt;val != q-&gt;val) return false;
        return dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);
    }
};
</code></pre>
<h4 id="40-顺时针打印矩阵">40. 顺时针打印矩阵</h4>
<p>题目描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<pre><code>样例
输入：
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]

输出：[1,2,3,4,8,12,11,10,9,5,6,7]
</code></pre>
<p>思路：定义一个顺时针的方向，然后就开始移动，每次出界或者是遇到了之前遇到的数字就换一个方向。换方向可以通过(d + 1) % 4来实现，因为只有四个方向hh.</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) {
        vector&lt;int&gt; res;
        
        if (matrix.empty() || matrix[0].empty()) return res;
        int n = matrix.size(), m = matrix[0].size();
        vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m));
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y = 0, d = 1;
        for (int k = 0; k &lt; n * m; k ++){
            res.push_back(matrix[x][y]);
            st[x][y] = true;
            
            int a = x + dx[d], b = y + dy[d];
            if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b]){
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};
</code></pre>
<h4 id="41-包含min函数的栈">41. 包含min函数的栈</h4>
<p>题目描述：设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p>
<p>push(x)–将元素x插入栈中<br>
pop()–移除栈顶元素<br>
top()–得到栈顶元素<br>
getMin()–得到栈中最小元素</p>
<pre><code>样例
MinStack minStack = new MinStack();
minStack.push(-1);
minStack.push(3);
minStack.push(-4);
minStack.getMin();   --&gt; Returns -4.
minStack.pop();
minStack.top();      --&gt; Returns 3.
minStack.getMin();   --&gt; Returns -1.
</code></pre>
<p>思路：之前做过这道题，可以另开一个新栈存储最小值，第一个表示第一个数的最小的，第二个表示前两个数的最小值...</p>
<pre><code class="language-c++">class MinStack {
public:

    stack&lt;int&gt; stk, min_stk;
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        stk.push(x);
        if (min_stk.empty()) min_stk.push(x);
        else min_stk.push(min(x, min_stk.top()));
    }
    
    void pop() {
        stk.pop();
        min_stk.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return min_stk.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
</code></pre>
<h4 id="42-栈的压入-弹出序列">42. 栈的压入、弹出序列</h4>
<p>题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。<br>
假设压入栈的所有数字均不相等。<br>
例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>
注意：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。</p>
<pre><code>样例
输入：[1,2,3,4,5]
      [4,5,3,2,1]

输出：true
</code></pre>
<p>思路：由于输入输出都已经给了，所以只需要进行判断就可以了，开一个栈，每次压入元素，然后判断与输出的头元素是不是相同，相同的就pop，然后输出向后移一位在判断，不同的话就再压。如果输出的序列是正确的，那么栈最后应该为空，否则就是不正确的。</p>
<pre><code class="language-c++">class Solution {
public:
    bool isPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) {
        if (pushV.size() != popV.size()) return false;
        stack&lt;int&gt; stk;
        int i = 0;
        for (auto x : pushV){
            stk.push(x);
            while (stk.size() &amp;&amp; stk.top() == popV[i]){
                stk.pop();
                i ++;
            }
        } 
        return stk.empty();
    }
};
</code></pre>
<h4 id="43-不分行从上往下打印二叉树">43. 不分行从上往下打印二叉树</h4>
<p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>
<pre><code>样例
输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]
    8
   / \
  12  2
     /
    6
   /
  4
输出：[8, 12, 2, 6, 4]
</code></pre>
<p>思路：先把根节点的值放进一个队列中，然后把它的值更新到res中，然后pop掉，顺便把它的左右儿子也push进队列中，遍历整个树。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; printFromTopToBottom(TreeNode* root) {
        vector&lt;int&gt; res;
        queue&lt;TreeNode*&gt; q;
        if (! root) return res;
        q.push(root);
        while (q.size()){
            auto t = q.front();
            q.pop();
            res.push_back(t-&gt;val);
            if (t-&gt;left) q.push(t-&gt;left);
            if (t -&gt;right) q.push(t-&gt;right);
        }
        return res;
    }
};
</code></pre>
<h4 id="44-分行从上往下打印二叉树">44. 分行从上往下打印二叉树</h4>
<p>题目描述：从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p>
<pre><code>样例
输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]
    8
   / \
  12  2
     /
    6
   /
  4

输出：[[8], [12, 2], [6], [4]]
</code></pre>
<p>思路：相比较上一题，这道题就需要去遍历每一层的元素放进level，然后再push进最终的答案.</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(q.size()){
            vector&lt;int&gt; level;
            int t = q.size();
            for (int i = 0; i &lt; t; i++){
                auto k = q.front();
                q.pop();
                level.push_back(k-&gt;val);
                if (k-&gt;left) q.push(k-&gt;left);
                if (k-&gt;right) q.push(k-&gt;right);
            }
            res.push_back(level);
        }
        return res;
    }
};
</code></pre>
<h4 id="45-之字形打印二叉树">45. 之字形打印二叉树</h4>
<p>题目描述：请实现一个函数按照之字形顺序从上向下打印二叉树。<br>
即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<pre><code>样例
输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]
    8
   / \
  12  2
     / \
    6   4
输出：[[8], [2, 12], [6, 4]]
</code></pre>
<p>思路：改了一下上一道代码，最后添加一行判断的语句，因为只需要把偶数行的输出翻转就可以了。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(q.size()){
            vector&lt;int&gt; level;
            int t = q.size();
            for (int i = 0; i &lt; t; i++){
                auto k = q.front();
                q.pop();
                level.push_back(k-&gt;val);
                if (k-&gt;left) q.push(k-&gt;left);
                if (k-&gt;right) q.push(k-&gt;right);
            }
            res.push_back(level);
        }
        int len = res.size();
        for (int i = 0; i &lt; len; i ++){
            if (i % 2 == 1) reverse(res[i].begin(), res[i].end());
        }
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week2(2道题不会做)]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day2</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day2">
        </link>
        <updated>2019-10-29T03:04:52.000Z</updated>
        <content type="html"><![CDATA[<h4 id="24-机器人的运动范围">24. 机器人的运动范围</h4>
<p>题目描述: 地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。<br>
一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。<br>
但是不能进入行坐标和列坐标的数位之和大于 k 的格子。<br>
请问该机器人能够达到多少个格子？</p>
<pre><code>样例
输入：k=18, m=40, n=40
输出：1484
解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。
      但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
</code></pre>
<p>注意:</p>
<ul>
<li>0&lt;=m&lt;=50</li>
<li>0&lt;=n&lt;=50</li>
<li>0&lt;=k&lt;=100<br>
分析：去枚举每个格子，要记得只能从合法格子进入非法格子，不能从非法格子进入合法格子。</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        if (! rows || ! cols) return 0;
        int count = 1;
        // 表示格子状态
        int st[rows][cols] = {0};
        st[0][0] = 1;
        for (int i = 0; i &lt; rows; i ++)
            for (int j = 0; j &lt; cols; j ++)
            {
                int p = i / 10 + i % 10 + j / 10 + j % 10;
                // 只能从左边或者上边进入
                if (p &lt;= threshold &amp;&amp; (st[i - 1][j] == 1 || st[i][j - 1] == 1))
                {
                    count ++;
                    st[i][j] = 1;
                }
            }
        return count;
    }
};
</code></pre>
<p>也可以通过宽搜的方式来进行遍历：</p>
<pre><code class="language-c++">class Solution {
public:

    int get_single(int x){
        int s  = x / 10 + x % 10;
        return s;
    }
    
    int get_sum(pair&lt;int, int&gt; p){
        return get_single(p.first) + get_single(p.second);
    }
    
    int movingCount(int threshold, int rows, int cols)
    {
        if (! rows || ! cols) return 0;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols));
        int res = 0;
        q.push({0, 0});
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        
        while (q.size()){
            auto t = q.front();
            q.pop();
            if (get_sum(t) &gt; threshold || st[t.first][t.second]) continue;
            res ++;
            st[t.first][t.second] = true;
            for (int i = 0; i &lt; 4; i++)
            {
                int x = t.first + dx[i], y = t.second + dy[i];
                if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols) q.push({x, y});
            }
        }
        return res;
    }
};
</code></pre>
<h4 id="25-剪绳子">25. 剪绳子</h4>
<p>题目描述：给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。<br>
每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？<br>
例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
<pre><code>样例
输入：8
输出：18
</code></pre>
<p>思路：尽可能分更多的3的绳子，if n &gt;= 5, 那么3 * (n - 3) = 3n - 9 &gt; n.</p>
<pre><code class="language-c++">class Solution {
public:
    int maxProductAfterCutting(int n) {
        if (n &lt;= 3) return 1 * (n - 1);
        int res = 1;
        if (n % 3 == 1)
        {
            res *= 4;
            n -= 4;
        }
        if (n % 3 == 2)
        {
            res *= 2;
            n -= 2;
        }
        while (n)
        {
            res *= 3;
            n -= 3;
        }
        return res;
    }
};
</code></pre>
<h4 id="26-二进制中1的个数">26. 二进制中1的个数</h4>
<p>题目描述：输入一个32位整数，输出该数二进制表示中1的个数。<br>
注意：<br>
负数在计算机中用其绝对值的补码来表示。</p>
<p>ps.什么叫补码呢？这得从原码，反码说起。<br>
原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。<br>
比如 00000000 00000000 00000000 00000101 是 5的 原码。<br>
反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。<br>
取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）</p>
<pre><code>样例1
输入：9
输出：2
解释：9的二进制表示是1001，一共有2个1。
样例2
输入：-2
输出：31
解释：-2在计算机里会被表示成11111111111111111111111111111110，
      一共有31个1。
</code></pre>
<p>思路：每次与 1 &amp;，就相当于看看二进制末尾是不是1，然后右移一位，但是有个问题就是正数右移会在前面补0是ok的，但是负数会在前面补1，这样就会多算好多，所以可以把负数变为无符号整数，如果是正数不会变，如果是负数，那么会变为绝对值的反码，但是依然表示为正数，这样就可以了。</p>
<pre><code class="language-c++">class Solution {
public:
    int NumberOf1(int n) {
        int res = 0;
        unsigned int un = n;
        while (un){
            res += un &amp; 1, un &gt;&gt;= 1;
        }
        return res;
    }
};
</code></pre>
<p>并且由于题目中说了这是一个32位的整数，所以也可以一位一位的进行判断：</p>
<pre><code class="language-c++">class Solution {
public:
    int NumberOf1(int n) {
        int res = 0;
        for (int i = 32; i &gt; 0; i --){
            res += n &gt;&gt; i &amp; 1;
        }
        return res;
    }
};
</code></pre>
<h4 id="27-数值的整数次方">27. 数值的整数次方</h4>
<p>题目描述: 实现函数double Power(double base, int exponent)，求base的 exponent次方。<br>
不得使用库函数，同时不需要考虑大数问题。<br>
注意：<br>
不会出现底数和指数同为0的情况</p>
<pre><code>样例1
输入：10 ，2
输出：100

样例2
输入：10 ，-2  
输出：0.01
</code></pre>
<p>思路：就正常相乘就可以了，判断一下指数的正负，&lt; 0 的话翻一下就好了。</p>
<pre><code class="language-c++">class Solution {
public:
    double Power(double base, int exponent) {
        if (exponent == 0) return 1;
        if (exponent &gt; 0) return help(base, exponent);
        else return 1 / help(base, -exponent);
    }
    
    double help(double base, int exponent){
        int k = base;
        while (-- exponent){
            base *= k;
        }
        return base;
    }
};
</code></pre>
<p>也可以不用这么麻烦：</p>
<pre><code class="language-c++">class Solution {
public:
    double Power(double base, int exponent) {
        double res = 1;
        bool minus = false;
        if (exponent &lt; 0) minus = true, exponent = -exponent;
        while (exponent --){
            res *= base;
        }
        if (minus) return 1 / res;
        return res;
    }
};
</code></pre>
<p>update: 快速幂<br>
比如我们要求 a ^ b，加入b = 13, 那么二进制表示就是1101，即8 + 4 + 1, 所以a ^ b = a ^ 8 * a ^ 4 * a ^ 1, 这就表明当b的二进制位是1的时候，我们可以乘以a ^ 2 ^ 位数。<br>
所以这道题也可以这样做：</p>
<pre><code class="language-c++">class Solution {
public:
    double Power(double base, int exponent) {
        double res = 1, t = base;
        bool is_minus = false;
        if (exponent &lt; 0) is_minus = true, exponent = -exponent;
        while (exponent &gt; 0){
            if (exponent &amp; 1) res *= t;
            t *= t;
            exponent &gt;&gt;= 1;
        }
        if (is_minus) return 1 / res;
        return res;
    }
};
</code></pre>
<p>快速幂模板：<br>
求 m^k%p ，时间复杂度 O(logk)。</p>
<pre><code class="language-c++">int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&amp;1) res = res * t % p;
        t = t * t % p;
        k &gt;&gt;= 1;
    }
    return res;
}
</code></pre>
<h4 id="28-在o1时间删除链表结点">28. 在O(1)时间删除链表结点</h4>
<p>题目描述：给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。<br>
假设链表一定存在，并且该节点一定不是尾节点。<br>
思路：之前做过这道题，因为不知道它之前的节点，所以可以把它后面的节点赋值给它，然后删掉它后面的点，曲线救国。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    }
};
</code></pre>
<h4 id="29-删除链表中重复的节点">29. 删除链表中重复的节点</h4>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。</p>
<pre><code>样例1
输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出：1-&gt;2-&gt;5

样例2
输入：1-&gt;1-&gt;1-&gt;2-&gt;3
输出：2-&gt;3
</code></pre>
<p>思路：值得注意的重复的节点不会保留，所以头结点是会变的，需要创建虚拟头结点。需要两个指针，p指向一段末尾，q指向一段的开头，如果发现q的这一段长度大于一，那么q移动到另一段的开头，p直接指向q就可以删掉这一段。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplication(ListNode* head) {
        auto dummy = new ListNode(-1);
        dummy-&gt;next = head;
        
        auto p = dummy;
        while (p-&gt;next){
            auto q = p-&gt;next;
            while (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;
            if (p-&gt;next-&gt;next == q) p = p-&gt;next;
            else p-&gt;next = q;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<h4 id="30-正则表达式匹配">30. 正则表达式匹配</h4>
<p>题目描述：请实现一个函数用来匹配包括'.'和'<em>'的正则表达式。<br>
模式中的字符'.'表示任意一个字符，而'</em>'表示它前面的字符可以出现任意次（含0次）。<br>
在本题中，匹配是指字符串的所有字符匹配整个模式。<br>
例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</p>
<pre><code>样例
输入：
s=&quot;aa&quot;
p=&quot;a*&quot;

输出:true
</code></pre>
<h4 id="32-调整数组顺序使奇数位于偶数前面">32. 调整数组顺序使奇数位于偶数前面</h4>
<p>题目描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序。<br>
使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<pre><code>样例
输入：[1,2,3,4,5]
输出: [1,3,5,2,4]
</code></pre>
<p>思路：返回的顺序只要奇数在前，偶数在后面，不需要内部有序。设定两个指针，第一个l之前全是奇数，第二个r后面全是偶数，每次l++，r--，这样每次交换两个指针位置的数字即可。</p>
<pre><code class="language-c++">class Solution {
public:
    void reOrderArray(vector&lt;int&gt; &amp;array) {
        int l = 0, r = array.size();
        while (l &lt; r){
            while (l &lt; r &amp;&amp; array[l] % 2 == 1) l ++;
            while (l &lt; r &amp;&amp; array[r] % 2 == 0) r --;
            if (l &lt; r){
                int tmp = array[l];
                array[l] = array[r], array[r] = tmp;
            }
        }
    }
};
</code></pre>
<pre><code class="language-python">class Solution(object):
    def reOrderArray(self, array):
        l, r = 0, len(array) - 1
        while (l &lt; r):
            while (l &lt; r and array[l] % 2 == 1): l += 1
            while (l &lt; r and array[r] % 2 == 0): r -= 1
            if (l &lt; r):
                array[l], array[r] = array[r], array[l]
</code></pre>
<h4 id="33-链表中倒数第k个节点">33. 链表中倒数第k个节点</h4>
<p>题目描述: 输入一个链表，输出该链表中倒数第k个结点。<br>
注意：<br>
k &gt;= 0;<br>
如果k大于链表长度，则返回 NULL;</p>
<pre><code>样例
输入：链表：1-&gt;2-&gt;3-&gt;4-&gt;5 ，k=2
输出：4
</code></pre>
<p>思路：倒数第k个就是正数第n - k个，所以先遍历一遍找出链表的长度，然后再遍历一遍，找到第n-k个返回即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* findKthToTail(ListNode* head, int k) {
        auto p = head;
        int n = 0;
        for (auto t = head; t; t = t-&gt;next) n++;
        if (k &gt; n) return NULL;
        for (int i = 0; i &lt; n - k; i ++) p = p-&gt;next;
        return p;
    }
};
</code></pre>
<p>Update:<br>
也可以用双指针算法来做</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* findKthToTail(ListNode* head, int k) {
        auto p = head, q = head;
        int n = 0;
        for (auto q = head; q; q = q-&gt;next) n ++;
        if (k &gt; n) return NULL;
        while (k --) p = p-&gt;next;
        while (p){
            p = p -&gt; next;
            q = q-&gt;next;
        }
        return q;
    }
};
</code></pre>
<h4 id="34-链表中环的入口结点">34. 链表中环的入口结点</h4>
<p>题目描述：给定一个链表，若其中包含环，则输出环的入口节点。<br>
若其中不包含环，则输出null。<br>
思路：之前做过这道题，LC链表专题。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *entryNodeOfLoop(ListNode *head) {
        auto fast = head, slow = head;
        while (fast)
        {
            fast = fast -&gt; next;
            slow = slow -&gt; next;
            if (fast) fast = fast -&gt; next;
            else break;
            
            if (fast == slow){
                slow = head;
                while (slow != fast)
                {
                    slow = slow -&gt; next;
                    fast = fast -&gt; next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week1]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day1</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day1">
        </link>
        <updated>2019-10-25T00:54:07.000Z</updated>
        <content type="html"><![CDATA[<h4 id="13-找出数组中重复的数字">13. 找出数组中重复的数字</h4>
<p>给定一个长度为 n 的整数数组 nums，数组中所有的数字都在 0∼n−1 的范围内。<br>
数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。<br>
请找出数组中任意一个重复的数字。<br>
注意：如果某些数字不在 0∼n−1 的范围内，或数组中不包含重复数字，则返回 -1；</p>
<pre><code>样例
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。
返回 2 或 3。
</code></pre>
<p>思路：刚开始看到这道题就想用字典来做，用字典存储每个数字出现的次数，然后&gt;1的话返回即可。</p>
<pre><code class="language-c++">class Solution {
public:
    unordered_map&lt;int, int&gt; hash;
    int duplicateInArray(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return -1;
        for (auto num : nums)
        {   
            if (num &gt; 0 || num &lt; nums.size() - 1)
                hash[num] ++;
            else return -1;
        }
        int t = 0;
        for (int i = 0; i &lt; nums.size(); i ++)
        {
            t = max(t, hash[nums[i]]);
            if (t &gt; 1) return nums[i];
        }
        if (t == 1) return -1;
    }
};
</code></pre>
<p>一个更妙的解题方法：因为一共有n个数，n个坑，所以可以把每个数放在属于自己的位置上，如果出现两个相同的数字，那么返回即可。</p>
<pre><code class="language-c++">class Solution {
public:
    int duplicateInArray(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        for (auto num : nums) 
        {
            if (num &lt; 0 || num &gt; n - 1) return -1;
        }
        for (int i = 0; i &lt; n; i ++)
        {
            while (i != nums[i] &amp;&amp; nums[nums[i]] != nums[i]) swap(nums[i], nums[nums[i]]);
            if (i != nums[i] &amp;&amp; nums[i] == nums[nums[i]]) return nums[i];
        }
        return -1;
    }
};
</code></pre>
<p>update:</p>
<pre><code class="language-python">class Solution(object):
    def duplicateInArray(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype int
        &quot;&quot;&quot;
        n = len(nums)
        for x in nums:
            if (x &lt; 0 or x &gt; n - 1): return -1
        i = 0
        for i in range(n):
            while (i != nums[i] and nums[nums[i]] != nums[i]):
                x, y = nums[i], nums[nums[i]]
                nums[nums[i]], nums[i] = x, y
            if (i != nums[i] and nums[i] == nums[nums[i]]):
                return nums[i]
        return -1
</code></pre>
<h4 id="14-不修改数组找出重复的数字">14. 不修改数组找出重复的数字</h4>
<p>给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。<br>
请找出数组中任意一个重复的数，但不能修改输入的数组。</p>
<pre><code>样例
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。
返回 2 或 3。
</code></pre>
<p>思考题：如果只能使用 O(1) 的额外空间，该怎么做呢？<br>
思路：之前做过这道题，用二分即可。</p>
<pre><code class="language-c++">class Solution {
public:
    int duplicateInArray(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return -1;
        int n = nums.size();
        int l = 1, r = n - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            int cnt = 0;
            for (auto num : nums)
            {
                if (num &gt;= l &amp;&amp; num &lt;= mid) cnt ++;
            }
            if (cnt &gt; mid - l + 1) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<p>update:</p>
<pre><code class="language-python">class Solution(object):
    def duplicateInArray(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype int
        &quot;&quot;&quot;
        if not nums: return -1;
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1;
            cnt = 0
            for num in nums:
                if (num &gt;= l and num &lt;= mid): cnt += 1
            if (cnt &gt; mid - l + 1): r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="15-二维数组中的查找">15. 二维数组中的查找</h4>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>样例
输入数组：
[
  [1,2,8,9]，
  [2,4,9,12]，
  [4,7,10,13]，
  [6,8,11,15]
]
</code></pre>
<p>如果输入查找数值为7，则返回true，<br>
如果输入查找数值为5，则返回false。<br>
思路:刚开始看到这道题以为和<a href="https://leetcode.com/problems/search-a-2d-matrix/">LeetCode74</a>一模一样，用二分写了，后来发现不一样hh。<br>
一个很妙的方法：每次都用右上角(左下角)的点进行比较，因为这个点的左边一行比它小，下边一列比它大，所以如果大于它，那么可以去掉一行，小于它可以去掉一列，直到找到答案。</p>
<pre><code class="language-c++">class Solution {
public:
    bool searchArray(vector&lt;vector&lt;int&gt;&gt; array, int target) {
        if (array.empty() || array[0].empty()) return false;
        int i = 0, j = array[0].size() - 1;
        while (i &lt; array.size() &amp;&amp; j &gt;= 0)
        {
            if (array[i][j] == target) return true;
            if (array[i][j] &gt; target) j --;
            else i ++;
        }
        return false;
    }
};
</code></pre>
<p>update:</p>
<pre><code class="language-c++">class Solution(object):
    def searchArray(self, array, target):
        &quot;&quot;&quot;
        :type array: List[List[int]]
        :type target: int
        :rtype: bool
        &quot;&quot;&quot;
        if (len(array) == 0 or len(array[0]) == 0): return False
        n = len(array)
        m = len(array[0])
        i, j = 0, m - 1;
        while i &lt; n and j &gt;=0:
            if array[i][j] == target: return True
            if array[i][j] &gt; target: j -= 1
            else: i += 1
        return False
</code></pre>
<h4 id="16-替换空格">16. 替换空格</h4>
<p>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。<br>
你可以假定输入字符串的长度最大是1000。<br>
注意输出字符串的长度可能大于1000。</p>
<pre><code>样例
输入：&quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;
</code></pre>
<p>思路：可以设定一个新的字符串，每次遇见空格就加'%20'，其它的就加上即可。</p>
<pre><code class="language-c++">class Solution {
public:
    string replaceSpaces(string &amp;str) {
        string res;
        for (auto c : str)
        {
            if (c == ' ') res += &quot;%20&quot;;
            else res += c;
        }
        return res;
    }
};
</code></pre>
<p>也可以首先计算出替换空格后的字符串长度，然后扩充原来的字符串，用两个指针直接在原字符串上进行修改。</p>
<pre><code class="language-c++">class Solution {
public:
    string replaceSpaces(string &amp;str) {
        int len = 0;
        for (auto c : str)
        {
            if (c == ' ') len += 3;
            else len += 1;
        }
        int i = str.size() - 1, j = len - 1;
        str.resize(len);
        while (i &gt;= 0)
        {
            if (str[i] == ' ')
            {
                str[j --] = '0';
                str[j --] = '2';
                str[j --] = '%';
            }
            else str[j --] = str[i];
            i --;
        }
        return str;
    }
};
</code></pre>
<p>当然用python来写肯定更简单</p>
<pre><code class="language-python">class Solution(object):
    def replaceSpaces(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        res = s.split(' ')
        return '%20'.join(res)
</code></pre>
<h4 id="17-从尾到头打印链表">17. 从尾到头打印链表</h4>
<p>题目描述:输入一个链表的头结点，按照<code>从尾到头</code>的顺序返回节点的值。<br>
返回的结果用数组存储。</p>
<pre><code>样例
输入：[2, 3, 5]
返回：[5, 3, 2]
</code></pre>
<p>思路：首先反转链表，最后遍历一次，把每个节点的值放进列表中即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; printListReversingly(ListNode* head) {
        if (! head) return {};
        vector&lt;int&gt; res;
        auto a = head, b = head -&gt;next;
        while (b)
        {
            auto c = b-&gt;next;
            b -&gt; next = a;
            a = b;
            b = c;
        }
        head -&gt; next = NULL;
        head = a;
        for (auto p = head; p; p = p-&gt;next) res.push_back(p-&gt;val);
        return res;
    }
};
</code></pre>
<p>也可以不用翻转列表，直接先得到正常顺序的节点值列表，然后翻转这个列表即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; printListReversingly(ListNode* head) {
        vector &lt;int&gt; res;
        for (auto p = head; p; p = p-&gt;next) res.push_back(p-&gt;val);
        reverse(res.begin(), res.end());
        return res;
    }
};
</code></pre>
<h4 id="18-重建二叉树">18. 重建二叉树</h4>
<p>题目描述：输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。<br>
注意:<br>
二叉树中每个节点的值都互不相同；<br>
输入的前序遍历和中序遍历一定合法；</p>
<pre><code>样例
给定：
前序遍历是：[3, 9, 20, 15, 7]
中序遍历是：[9, 3, 15, 20, 7]
返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]
返回的二叉树如下所示：
    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>思路：之前做过这道题，因为前序遍历的第一个数字肯定是根节点，然后在中序遍历中找到这个数，那么它的左边就是左子树，右边就是右子树，然后不断递归即可。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map &lt;int, int&gt; pos;
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        int n = preorder.size();
        for (int i = 0; i &lt; n; i ++) pos[inorder[i]] = i;
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);
    }
    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir)
    {
        if (pl &gt; pr) return NULL;
        int val = preorder[pl];
        int k = pos[val];
        int len = k - il;
        auto root = new TreeNode(val);
        root-&gt;left = dfs(preorder, inorder, pl + 1, pl + len, il, k - 1);
        root-&gt;right = dfs(preorder, inorder, pl + len + 1, pr, k + 1, ir);
        return root;
    }
};
</code></pre>
<h4 id="19-二叉树的下一个节点">19. 二叉树的下一个节点</h4>
<p>题目描述：给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。<br>
注意：<br>
如果给定的节点是中序遍历序列的最后一个，则返回空节点;<br>
二叉树一定不为空，且给定的节点一定不是空节点；</p>
<pre><code>样例
假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。
则应返回值等于3的节点。
解释：该二叉树的结构如下，2的后继节点是3。
  2
 / \
1   3
</code></pre>
<p>思路：树的后继：当前节点在中序遍历中的下一个节点，即整颗二叉搜索树中比我大的最小的元素。<br>
要分情况讨论<br>
<img src="https://tudouvvv.github.io//post-images/1572309512253.png" alt=""></p>
<ol>
<li>如图，如果当前节点有右儿子，那么右子树最左侧的节点就是当前节点的后继，比如F的后继就是H；</li>
<li>如果没有的话，就要去寻找它的父节点的，如果当前节点是它父节点的左子树，那么它的父节点就是后继,比如H的后继就是E，否则，就一直向上寻找，比如D，它是它父节点的右子树，那么就继续向上找，直到找到是左子树的父节点，它的父节点是C，C是父节点F的左子树，所以F就是D的后继。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* p) {
        if (p-&gt;right)
        {
            p = p-&gt;right;
            while (p-&gt;left) p = p-&gt;left;
            return p;
        }
        while (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father;
        return p-&gt;father;
    }
};
</code></pre>
<h4 id="20-用两个栈实现队列">20. 用两个栈实现队列</h4>
<p>题目描述: 请用栈实现一个队列，支持如下四种操作：<br>
push(x) – 将元素x插到队尾；<br>
pop() – 将队首的元素弹出，并返回该元素；<br>
peek() – 返回队首元素；<br>
empty() – 返回队列是否为空；<br>
注意：<br>
你只能使用栈的标准操作：push to top，peek/pop from top, size 和 is empty；<br>
如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；<br>
输入数据保证合法，例如，在队列为空时，不会进行pop或者peek等操作；<br>
思路：用两个栈来做，当需要pop的时候可以把原始栈内元素push进cache栈中，然后pop就是队首元素，然后再恢复，peek操作也一样。</p>
<pre><code class="language-c++">class MyQueue {
public:
    stack&lt;int&gt; stk, help;
    /** Initialize your data structure here. */
    MyQueue() {
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stk.push(x);
    }
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        while (! stk.empty())
        {
            int k = stk.top();
            help.push(k);
            stk.pop();
        }
        int t = help.top();
        help.pop();
        while (! help.empty())
        {
            int k = help.top();
            stk.push(k);
            help.pop();
        }
        return t;
    }
    
    /** Get the front element. */
    int peek() {
        while (! stk.empty())
        {
            int k = stk.top();
            help.push(k);
            stk.pop();
        }
        int t = help.top();
        while (! help.empty())
        {
            int k = help.top();
            stk.push(k);
            help.pop();
        }
        return t;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return stk.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * bool param_4 = obj.empty();
 */
</code></pre>
<p>可以写一个函数，来进行两个栈内元素互换的操作。</p>
<pre><code class="language-c++">class MyQueue {
public:
    /** Initialize your data structure here. */
    stack&lt;int&gt; stk, cache;
    MyQueue() {
        
    }
    
    void copy(stack&lt;int&gt; &amp;a, stack&lt;int&gt; &amp;b){
        while (a.size()){
            b.push(a.top());
            a.pop();
        }
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stk.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        copy(stk, cache);
        int val = cache.top();
        cache.pop();
        copy(cache, stk);
        return val;
    }
    
    /** Get the front element. */
    int peek() {
        copy(stk, cache);
        int val = cache.top();
        copy(cache, stk);
        return val;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return stk.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * bool param_4 = obj.empty();
 */
</code></pre>
<h4 id="21-斐波那契数列">21. 斐波那契数列</h4>
<p>题目描述：输入一个整数 n ，求斐波那契数列的第 n 项。<br>
假定从0开始，第0项为0。(n&lt;=39)</p>
<pre><code>样例
输入整数 n=5 
返回 5
</code></pre>
<p>思路：设定一个初始值全为1，大小为n的vector，有几个特殊情况需要判断一下，如果n = 0，返回0， 如果n = 1 或者 n = 2，返回1，然后就用迭代方法计算即可，其实也可以用一个滚动数组来节省空间。</p>
<pre><code class="language-c++">class Solution {
public:
    int Fibonacci(int n) {
        vector&lt;int&gt; res(n, 1);
        if (n == 0) return 0;
        if (n == 1 || n == 2) return 1;
        for (int i = 2; i &lt; n; i ++)
        {
            res[i] = res[i - 1] + res[i - 2];
        }
        return res[n - 1];
    }
};
</code></pre>
<p>滚动数组：</p>
<pre><code class="language-c++">class Solution {
public:
    int Fibonacci(int n) {
        int a = 0, b = 1;
        while (n --)
        {
            int c = a + b;
            a = b, b = c;
        }
        return a;
    }
};
</code></pre>
<p>ps.<a href="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法</a></p>
<h4 id="22-旋转数组的最小数字">22. 旋转数组的最小数字</h4>
<p>题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>
输入一个升序的数组的一个旋转，输出旋转数组的最小元素。<br>
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>
数组可能包含重复项。<br>
注意：数组内所含元素非负，若数组大小为0，请返回-1。</p>
<pre><code>样例
输入：nums=[2,2,2,0,1]
输出：0
</code></pre>
<p>思路:之前做过这道题，唯一不同的是，这道题中有重复元素，所以如果用二分做的话，需要先把后面的重复元素删掉，保证二分的性质。</p>
<pre><code class="language-c++">class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return -1;
        int l = 0, r = nums.size() - 1;
        while (nums[r] == nums[0]) r--;
        if (nums[r] &gt; nums[0]) return nums[0];
        int k = r;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt; nums[k]) r = mid;
            else l = mid + 1;
        }
        return nums[l];
    }
};
</code></pre>
<h4 id="23-矩阵中的路径">23. 矩阵中的路径</h4>
<p>题目描述: 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>
路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。<br>
如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。</p>
<pre><code>注意：
输入的路径不为空；
所有出现的字符均为大写英文字母；
</code></pre>
<p>思路: 之前做过这道题但是都忘记了... 就是先枚举起点，然后在上下左右的去寻找后面的单词。</p>
<pre><code class="language-c++">class Solution {
public:
    bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str) {
        if (matrix.empty() || matrix[0].empty()) return false;
        int n = matrix.size(), m = matrix[0].size();
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; m; j++)
                if (dfs(matrix, str, i, j, 0))
                    return true;
        return false;
    }
    
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string &amp; str, int x, int y, int u){
        if (matrix[x][y] != str[u]) return false;
        if (u == str.size() - 1) return true;
        char t = matrix[x][y];
        matrix[x][y] = '*';
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        for (int i = 0; i &lt; 4; i ++)
        {
            int a = x + dx[i], b = y + dy[i];
            if (a &gt;= 0 &amp;&amp; a &lt; matrix.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; matrix[0].size())
            {
                if (dfs(matrix, str, a, b, u + 1)) return true;
            }
        }
        matrix[x][y] = t;
        return false;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[做作的日常①]]></title>
        <id>https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang</id>
        <link href="https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang">
        </link>
        <updated>2019-10-07T12:45:12.000Z</updated>
        <content type="html"><![CDATA[<p>十一就要结束了呀！！！<br>
时间呀时间，你慢点撒！</p>
<ol>
<li>求斐波那契数列的前1000个数（当时连斐波那契数列是啥都不知道hh）<br>
斐波那契数列是这样一个数列：1, 1, 2, 3, 5, 8, ..., ...<br>
即f(1) = 1, f(2) = 1, f(n) = f(n - 1) + f(n - 2)这样一个递推关系式<br>
可以开一个1000个空间的数组，也可以用while循环来做，但是没啥区别，都是要通过迭代的方式来进行。<br>
Python</li>
</ol>
<pre><code class="language-python">class Solution:
    def Fibonacci_sequence(self, nums):
        f = [0 for _ in range(nums)]
        if nums == 1:
            return [1]
        if nums == 2:
            return [1, 1]
        f[0], f[1] = 1, 1
        for i in range(2, nums):
            f[i] = f[i - 1] + f[i - 2]
        return f
</code></pre>
<ol start="2">
<li>求前1000个质数<br>
质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。<br>
可以写一个函数来判断一个数是不是质数，然后主函数用一个while循环进行判断，直到有1000个数，而且判断的时候只需要从2到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>即可。<br>
Python</li>
</ol>
<pre><code class="language-python">class Solution:
    def Prime(self, nums):
        f = [2]
        if nums == 1:
            return f
        i = 3
        while len(f) &lt; nums:
            if self.is_prime(i): f.append(i)
            i += 1
        return f

    def is_prime(self, n):
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第八周(动态规划专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第八周(动态规划专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第八周(动态规划专题)">
        </link>
        <updated>2019-09-27T09:32:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="53-maximum-subarray"><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></h4>
<p>题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<pre><code>示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre>
<p>分析：</p>
<ol>
<li>要计算连续的最大和，其实就是要看加了某个数之后的和与该数的大小，如果变小了那就没必要了，所以每次进行判断，如果前面的数&gt;0，那么就加上它，这样遍历一遍，整个数组中最大的值就是我们要找的答案。<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans = INT_MIN;
        for(int i = 1; i &lt; nums.size(); i ++)
        {
            if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1];
        }
        for (auto num : nums)  ans = max(ans, num);
        return ans;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        for i in range(1, len(nums)):
            if nums[i - 1] &gt; 0:
                nums[i] += nums[i - 1]
        return max(nums)
</code></pre>
<ol start="2">
<li>动态规划<br>
从集合的角度来考虑DP问题，最重要的就是要求出状态转移方程是什么样子的，对每个nums[i]来说，它的连续子数组的和共有以下情况:</li>
</ol>
<ul>
<li>nums[1] + nums[2] + ... + nums[i]</li>
<li>nums[2] + nums[3] + ... + nums[i]</li>
<li>...</li>
<li>0 + nums[i]<br>
我们去掉nums[i]来找这些情况中的最大和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> ，这些情况中的最大和就等于nums[i - 1]情况下的最大和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以状态转移方程就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f(x) = max(0,  f(x-1)) + nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int res= INT_MIN, last = 0;
        for (int i = 0; i &lt; nums.size(); i ++)
        {
            int now = max(0, last) + nums[i];
            res = max(res, now);
            last = now;
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        res = -float('inf')
        last = 0
        for i in range(len(nums)):
            now = max(0, last) + nums[i]
            res = max(res, now)
            last = now
        return res
</code></pre>
<h4 id="120-triangle"><a href="https://leetcode.com/problems/triangle/">120. Triangle</a></h4>
<p>题目描述：给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<pre><code>例如，给定三角形：
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
</code></pre>
<p>分析：首先记录第一行的数字res = triangle[0][0]，初始时i = 0，然后从第二行开始，res += min(char[i], char[i + 1])，这是它相邻的两个位置，记录min_char的index，然后替换i，继续枚举。<br>
Python❌</p>
<pre><code class="language-python">class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        if not list: return 0
        res = triangle[0][0]
        i = 0
        for char in triangle[1:]:
            min_char = min(char[i], char[i + 1])
            res += min_char
            i = char.index(min_char)
        return res
</code></pre>
<p>但是不知道为什么有个案例过不了<code>[[-1],[2,3],[1,-1,-3]]</code>，讲道理不是应该-1 + 2 + -1 = 0 嘛，不知道为什么答案是-1。<br>
✅ps.我明白了，这并不是一个贪心算法的过程，而是要看全局，所以正确的路径应该是-1 + 3 + -3 = -1。<br>
所以这也是一道用dp解决的问题：<br>
<img src="https://tudouvvv.github.io//post-images/1569826922552.png" alt=""><br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(n));
        f[0][0] = nums[0][0];
        for(int i = 1; i &lt; n; i ++)
            for(int j = 0; j &lt;= i; j ++)
            {
                f[i][j] = INT_MAX;
                if (j &gt; 0) f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j]);
                if (j &lt; i) f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j]);
            }
        long long res = INT_MAX;
        for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1][i]);
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def minimumTotal(self, nums: List[List[int]]) -&gt; int:
        n = len(nums)
        f = [[0 for _ in range(n)] for _ in range(n)]
        f[0][0] = nums[0][0]
        for i in range(1, n):
            for j in range(i + 1):
                f[i][j] = float('inf')
                if j &gt; 0: f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j])
                if j &lt; i: f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j])
        res = float('inf')
        for i in range(n):
            res = min(res, f[n - 1][i])
        return res
</code></pre>
<p>因为我们最后只需要最后一行的数据进行判断，并且每行的结果只依赖于上一行的结果，所以完全不需要开n行数组，只需要开两行，然后滚动就行，这就是滚动数组：</p>
<pre><code class="language-c++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;long long&gt;&gt; f(2, vector&lt;long long&gt;(n));
        f[0][0] = nums[0][0];
        for(int i = 1; i &lt; n; i ++)
            for(int j = 0; j &lt;= i; j ++)
            {
                f[i &amp; 1][j] = INT_MAX;
                if (j &gt; 0) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j - 1] + nums[i][j]);
                if (j &lt; i) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j] + nums[i][j]);
            }
        long long res = INT_MAX;
        for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1 &amp; 1][i]);
        return res;
    }
};
</code></pre>
<h4 id="63-unique-paths-ii"><a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a></h4>
<p>题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>
<img src="https://tudouvvv.github.io//post-images/1569829741021.png" alt=""><br>
网格中的障碍物和空位置分别用 1 和 0 来表示。<br>
说明：m 和 n 的值均不超过 100。</p>
<pre><code>示例:
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</code></pre>
<p>分析：<img src="https://tudouvvv.github.io//post-images/1569830381210.png" alt=""><br>
对于状态计算来说，分为两种情况：</p>
<ol>
<li>最后一步从上往下走: f[i][j] += f[i - 1][j]</li>
<li>最后一步从左往右走: f[i][j] += f[i][j - 1]<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; g) {
        int n = g.size(), m = g[0].size();
        vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(m));
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; m; j ++)
            {
                if (g[i][j]) continue;
                if (!i &amp;&amp; !j) f[i][j] = 1;
                if (i &gt; 0) f[i][j] += f[i - 1][j];
                if (j &gt; 0) f[i][j] += f[i][j - 1];
            }
        return f[n - 1][m - 1];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int:
        n = len(g)
        m = len(g[0])
        f = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if g[i][j]: continue;
                if i == 0 and j == 0: f[i][j] = 1
                if (i &gt; 0): f[i][j] += f[i - 1][j]
                if (j &gt; 0): f[i][j] += f[i][j - 1]
        return f[n - 1][m - 1]
</code></pre>
<h4 id="91-decode-ways"><a href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a></h4>
<p>题目描述：一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>
'A' -&gt; 1<br>
'B' -&gt; 2<br>
...<br>
'Z' -&gt; 26<br>
给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<pre><code>示例:
输入: &quot;226&quot;
输出: 3
解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。
</code></pre>
<p>分析：还是用DP的思路来解决：<br>
<img src="https://tudouvvv.github.io//post-images/1569833953551.png" alt=""><br>
首先状态表示，f[i]表示所有由前i个数字解码得到的字符串的个数，然后是状态计算，共有两种情况:最后一个字母是一个数字f[i - 1]，最后一个字母是两个数字f[i - 2]，特别还是要考虑边界条件。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector&lt;int&gt; f(n + 1);
        f[0] = 1;
        for (int i = 1; i &lt;= n; i ++)
        {
            if (s[i - 1] != '0') f[i] += f[i - 1];
            if (i &gt;= 2)
            {
                int t = (s[i - 2] - '0') * 10 + s[i - 1] - '0';
                if (t &gt;= 10 and t &lt;= 26) f[i] += f[i - 2];
            }
        }
        return f[n];    
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        n = len(s)
        f = [0 for _ in range(n + 1)]
        f[0] = 1
        
        for i in range(1, n + 1):
            if s[i - 1] != '0': f[i] += f[i - 1]
            if i &gt; 1:
                t = int(s[i - 2]) * 10 + int(s[i - 1])
                if 10 &lt;= t &lt;=26:
                    f[i] += f[i - 2]
        return f[n]
</code></pre>
<h4 id="198-house-robber"><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></h4>
<p>题目描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<pre><code>示例:
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</code></pre>
<p>分析：我把奇数的加一起，偶数的加一起，max一下不就可以了嘛</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        res1 = 0
        res2 = 0
        for i in range(len(nums)):
            if i % 2 == 0:
                res1 += nums[i]
            else:
                res2 += nums[i]
        return max(res1, res2)
</code></pre>
<p>好吧，少考虑了情况，如果是[2, 1, 1, 2]的话就不需要隔一个偷一个了。<br>
考虑用DP来做，用两个数组分别表示状态：<br>
<img src="https://tudouvvv.github.io//post-images/1570085349472.png" alt=""><br>
那么在进行状态计算的时候，f[i]因为表示不取nums[i]的最大值，所以就等于nums[i-1]的最大值，所以f[i] = max(f[i - 1], g[i - 1])<br>
g[i]表示选了nums[i]的最大值，既然选了nums[i]，那么肯定没有选nums[i - 1]，于是g[i] = f[i - 1] + nums[i]。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; f(n + 1), g(n + 1);
        
        for (int i = 1; i &lt;=n; i ++ )
        {
            f[i] = max(f[i - 1], g[i - 1]);
            g[i] = f[i - 1] + nums[i - 1];
        }
        
        return max(f[n], g[n]);
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [0 for _ in range(n + 1)]
        g = [0 for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            f[i] = max(f[i - 1], g[i - 1])
            g[i] = f[i - 1] + nums[i - 1]
            
        return max(f[n], g[n])
</code></pre>
<h4 id="300-longest-increasing-subsequence"><a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></h4>
<p>题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<pre><code>示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
</code></pre>
<p>Note:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。<br>
分析：用DP来解决，首先状态表示f[i]：表示以第i个数结尾的上升子序列的最大值；然后是状态更新，我们要遍历从0到i的所有数，如果nums[j] &lt; nums[i]， 就说明它可i以被放进去，那么f[i] = max(f[i], f[j] + 1)，最后再遍历f，找出最大值即可。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; f(n, 1);
        
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; i; j ++)
                if (nums[j] &lt; nums[i])
                {
                    f[i] = max(f[i], f[j] + 1);
                }
        
        int res = 0;
        for (int i = 0; i &lt; n; i ++) res = max(res, f[i]);
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [1 for _ in range(n)]
        
        for i in range(n):
            for j in range(i):
                if nums[j] &lt; nums[i]:
                    f[i] = max(f[i], f[j] + 1)
        
        res = 0
        for i in range(n): res = max(res, f[i])
        return res
</code></pre>
<h4 id="72-edit-distance"><a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a></h4>
<p>题目描述：给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>
你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<pre><code>示例:
输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出: 3
解释: 
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')
</code></pre>
<p>分析：首先集合表示：f[i, j]表示将第一个字符串的前i个字母，变成第二个字符串的前j个字母的方案的最小值，那么在进行状态计算时，我们考虑最后一步的情况，由于它共有三种操作方式，所以最后一步的情况如下：</p>
<ol>
<li>插入：我在第一个字符串中插入一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i个字符和第二个字符串的前j - 1个字符相同，所以f[i, j] = f[i, j - 1] + 1</li>
<li>删除：我在第一个字符串中删除一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i - 1个字符和第二个字符串的前j的字符相同，所以f[i, j] = f[i - 1, j] + 1</li>
<li>替换：替换又分为两种情况：1）第一个字符串的第i个字符和第二个字符串的第j个字符是相同的，不需要替换了，所以f[i, j] = f[i - 1, j - 1]; 2）第一个字符串的第i个字符和第二个字符串的第j个字符是不同的，需要替换一下，所以f[i, j] = f[i - 1, j - 1] + 1;<br>
最后只需要在上面四种方案中求一个最小值代表状态即可。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));
        for (int i = 0; i &lt;= n; i ++) f[i][0] = i;
        for (int i = 0; i &lt;= m; i ++) f[0][i] = i;
        for (int i = 1; i &lt;= n; i ++)
            for (int j = 1; j &lt;= m; j ++)
            {
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1;
                f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i -1] != word2[j - 1]));
            }
        
        return f[n][m];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        n, m = len(word1), len(word2)
        f = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
        for i in range(n + 1): f[i][0] = i
        for i in range(m + 1): f[0][i] = i
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1
                f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i - 1] != word2[j - 1]));
        return f[n][m]
</code></pre>
<h4 id="518-coin-change-2"><a href="https://leetcode.com/problems/coin-change-2/">518. Coin Change 2</a></h4>
<p>题目描述：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。<br>
Note:<br>
你可以假设：</p>
<ul>
<li>0 &lt;= amount (总金额) &lt;= 5000</li>
<li>1 &lt;= coin (硬币面额) &lt;= 5000</li>
<li>硬币种类不超过 500 种</li>
<li>结果符合 32 位符号整数</li>
</ul>
<pre><code>示例:
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre>
<p>分析：首先状态表示f[i,j]表示为用前i个硬币凑出总钱数为j的凑法的数量，那么在状态表示时，有很多种情况：</p>
<ol>
<li>用了0个第i个硬币，所以f[i, j] = f[i - 1, j];</li>
<li>用了t个第i个硬币，所以f[i, j] = f[i - 1, j - t * coins[i]];<br>
所以，f[i ,j] = f[i - 1, j] + f[i - 1, j - c] + f[i - 1, j - 2c] + ... + f[i - 1, j - kc]<br>
但是，f[i, j - c] = f[i - 1, j - c] + f[i - 1, j - 2c]  + ... + f[i - 1, j - kc]<br>
所以，我们可以用f[i, j - c]的状态替换掉后面一堆东西，于是f[i, j] = f[i - 1, j] + f[i, j - c]<br>
由于这里i只与上一层有关系，所以可以用滚动数组来求解，同时f[i - 1, j] 与 f[i , j]表示的j都是一样的，所以可以用一个一维的滚动数组来简化f[j] = f[j] + f[j - c]。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        int m = amount;
        vector&lt;int&gt; f(m + 1);
        f[0] = 1;
        for (auto c : coins)
            for (int j = c; j &lt;= m; j ++)
                f[j] += f[j - c];
        return f[m];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        m = amount
        f = [0 for _ in range(m + 1)]
        f[0] = 1
        for coin in coins:
            for j in range(coin, m + 1):
                f[j] += f[j - coin]
        return f[m]
</code></pre>
<h4 id="664-strange-printer"><a href="https://leetcode.com/problems/strange-printer/">664. Strange Printer</a></h4>
<p>题目描述：有台奇怪的打印机有以下两个特殊要求：<br>
打印机每次只能打印同一个字符序列。<br>
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。<br>
给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。</p>
<pre><code>示例:
输入: &quot;aba&quot;
输出: 2
解释: 首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 'a'。
</code></pre>
<p>分析：f[l][r]表示将[L, R]染成最终模样的方式的最小值：<br>
<img src="https://tudouvvv.github.io//post-images/1570433988785.png" alt=""><br>
首先是把端点染成想要的颜色，f[l][r] = f[l + 1][r] + 1<br>
然后另一种情况是染[l, k]，l和k处的颜色相同的话，f[l][r]= f[l][k - 1] + f[k + 1][r]<br>
最后求两者的最小值即可。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int strangePrinter(string s) {
        int n = s.size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1));
        if (s.empty()) return 0;
        for (int len = 1; len &lt;= n; len ++)
            for (int l = 0; l + len - 1 &lt; n; l ++)
            {
                int r = l + len - 1;
                f[l][r] = f[l + 1][r] + 1;
                for (int k = l + 1; k &lt;= r; k ++)
                    if (s[l] == s[k])
                        f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r]);
            }
        return f[0][n - 1];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def strangePrinter(self, s: str) -&gt; int:
        n = len(s)
        if n == 0: return 0
        f = [[0 for _ in range(n + 1)]for _ in range(n + 1)]
        for lens in range(1, n + 1):
            for l in range(0, n - lens + 1):
                r = l + lens - 1
                f[l][r] = f[l + 1][r] + 1
                for k in range(l + 1, r + 1):
                    if s[l] == s[k]:
                        f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r])
                        print(f)
        return f[0][n - 1]
</code></pre>
<h4 id="10-regular-expression-matching存疑">❌<a href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching</a>(存疑)</h4>
<p>题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p>
<pre><code>'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
</code></pre>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。<br>
Note:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li>
</ul>
<pre><code>示例:
输入:
s = &quot;aa&quot;
p = &quot;a*&quot;
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。
</code></pre>
<p>分析：考虑用DP来做，f[i][j]表示s的第i个字符与p的第j个字符是否匹配，我们现在已经得知了之前的状态，也就是f[i - 1][j - 1]，现在要考虑的就是s[i]与p[j]的关系：</p>
<ol>
<li>如果s[i] = p[j], 那么f[i][j] = f[i - 1][j - 1]</li>
<li>如果p[j] = '.', 那么f[i][j] = f[i - 1][j - 1]</li>
<li>如果p[j] = '*', 那么我们要考虑s[i] 与 p[j - 1]的关系：
<ol>
<li>如果s[i] != p[j - 1], 那么f[i][j] = f[i - 1][j - 2]，此时*表示匹配0个前面的字母</li>
<li>如果p[j - 1] = '.' || p[j - 1] = s[i]：</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
</feed>