<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tudouvvv.github.io/</id>
    <title>Tudouvvv</title>
    <updated>2019-08-26T12:03:05.863Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tudouvvv.github.io/"/>
    <link rel="self" href="https://tudouvvv.github.io//atom.xml"/>
    <subtitle>人生还长，慢慢来</subtitle>
    <logo>https://tudouvvv.github.io//images/avatar.png</logo>
    <icon>https://tudouvvv.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Tudouvvv</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第四周(字符串处理专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第四周(字符串处理专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第四周(字符串处理专题)">
        </link>
        <updated>2019-08-26T08:01:46.000Z</updated>
        <content type="html"><![CDATA[<h4 id="38-count-and-say"><a href="https://leetcode.com/problems/count-and-say/">38. Count and Say</a></h4>
<p>题目描述：报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
</code></pre>
<p>1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。<br>
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。<br>
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。<br>
给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。<br>
注意：整数顺序将表示为一个字符串。</p>
<p>分析：每一行生成的内容都是根据上一行的内容得来的，每次需要得到连续段的个数以及数值，转成字符串即可。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    string countAndSay(int n) {
        string s = &quot;1&quot;;
        for (int i = 0; i &lt; n -1; i++)
        {
            string ns;
            for (int j = 0; j &lt; s.size(); j++)
            {
                int k = j + 1;
                while (k &lt; s.size() &amp;&amp; s[k] == s[j]) k++;
                ns += to_string(k - j) + s[j];
                j = k - 1;
            }
            s = ns;
        }
        return s;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def countAndSay(self, n: int) -&gt; str:
        s = '1'
        for i in range(n-1):
            ns = &quot;&quot;
            j = 0
            while j &lt; len(s):
                k = j + 1
                while (k &lt; len(s) and s[j] == s[k]):
                    k += 1
                ns += str(k - j) + s[j]
                j = k - 1
                j += 1
            s = ns
        return s
</code></pre>
<h4 id="49-group-anagrams"><a href="https://leetcode.com/problems/group-anagrams/">49. Group Anagrams</a></h4>
<p>题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<pre><code>示例：
输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre>
<p>Note:</p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。<br>
分析：先把每个字符串排个序，构建一个字典，每个字符串是key，排好序的是value，这样就可以把相同的放在一起。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第三周(树专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第三周(树专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第三周(树专题)">
        </link>
        <updated>2019-07-30T03:56:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="98-validate-binary-search-tree"><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h4>
<p>题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树（BST）。<br>
假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<pre><code>示例：
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
根节点的值为 5 ，但是其右子节点值为 4 。
</code></pre>
<p>分析：<br>
<img src="https://tudouvvv.github.io//post-images/1564546182987.png" alt=""><br>
用递归的思想，自上往下的进行搜索判断。首先，假定根节点的值是x，它的范围是在[-∞,+∞]之间的，那么它的左子树的范围就是[-∞,x-1]之间的，假定左子树根节点的值为y，那么对它来说，它的左子树的范围是[-∞,y-1]，右子树的范围是在[y+1,x-1]。以此类推，不断判断，如果哪一个结点的值不在它所属的范围内，那么它就不是一颗BST。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
       return dfs(root, INT_MIN, INT_MAX);
    }
    
    bool dfs(TreeNode *root, long long minv, long long maxv)
    {
        if (!root) return true;
        if (root-&gt;val &lt; minv || root-&gt;val &gt; maxv)  return false;
        # 1ll的目的是为了防止溢出，因为val有可能是负无穷或正无穷
        return dfs(root-&gt;left, minv, root-&gt;val -1ll) &amp;&amp; dfs(root-&gt;right, root-&gt;val +1ll, maxv);
    }
};
</code></pre>
<p>Python</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        return self.dfs(root, -float('inf'), float('inf'))
    
    def dfs(self, root, minv, maxv):
        if not root:
            return True
        if root.val &lt; minv or root.val &gt; maxv:
            return False
        return self.dfs(root.left, minv, root.val-1) and self.dfs(root.right, root.val+1, maxv)
</code></pre>
<h4 id="94-binary-tree-inorder-traversal"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h4>
<p>题目描述：给定一个二叉树，返回它的中序遍历。</p>
<pre><code>示例：
输入: [1,null,2,3]
   1
    \
     2
    /
   3
输出: [1,3,2]
</code></pre>
<p>Note:</p>
<ul>
<li>进阶: 递归算法很简单，你可以通过迭代算法完成吗？<br>
分析：<br>
可以用栈来实现中序遍历，将整棵树的最左边一条链压入栈中，每次取出栈顶元素，如果它有右子树，则将右子树压入栈中。<br>
C++</li>
</ul>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; stk;
        auto p = root;
        while (p || stk.size())
        {
            while(p)
            {
                stk.push(p);
                p = p-&gt;left;
            }
            p = stk.top();
            stk.pop();
            res.push_back(p-&gt;val);
            p = p-&gt;right;
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res = []
        stk = []
        p = root
        while(p or len(stk)):
            while p:
                stk.append(p)
                p = p.left
            p = stk.pop()
            res.append(p.val)
            p = p.right
        return res
</code></pre>
<h4 id="101-symmetric-tree"><a href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a></h4>
<p>题目描述：给定一个二叉树，检查它是否是镜像对称的。</p>
<pre><code>示例：
    1
   / \
  2   2
 / \ / \
3  4 4  3
二叉树 [1,2,2,3,4,4,3] 是对称的。
</code></pre>
<p>Note:</p>
<ul>
<li>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。<br>
分析：</li>
<li>递归的方式</li>
</ul>
<ol>
<li>两个根节点的值要相等</li>
<li>左边的左子树与右边的右子树对称</li>
<li>左边的右子树与右边的左子树对称</li>
</ol>
<ul>
<li>迭代的方式</li>
</ul>
<ol>
<li>左边的树：左中右遍历</li>
<li>右边的树：右中左遍历</li>
<li>同时遍历，判断两边的值是否一样<br>
C++(递归的方式)</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return dfs(root-&gt;left, root-&gt;right);        
    }
    bool dfs(TreeNode* p, TreeNode* q){
        // 如果是空的，则必须同时为空才对称
        if (!p || !q) return !p &amp;&amp; !q;
        return p-&gt;val == q-&gt;val &amp;&amp; dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root: return True
        return self.dfs(root.left, root.right)
    def dfs(self, p, q):
        if (not p) or (not q): return (not p) and (not q)
        return p.val == q.val and self.dfs(p.left, q.right) and self.dfs(p.right, q.left)
</code></pre>
<p>C++(迭代的方式)</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        stack&lt;TreeNode*&gt; left, right;
        auto l = root-&gt;left, r = root-&gt;right;
        while (l || r || left.size() || right.size())
        {
            while (l &amp;&amp; r)
            {
                left.push(l), l = l-&gt;left;
                right.push(r), r = r-&gt;right;
            }
            if (l || r) return false;
            
            l = left.top(), left.pop();
            r = right.top(), right.pop();
            if (l-&gt;val != r-&gt;val) return false;
            l = l-&gt;right, r = r-&gt;left;
        }
        return true;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root: return True
        left, right = [], []
        l, r = root.left, root.right
        while (l or r or len(left) or len(right)):
            while (l and r):
                left.append(l)
                l = l.left
                right.append(r)
                r = r.right
            # 上面循环结束只有两种情况:全空或者一个空，一个不空
            # 一个空，一个不空肯定不对称，返回False
            if (l or r): return False
            l = left.pop()
            r = right.pop()
            if l.val != r.val: return False
            l = l.right
            r = r.left
        return True
</code></pre>
<h4 id="105-construct-binary-tree-from-preorder-and-inorder-traversal"><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h4>
<p>题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。<br>
Node:</p>
<ul>
<li>你可以假设树中没有重复的元素。</li>
</ul>
<pre><code>示例：
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>分析：</p>
<ol>
<li>前序遍历的第一个点肯定是根节点，在中序遍历中找到这个数，那么它左边的数就是左子树，右边的数就是右子树；</li>
<li>直到左子树的个数后，在前序遍历中就可以把左子树的前序遍历和右子树的前序遍历区分开来；</li>
<li>然后不断递归即可；</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map&lt;int, int&gt; pos;
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        int n = preorder.size();
        for (int i =0; i &lt; n; i++) pos[inorder[i]] = i;
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);
    }
    
    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir){
        if (pl &gt; pr) return NULL;
        int val = preorder[pl];
        int k = pos[val];
        int len = k - il;
        auto root = new TreeNode(val);
        root-&gt;left = dfs(preorder, inorder, pl+1, pl+len, il, k-1);
        root-&gt;right = dfs(preorder, inorder, pl+len+1, pr, k+1, ir);
        
        return root;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        pos = {}
        n = len(preorder)
        for i, char in enumerate(inorder):
            pos[char] = i
        return self.dfs(pos, preorder, inorder, 0, n-1, 0, n-1)
    
    def dfs(self, pos, preorder, inorder, pl, pr, il, ir):
        if pl &gt; pr: return None
        val = preorder[pl]
        k = pos[val]
        length = k - il
        root = TreeNode(val)
        root.left = self.dfs(pos, preorder, inorder, pl+1, pl+length, il, k-1)
        root.right = self.dfs(pos, preorder, inorder, pl+length+1, pr, k+1, ir)
        return root
</code></pre>
<h4 id="102-binary-tree-level-order-traversal"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h4>
<p>题目描述：给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<pre><code>示例:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
</code></pre>
<p>分析：一层一层地进行，设置一个队列，每次存储这层元素，最后再把每层的元素存储到一个二维数组中即可。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!root) return res;
        
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        
        while(q.size())
        {
            int len = q.size();
            vector&lt;int&gt; level;
            
            for(int i = 0; i &lt; len; i++)
            {
                auto t = q.front();
                q.pop();
                level.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.push_back(level);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        res = []
        q = []
        if not root: return res
        q.append(root)
        
        while(len(q)):
            length = len(q)
            level = []
            for i in range(length):
                t = q[0]
                del(q[0])
                level.append(t.val)
                if t.left: 
                    q.append(t.left)
                if t.right: 
                    q.append(t.right)
            res.append(level)
        return res
</code></pre>
<h4 id="236-lowest-common-ancestor-of-a-binary-tree"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h4>
<p>题目描述:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
Note:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<pre><code>示例：
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
</code></pre>
<p>分析：</p>
<ul>
<li>如果以root为根的子树中包含p和q，则返回它们的公共祖先</li>
<li>如果只包含p/q，那么只返回p/q</li>
<li>如果都不包含，则返回NULL</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;
        auto left = lowestCommonAncestor(root-&gt;left, p, q);
        auto right = lowestCommonAncestor(root-&gt;right, p, q);
        if (!left) return right;
        if (!right) return left;
        return root;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        if root == None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left: return right
        if not right: return left
        return root
</code></pre>
<h4 id="543-diameter-of-binary-tree"><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h4>
<p>题目描述：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p>
<pre><code>示例
给定二叉树
          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
</code></pre>
<p>Note</p>
<ul>
<li>两结点之间的路径长度是以它们之间边的数目表示。<br>
分析：递归时需要计算，从当前结点出发，求左右两边深度的最大值。<br>
C++</li>
</ul>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return ans;
    }
    int dfs(TreeNode* root){
        if (!root) return 0;
        auto left = dfs(root-&gt;left);
        auto right = dfs(root-&gt;right);
        ans = max(ans, left+right);
        return max(left+1, right+1);
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:
        self.ans = 0
        def dfs(root):
            if not root: return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.ans = max(self.ans, left+right)
            return max(left+1, right+1)
        dfs(root)
        return self.ans
</code></pre>
<h4 id="124-binary-tree-maximum-path-sum"><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></h4>
<p>题目描述：给定一个非空二叉树，返回其最大路径和。<br>
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<pre><code>示例
输入: [-10,9,20,null,null,15,7]
   -10
   / \
  9  20
    /  \
   15   7
输出: 42
</code></pre>
<p>分析：与上道题不同返回最长的边数不同，这道题有了权重，但与上题类似，先枚举最高点。<br>
每个点有三种情况：</p>
<ol>
<li>向左走，root.val+L</li>
<li>向右走，root.val+R</li>
<li>不走，root.val+0<br>
每次在这三种情况中取最大值。<br>
C++</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans;
    }
    // 返回从root向下走的最大值
    int dfs(TreeNode* root){
        if (!root) return 0;
        auto left = dfs(root-&gt;left);
        auto right = dfs(root-&gt;right);
        
        ans = max(ans, left+right+root-&gt;val);
        return max(0, root-&gt;val + max(0, max(left, right)));
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -&gt; int:
        self.ans = -float('inf')
        def dfs(root):
            if not root: return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.ans = max(self.ans, left+right+root.val)
            return max(0, root.val+max(0, left, right))
        dfs(root)
        return self.ans
</code></pre>
<h4 id="173-binary-search-tree-iterator"><a href="https://leetcode.com/problems/binary-search-tree-iterator/">173. Binary Search Tree Iterator</a></h4>
<p>题目描述：实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。<br>
调用 next() 将返回二叉搜索树中的下一个最小的数。<br>
Note:</p>
<ul>
<li>next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。</li>
<li>以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。<br>
<img src="https://tudouvvv.github.io//post-images/1566803022501.png" alt=""></li>
</ul>
<pre><code>示例：
BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false
</code></pre>
<p>分析：按照中序遍历的方法输出树中的每一个节点，<code>next</code>返回下一个值，<code>hasNext</code>返回是否存在下一个值，可以用栈的方式来进行，栈的空间大小与树的大小成正比。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator {
public:
    stack&lt;TreeNode*&gt; stk;
    BSTIterator(TreeNode* root) {
        while(root)
        {
            stk.push(root);
            root = root-&gt;left;
        }
    }
    
    /** @return the next smallest number */
    int next() {
        auto p = stk.top();
        stk.pop();
        int res = p-&gt;val;
        p = p-&gt;right;
        while (p)
        {
            stk.push(p);
            p = p-&gt;left;
        }
        return res;
    }
    
    /** @return whether we have a next smallest number */
    bool hasNext() {
        return ! stk.empty();
    }
};

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj-&gt;next();
 * bool param_2 = obj-&gt;hasNext();
 */
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stk = []
        while root:
            self.stk.append(root)
            root = root.left

    def next(self) -&gt; int:
        &quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;
        p = self.stk.pop()
        res = p.val
        p = p.right
        while p:
            self.stk.append(p)
            p = p.left
        return res

    def hasNext(self) -&gt; bool:
        &quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;
        return len(self.stk) &gt; 0


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
</code></pre>
<h4 id="297-serialize-and-deserialize-binary-tree"><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize and Deserialize Binary Tree</a>(存疑)</h4>
<p>题目描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<pre><code>示例：
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 &quot;[1,2,3,null,null,4,5]&quot;
</code></pre>
<p>Note:</p>
<ul>
<li>这与 LeetCode 目前使用的方式一致，你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</li>
<li>不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</li>
</ul>
<p>分析：采用前序遍历的方式，因为加上了空节点，所以可以用前序遍历的方式来构建一棵唯一二叉树。一般情况下，前序遍历并不能唯一确定一棵二叉树；前序遍历+中序遍历可以唯一确定一棵二叉树。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string res;
        dfs1(root, res);
        return res;
    }
    
    void dfs1(TreeNode* root, string &amp;res)
    {
        if (!root)
        {
            res += &quot;#,&quot;;
            return;
        }
        res += to_string(root-&gt;val) + ',';
        dfs1(root-&gt;left, res);
        dfs1(root-&gt;right, res);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs2(data, u);
    }
    
    TreeNode* dfs2(string &amp;data, int &amp;u)
    {
        if (data[u] == '#'){
            u += 2;
            return NULL;
        }
        
        int t = 0;
        bool is_minus = false;
        if (data[u] == '-')
        {
            is_minus = true;
            u ++;
        }
        while (data[u] != ',')
        {
            t = t * 10 + data[u] - '0';
            u ++;
        }
        u ++;
        if (is_minus) t = -t;
        
        auto root = new TreeNode(t);
        root-&gt;left = dfs2(data, u);
        root-&gt;right = dfs2(data, u);
        
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第二周(链表专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第二周(链表专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第二周(链表专题)">
        </link>
        <updated>2019-07-24T07:23:43.000Z</updated>
        <content type="html"><![CDATA[<p>链表的题目可以通过画图来看！！！</p>
<h4 id="19-remove-nth-node-from-end-of-list"><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></h4>
<p>题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>
你能尝试使用一趟扫描实现吗？</p>
<pre><code>示例：
给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
</code></pre>
<p>分析：对于单链表而言，要删除一个结点，首先要找到这个结点的头结点， 比如说示例中的4号结点，我们首先要找到3号结点，然后让3号结点的next指针指向下一个结点的头部，这样就可以删掉4号结点。</p>
<p>由于有可能删除我们的头结点，所以我们一般会创建一个虚拟结点来指向头结点。</p>
<ol>
<li>建立一个虚拟头结点，来指向原始头结点</li>
<li>设定一个红指针，让它先向后走n步，然后在设定一个绿指针，两个指针同时向后移动，红指针到达最后一个结点时终止，此时绿指针就是倒数第n+1个结点。</li>
<li>让绿指针指向后面一个结点的头结点。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dumpy = new ListNode(-1);
        dumpy-&gt;next = head;
        
        auto first = dumpy, second =dumpy;
        while (n--) first = first -&gt; next;
        while (first-&gt;next)
        {
            first = first-&gt;next;
            second = second-&gt;next;
        }
        second-&gt;next = second-&gt;next-&gt;next;
        return dumpy -&gt;next;
    }
}; 
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dumpy = ListNode(-1)
        dumpy.next = head 
        first, second = dumpy, dumpy

        while first.next:
            if n:
                n -= 1
            else:
                second = second.next
            first = first.next
        second.next = second.next.next
        return dumpy.next
</code></pre>
<h4 id="237-delete-node-in-a-linked-list"><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">237. Delete Node in a Linked List</a></h4>
<p>题目描述：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<pre><code>示例：
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
</code></pre>
<p>说明:</p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<p>分析：因为上一道题说过，删除某个结点需要直到它上一个结点的地址，但是现在只给了该结点的地址，所以一个做法是把它下一个节点的值赋值给它，然后删除下一个结点，因为给的并不是最后一个结点，所以是可行的。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val = node.next.val
        node.next = node.next.next
</code></pre>
<p>并且这道题我们其实是用node-&gt;next的结构来替换node的结构，所以也可以这样写：</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        *(node) = *(node-&gt;next);
    }
};
</code></pre>
<h4 id="83-remove-duplicates-from-sorted-list"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List</a></h4>
<p>题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<pre><code>示例：
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3
</code></pre>
<p>分析：从小到达排好序的链表，所以第一个结点是肯定不会被删掉的。我们从前到后进行枚举，每个结点有两种情况：1. 如果下一个点和当前点相同，删除下一个点；2. 如果下一个点和当前点不同，指针向后一位。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        auto cur = head;
        while (cur)
        {
            if (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val)
                cur-&gt;next = cur-&gt;next-&gt;next;
            else cur = cur-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        cur = head
        while cur:
            if cur.next and cur.next.val == cur.val:
                cur.next = cur.next.next
            else: cur = cur.next
        return head
</code></pre>
<h4 id="61-rotate-list"><a href="https://leetcode.com/problems/rotate-list/">61. Rotate List</a></h4>
<p>题目描述：给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<pre><code>示例：
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
</code></pre>
<p>分析：翻转就是把最后k个结点移到前面，由于k可能超过链表的长度，所以应该首先取模；<br>
<img src="https://tudouvvv.github.io//post-images/1563972831098.png" alt=""><br>
然后利用双指针，first指针首先从头往后走k步，然后second指针和first同时走，first走到结尾的时候停止，此时，first指向末尾，second指向倒数第k+1位；最后1. first-&gt;next=head； 2. head=second.next；3. second.next-&gt;null。<br>
ps. 头结点变得情况可以用虚拟头结点<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return NULL;
        int n = 0;
        for (auto p = head; p; p=p-&gt;next) n++;
        k %= n;
        auto first=head, second=head;
        while(k--) first = first-&gt;next;
        while(first-&gt;next)
        {
            first = first-&gt;next;
            second = second-&gt;next;
        }
        first-&gt;next = head;
        head =  second-&gt;next;
        second-&gt;next = NULL;
        return head;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:
        if not head: return None
        n = 1
        p = head
        while p.next:
            p = p.next
            n += 1
        k %= n
        first, second = head, head
        while k:
            first = first.next
            k -= 1
        while first.next:
            first = first.next 
            second = second.next
        first.next = head
        head = second.next
        second.next = None
        return head
</code></pre>
<h4 id="24-swap-nodes-in-pairs">⭐<a href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></h4>
<p>题目描述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<pre><code>示例：
Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.
</code></pre>
<p>分析：每次枚举一对儿结点，因为这道题头结点会发生变化，所以创建虚拟头结点p，然后分别创建a、b两个结点。<br>
<img src="https://tudouvvv.github.io//post-images/1564026372602.png" alt=""><br>
修改三个指针的指向位置即可：<br>
p-&gt;next = b；a-&gt;next = b-&gt;next；b-&gt;next = a；然后挪动p<br>
的位置，指向下一对儿结点的头部p= a。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        auto dummy = new ListNode(-1);
        dummy -&gt; next = head;
        
        for (auto p=dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;)
        {
            auto a = p-&gt;next, b = a-&gt;next;
            p-&gt;next = b;
            a-&gt;next = b-&gt;next;
            b-&gt;next = a;
            p = a;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        p = dummy
        while p.next and p.next.next:
            a = p.next
            b = a.next
            p.next = b
            a.next = b.next
            b.next = a
            p = a
        return dummy.next
</code></pre>
<h4 id="206-reverse-linked-list">⭐<a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></h4>
<p>题目描述：反转一个单链表。</p>
<pre><code>示例：
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>分析：翻转结点等价于把中间结点的指向位置翻转，具体做法就是：</p>
<ol>
<li>设定三个指针a\b分别指向1，2</li>
<li>c = b-&gt;next;</li>
<li>b-&gt;next=a;</li>
<li>a=b, b=c<br>
这样就完成了一次翻转，并且把两个指针移到到了下一个需要反转的位置。当b为空的时候，翻转结束；然后令head-&gt;next = NULL，head = a即可。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head) return NULL;
        auto a = head, b = a-&gt;next;
        while (b)
        {
            auto c = b -&gt; next;
            b-&gt;next = a;
            a=b, b=c;
        }
        head-&gt;next = NULL;
        head = a;
        
        return head;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        a = head
        b = a.next
        while b:
            c = b.next
            b.next = a
            a = b
            b = c
        head.next = None
        
        return a
</code></pre>
<h4 id="92-reverse-linked-list-ii">⭐<a href="https://leetcode.com/problems/reverse-linked-list-ii/">92. Reverse Linked List II</a></h4>
<p>题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<pre><code>示例：
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
</code></pre>
<p>分析：我们要翻转其中一段链表m-&gt;n，我们首先得知道m的位置b，它前一个点a以及n的位置c以及它后一个点d，然后因为这道题中头结点也有可能发生翻转，所以我们创建一个虚拟的头结点。<br>
具体做法：</p>
<ol>
<li>先建立一个虚拟头结点</li>
<li>求出a、b、c、d的位置，a是虚拟头结点走m-1步，依此类推...</li>
<li>然后复用上段代码，翻转b--c;</li>
<li>然后a.next = c，b.next=d。<br>
C++</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (m==n) return head;
        auto dummy = new ListNode(-1);
        dummy -&gt; next = head;
        
        auto a=dummy, c=dummy;
        for (int i=0; i &lt; m- 1; i++) a = a-&gt;next;
        for (int i=0; i &lt; n; i ++) c = c-&gt;next;
        auto b = a-&gt;next, d = c-&gt;next;
        
        for (auto p = b, q = b-&gt;next; q != d;)
        {
            auto o = q-&gt;next;
            q-&gt;next = p;
            p = q;
            q = o;
        }
        
        a -&gt; next = c;
        b -&gt; next = d;
        
    return dummy-&gt;next;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:
        if m == n:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        
        a, c  = dummy, dummy
        while m-1 &gt; 0:
            a = a.next
            m -= 1
        while n &gt; 0:
            c = c.next
            n -= 1
        b = a.next
        d = c.next
        p, q = b, b.next
        while q != d:
            o = q.next
            q.next = p
            p, q = q, o
        a.next = c
        b.next = d
        return dummy.next
</code></pre>
<h4 id="160-intersection-of-two-linked-lists"><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></h4>
<p>题目描述：编写一个程序，找到两个单链表相交的起始节点。<br>
如下面的两个链表：<br>
<img src="https://tudouvvv.github.io//post-images/1564042210816.png" alt="">在节点 c1 开始相交。<br>
注意：</p>
<ol>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>
分析：<img src="https://tudouvvv.github.io//post-images/1564042664892.png" alt=""><br>
设定两个指针，每次向后走一位，走到头后交换出发点，如果两个链表相交，那么它们在走过a+b+c后就一定会相遇，如果最后为空，那么它们就没有相交。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        auto p = headA, q = headB;
        while (p!=q)
        {
            if (p) p = p-&gt;next;
            else p = headB;
            if (q) q = q-&gt;next;
            else q = headA;
        }
        return p;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        &quot;&quot;&quot;
        :type head1, head1: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        p, q = headA, headB
        while p != q:
            if p != None:
                p = p.next
            else: p = headB
            if q != None:
                q = q.next
            else: q = headA
        return p
</code></pre>
<h4 id="142-linked-list-cycle-ii"><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></h4>
<p>题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<ul>
<li>不允许修改链表</li>
<li>能否只用O(1)的空间</li>
</ul>
<p><img src="https://tudouvvv.github.io//post-images/1564452405688.png" alt=""><br>
分析：设定两个指针，一个快指针fast（红色），一个慢指针slow（蓝色），fast指针每次走两步，slow指针每次走一步，当slow指针到b的时候，fast指针在左边c'处，离b的距离是y，由于快指针比慢指针快，所以二者会在c处相遇。相遇之后把慢指针重新放在头部，然后两个指针每次走一步，当两者相遇时一定在b点。因为第一次慢指针走到b时，走了x步，而快指针走了2x步，所以b--&gt;c'的距离是x步，整个圈的距离是x+y步，现在慢指针在开头，快指针在c处，两者每次走一步，当慢指针走x步时，快指针也走x步，就恰好相遇在b处。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        auto slow = head, fast = head;
        while (fast)
        {
            fast = fast-&gt;next;
            slow = slow-&gt;next;
            if (fast) fast = fast -&gt;next;
            // if (slow) slow = slow-&gt;next;
            else break;
            
            if  (fast == slow)
            {
                slow = head;
                while (slow != fast)
                {
                    slow = slow -&gt;next;
                    fast = fast -&gt;next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        slow, fast = head, head
        while fast:
            fast = fast.next
            slow = slow.next
            if fast: fast = fast.next
            else: break
            if slow == fast:
                slow = head
                while slow!= fast:
                    slow = slow.next
                    fast = fast.next
                return slow
        return None
</code></pre>
<h4 id="148-sort-list存疑">⭐<a href="https://leetcode.com/problems/sort-list/">148. Sort List</a>【存疑】</h4>
<p>题目描述：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<pre><code>示例：
Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
</code></pre>
<p>分析：快排和归并排序的空间复杂度不满足要求，<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        int n = 0;
        for (auto p=head; p; p=p-&gt;next)  n++;
        auto dummy = new ListNode(-1);
        dummy-&gt;next = head;
        for (int i = 1; i &lt; n; i *= 2)
        {
            auto cur = dummy;
            for (int j = 0; j + i &lt; n; j += i * 2)
            {
                auto left = cur-&gt;next, right = cur-&gt;next;
                for (int k = 0; k &lt; i; k ++) right = right-&gt;next;
                int l = 0, r = 0;
                while (l &lt; i &amp;&amp; r &lt; i &amp;&amp; right)
                    if (left-&gt;val &lt;= right-&gt;val)
                    {
                        cur-&gt;next = left;
                        cur = left;
                        left = left-&gt;next;
                        l ++;
                    }
                    else
                    {
                        cur-&gt;next = right;
                        cur = right;
                        right = right-&gt;next;
                        r ++;
                    }
                while (l &lt; i)
                {
                    cur-&gt;next = left;
                    cur = left;
                    left = left-&gt;next;
                    l ++;
                }
                while (r &lt; i &amp;&amp; right)
                {
                    cur-&gt;next = right;
                    cur = right;
                    right = right-&gt;next;
                    r ++;
                }
                
                cur-&gt;next = right; 
            }
        }
        
        return dummy-&gt;next;
        
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第一周(二分专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第一周(二分法)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第一周(二分法)">
        </link>
        <updated>2019-07-15T09:13:13.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p>二分的知识点就是每次把备选答案的空间缩小一半，但是整数二分一个很蛋疼的问题就是边界问题。</p>
<h3 id="二分思想">二分思想：</h3>
<p>答案是在一个区间之中，L-----R，通过中点的情况来判断答案的所处位置，然后删掉另外一边，缩小一半备选空间，然后再继续判断新的中点的情况，直到L==R找到答案。</p>
<p>70% 的二分题目都跟单调性有关(其余的题目虽然可以用二分但是不一定具有单调性)<br>
95% 的题目存在两段性的性质（左边一段成立，右边一段不成立），就可以找到一个边界点。</p>
<h3 id="时间复杂度logn">时间复杂度：logN</h3>
<h3 id="二分模板">二分模板</h3>
<h4 id="模板一">模板一：</h4>
<p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid]</code>和<code>[mid + 1, r]</code>时，其更新操作是<code>r = mid</code>或者<code>l = mid + 1</code>;，计算<code>mid</code>时不需要加1。</p>
<pre><code>int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;    // 向下取整
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
</code></pre>
<h4 id="模板二">模板二</h4>
<p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid - 1]</code>和<code>[mid, r]</code>时，其更新操作是<code>r = mid - 1</code>或者<code>l = mid</code>;，此时为了防止死循环，计算<code>mid</code>时需要加1。</p>
<pre><code>int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;    // 向上取整
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h3 id="二分的流程">二分的流程：</h3>
<ol>
<li>先考虑二分的区间;</li>
<li>编写二分的代码框架;</li>
<li>设计一个check（性质）;</li>
<li>判断一下区间如何更新;</li>
<li>如果更新方式写的是l = mid，r = mid - 1，那么就在算mid的时候加上1</li>
</ol>
<h3 id="习题练习">习题练习</h3>
<h5 id="69-sqrtx"><a href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x)</a></h5>
<p>题目描述：计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：首先二分的区间是[0, x]，然后确定一下判断的性质，我们想要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">mid^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>&lt;=x，那么就应该用第二个模板。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        int l=0, r=x;
        while (l &lt; r)
        {
            int mid = l + (long long)r + 1 &gt;&gt; 1;   // 防止mid溢出，所以用long long 型
            if (mid &lt;= x / mid)  l=mid;   //并且为了防止陷入死循环，需要+1向上取整
            else r = mid -1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def mySqrt(self, x: int) -&gt; int:
        l, r = 0, x
        while l&lt;r:
            mid = l + r + 1 &gt;&gt; 1
            if mid &lt;= (x / mid):
                l = mid
            else:
                r = mid -1
        return l
</code></pre>
<p>当然也可以选择另一个判断方式，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">mid^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>&gt;x，此时在[0, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><msqrt><mi>x</mi></msqrt><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left \lfloor\sqrt{x }\right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>]内是不满足的，在[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><msqrt><mi>x</mi></msqrt><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left \lfloor\sqrt{x }\right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>+1, x]内是满足的，所以最后返回l-1或者r-1即可</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        if (x==1) return 1;
        if (x==0) return 0;
        int l=0, r=x;
        while (l &lt; r) {
            int mid = l + (long long)r &gt;&gt; 1;
            if (mid &gt; x/mid)   r = mid;
            else l = mid + 1;
        }
        return l-1;
    }
};
</code></pre>
<h4 id="35-search-insert-position"><a href="https://leetcode.com/problems/search-insert-position/">35. Search Insert Position</a></h4>
<p>题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>
你可以假设数组中无重复元素。</p>
<p>分析：首先可二分的边界条件就是数组的大小，即[0, nums.size()]，我们确定的check条件是：nums[mid] &gt;= target，那就说明target在mid的左边，需要改变 右边界<code>r = mid</code>，如果nums[mid] &lt; target，就说明target在mid右边，需要改变左边界，<code>l = mid + 1</code>。当然check条件也可以改为nums[mid]&lt;target，这样区间更新策略换一下就行。</p>
<p>确定一下边界条件：如果数组为空，那么应该返回0；如果target&gt;nums.back()，返回数组的长度。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty() || target &gt; nums.back()) return nums.size();
        int l=0, r = nums.size()-1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r=mid;
            else  l = mid+1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchInsert(self, nums: List[int], target: int) -&gt; int:
        if len(nums) == 0 or target &gt; nums[-1]:
            return len(nums)
        l = 0
        r = len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target:
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="34-find-first-and-last-position-of-element-in-sorted-array"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></h4>
<p>题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>
你的算法时间复杂度必须是 O(log n) 级别，如果数组中不存在目标值，返回 [-1, -1]。<br>
示例：</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
</code></pre>
<p>分析：因为要返回两个位置，所以应该要用两次二分法，一次返回开始位置的索引，一次返回结束位置的索引。首先是开始位置，nums[mid] &gt;= target，然后是结束位置，nums[mid] &lt;= target。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty()) return {-1, -1};
        int l =0, r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) return {-1, -1};
        int start = l;
        l = 0, r = nums.size() - 1;
        while(l &lt; r)
        {
            int mid = l + r  + 1 &gt;&gt; 1;
            if (nums[mid] &lt;= target) l = mid;
            else r = mid - 1;
        }
        int end = r;
        return {start, end};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
        if len(nums) == 0: return [-1, -1]
        l, r = 0, len(nums)-1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target:
                r = mid
            else: l = mid + 1
        if nums[l] != target: return [-1, -1]
        else: start = l
        l, r = 0, len(nums)-1
        while l &lt; r:
            mid = l + r + 1 &gt;&gt; 1
            if nums[mid] &lt;= target:
                l = mid
            else: r = mid - 1
        end = r
        return [start, end]
</code></pre>
<h4 id="74-search-a-2d-matrix"><a href="https://leetcode.com/problems/search-a-2d-matrix/">74. Search a 2D Matrix</a></h4>
<p>题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。<br>
示例：</li>
</ul>
<pre><code>输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true
</code></pre>
<p>分析：如果展成一列的话，那么是单调递增的，这样就可以把整个空间分成两部分，check的性质是nums[mid] &gt;= target，需要了解到的是，数组的长度是：<code>n * m</code>(n为矩阵的行数，n为矩阵的列数)，然后还需要把mid还原为i和j，<code>i = mid // m</code>，<code>j = mid % m</code>。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) return false;
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = m * n - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (matrix[mid / m][mid % m] &gt;= target) r = mid;
            else l = mid + 1;
        }
        return matrix[r / m][r % m] == target;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        if len(matrix) == 0 or len(matrix[0]) == 0: return False
        n = len(matrix)
        m = len(matrix[0])
        l = 0
        r = m * n - 1
        while l &lt; r:
            mid  = l + r &gt;&gt; 1
            if matrix[mid // m][mid % m] &gt;= target:
                r = mid
            else: l = mid + 1
        return matrix[l // m][l % m] == target
</code></pre>
<h4 id="153-find-minimum-in-rotated-sorted-array"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></h4>
<p>题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
<code>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</code>请找出其中最小的元素，你可以假设数组中不存在重复元素。</p>
<p>分析：题目就是说把一个升序数组的一部分移到了数组的前面，如果用二分法来做的话，就首先应该找到一个二段性，可以把整个区间分成两部分。<br>
<img src="https://tudouvvv.github.io//post-images/1563356609008.png" alt=""><br>
如图，整个数组的分布相当于这个样子，我们想找的就是红色的这个点，判断的条件就是：<code>nums[mid] &lt;= nums.back()</code>，nums.back()就是蓝色的这个点，这样就把整个数组分成了两部分。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int l = 0, r = nums.size();
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt;= nums.back()) r = mid;
            else l = mid + 1;
        }
        return nums[r];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findMin(self, nums: List[int]) -&gt; int:
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &lt;= nums[-1]:
                r = mid
            else: l = mid + 1
        return nums[l]
</code></pre>
<h4 id="33-search-in-rotated-sorted-array"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></h4>
<p>题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
<code>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )</code><br>
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>
你可以假设数组中不存在重复的元素，你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>分析：虽然这道题没有明显的二分性，但是可以曲线救国，首先可以找到数组的最小值，把整个数组分成两块儿，然后再通过与<code>nums.back()</code>的比较来查看target是属于哪一块儿，再到该块儿进行二分。那第一步找到数组的最小值可以直接复用上一道题。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty()) return -1;
        int l = 0, r = nums.size() - 1;
// 找到最小值的位置
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt;= nums.back()) r = mid;
            else l = mid + 1;
        }
// 判断target属于哪一块儿
        if (target &gt; nums.back()) l = 0, r --;
        else r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r + 1&gt;&gt; 1;
            if (nums[mid] &lt;= target) l = mid;
            else r = mid - 1;
        }
// 这里只能用l，因为如果整个数组是单调的，那么之前l=r=0
// 判断属于哪一块儿后r有可能变为-1，那么第二个while循环就不会执行
// 此时nums[r] = nums[-1]会越界
        if (nums[l] == target) return l;
        return -1;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def search(self, nums: List[int], target: int) -&gt; int:
        if not nums: return -1;
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &lt;= nums[-1]:
                r = mid
            else: l = mid + 1
        if target &gt; nums[-1]: 
            l = 0
            r -= 1
        else: r = len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target: r = mid
            else: l = mid + 1
        if target == nums[l]: return l
        else: return -1
</code></pre>
<h4 id="278-first-bad-version"><a href="https://leetcode.com/problems/first-bad-version/">278. First Bad Version</a></h4>
<p>题目描述：你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。<br>
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。<br>
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<pre><code>示例：
给定 n = 5，并且 version = 4 是第一个错误的版本。
调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true
所以，4 是第一个错误的版本。 
</code></pre>
<p>分析：很明显这是一个二分的题目，因为就相当于这是一条时间线，从中间某个节点出现问题，那么就二分了，并且都不用去想二分的性质，因为题目已经给你提供了一个接口<code>isBadVersion</code>。<br>
C++</p>
<pre><code class="language-c++">// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int l = 0, r = n;
        while (l &lt; r)
        {
            int mid = (long long)l + r &gt;&gt; 1;  //测试的时候溢出了所以加了long long
            if (isBadVersion(mid)) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        l, r = 0, n
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if isBadVersion(mid):
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="162-find-peak-element"><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a></h4>
<p>题目描述：峰值元素是指其值大于左右相邻值的元素。<br>
给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br>
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br>
你可以假设 nums[-1] = nums[n] = -∞。</p>
<p>分析：考虑二分的做法，不管怎么样，数组中一定是存在一个峰值的，我们比较nums[mid] 与 nums[mid+1]的关系，如果nums[mid]&lt;nums[mid+1]，那么二分的两段中，右边必存在峰值，就算一直递增，那么端点也算峰值；反之亦然。<br>
所以用二分的思想，必然会找到一个峰值。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int l = 0, r = nums.size() - 1;
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
						// 为什么不用判断mid+1是否越界呢，因为此时mid= n - 1的话
						// l = r = n - 1，没有进入while循环
            if (nums[mid] &gt; nums[mid+1]) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findPeakElement(self, nums: List[int]) -&gt; int:
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt; nums[mid+1]:
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="287-find-the-duplicate-number"><a href="https://leetcode.com/problems/find-the-duplicate-number/">287. Find the Duplicate Number</a></h4>
<p>题目描述：给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>
Note：</p>
<ul>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<p>分析：<br>
<code>抽屉原理</code>：假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。<br>
将整个数组二分为两半，则两边至少会有一边存在重复的数，两边分别拥有的数的个数是：L = mid - l +1 ，R = r - mid + 1，现在我们的区间是[1, n]，mid就是1---&gt;n中间的那个数，举例：nums = [1,3,4,2,2]，此时的区间为[1, 4]，n= 4, mid = 2，统计小于等于mid的数的个数：</p>
<pre><code>for num in nums:
    if num &lt;= mid: 
        cnt += 1
</code></pre>
<p>计算出来cnt = 3，然后来比较cnt与左边的数的个数，如果cnt &gt; L，说明<br>
重复的这个数就在左边(这里的左边是相对区间[1, 4]来说的)<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int l = 1, r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            int cnt = 0;
            for (auto num : nums)
                if (num &gt;=l &amp;&amp; num &lt;= mid) 
                    cnt++;
            if (cnt&gt;mid-l+1) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        l, r = 1, len(nums)-1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            cnt = 0
            for num in nums:
                if num &gt;= l and num &lt;= mid:
                    cnt += 1
            if cnt &gt; mid - l + 1:
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="275-h-index-ii"><a href="https://leetcode.com/problems/h-index-ii/">275. H-Index II</a></h4>
<p>题目描述：给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）</p>
<p>分析：意思就是在一个数组中找到一个数h，使得数组中至少有h个数 &gt;= h。首先确定h的范围，h最大为n，最小为0，并且h是有二分性质的。如果h满足条件，那么h-1必然也满足...，所以小于&lt;=h的数满足答案，&gt;h的数不满足答案。用二分法找到h就行。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        int l = 0, r = citations.size();
        while (l &lt; r)
        {
            int mid = l + r + 1 &gt;&gt; 1;
            if (citations[citations.size() - mid] &gt;= mid) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        l, r = 0, len(citations)
        while l &lt; r:
            mid = l + r +1 &gt;&gt; 1;
            if citations[len(citations) - mid] &gt;= mid:
                l = mid
            else: r = mid - 1;
        return l
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[每日一题]-942. DI String Match]]></title>
        <id>https://tudouvvv.github.io//post/942-DI-String-Match</id>
        <link href="https://tudouvvv.github.io//post/942-DI-String-Match">
        </link>
        <updated>2019-04-04T08:19:05.000Z</updated>
        <summary type="html"><![CDATA[<center>升 级 打 怪 ing ~ ~</center>]]></summary>
        <content type="html"><![CDATA[<center>升 级 打 怪 ing ~ ~</center>
<!--more-->
<p>题目地址：<a href="https://leetcode.com/problems/di-string-match/">942. DI String Match</a></p>
<p>题目要求：</p>
<p>输入一个字符串S，只包含I(increase)和D(decrease)，然后A是一个从0到len(S)的数组，现在要求如果S[i] == &quot;I&quot;，那么A[i] &lt; A[i+1]；如果S[i] == &quot;D&quot;，那么A[i] &gt; A[i+1]。</p>
<p>思路：</p>
<p>必须要为后面的操作留有余地，所以遇见I的时候，拿出最小的数保证剩余的数都比它大；遇见D的时候，拿出最大的数保证剩下的数都比它小。</p>
<center>----------------------</center>
<p>所以我的做法是：</p>
<pre><code class="language-python">class Solution:
    def diStringMatch(self, S: str) -&gt; List[int]:
        p = []
        N = []
        for i in range(len(S)+ 1):
            p.append(i)
        for char in S:
            if char == &quot;D&quot;:
                N.append(max(p))
                p.remove(max(p))
            else:
                N.append(min(p))
                p.remove(min(p))
        N.append(p[0])
        return N
</code></pre>
<p>先构建一个从0到len(S)的序列(现在看来很蠢)然后遍历S，遇见D取大的，遇见I取小的，最后再把剩下的数加进去</p>
<p>提交后果然，Time Limit Exceeded</p>
<p>去讨论区看一看，我为什么要新建一个数组？？？每次取的数都是最左边或者最右边的数，直接设置两个指针指向两边即可。</p>
<pre><code class="language-python">
class Solution:
    def diStringMatch(self, S: str) -&gt; List[int]:
        l, r, N = 0, len(S), []
        for char in S:
            N.append(l if char =='I' else r)
            l, r = l +(char == 'I'), r - (char == 'D')
        return N + [l]
</code></pre>
<p>基本上大家的思路都是这样，可能写法不太一样，像我这种写法就非常的臃肿-----</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[每日一题]-883. Projection Area of 3D Shapes]]></title>
        <id>https://tudouvvv.github.io//post/883. Projection Area of 3D Shapes</id>
        <link href="https://tudouvvv.github.io//post/883. Projection Area of 3D Shapes">
        </link>
        <updated>2019-04-04T08:13:25.000Z</updated>
        <summary type="html"><![CDATA[<center>升 级 打 怪 ing ~ ~</center>]]></summary>
        <content type="html"><![CDATA[<center>升 级 打 怪 ing ~ ~</center>
<!--more-->
<p>题目地址：<a href="https://leetcode.com/problems/projection-area-of-3d-shapes/">883. Projection Area of 3D Shapes</a></p>
<p>题目要求：</p>
<p>求一个体积为1的方块拼起来的立方体的俯视图，主视图，左视图的面积之和。</p>
<p>样例：</p>
<p>背景是一个被分为N * N 个格子的坐标轴</p>
<p>输入：grid = [[1, 2],[3, 4]]</p>
<p>（输入说明：grid[0][0]表示在(0, 0)处有一个方块，grid[0][1]表示在(0, 1)处有一个方块...）</p>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/883.png" alt=""></p>
<p>输出：17</p>
<p>思路：</p>
<p>整个面积分为三部分：top、front、left</p>
<ul>
<li>
<p>输入的grid就相当于一个数组</p>
</li>
<li>
<p>top的面积就是所有非0元素的个数之和</p>
</li>
<li>
<p>front的面积就是每行元素的最大值之和</p>
</li>
<li>
<p>left的面积就是每列元素的最大值之和</p>
</li>
</ul>
<h3 id="top">top</h3>
<p>所以top的值就需要遍历每个元素，然后统计非0元素的个数:</p>
<pre><code class="language-python">for i in range(len(grid):
    for j in range(len(grid[0]):
        if grid[i][j] != 0:
            top += 1
</code></pre>
<h3 id="front">front</h3>
<pre><code>for i in range(len(grid)):
    front += max(grid[i])
</code></pre>
<h3 id="left">left</h3>
<pre><code>for i in range(len(grid)):
    left_num = 0
    for j in range(len(grid[0])):
        left_num = max(left_num, grid[j][i])
    left += left_num
</code></pre>
<p>完整代码：</p>
<pre><code class="language-python">class Solution:
    def projectionArea(self, grid: List[List[int]]) -&gt; int:
        top, front, left = (0, 0, 0)
        for i in range(len(grid)):
            left_num = 0
            front += max(grid[i])
            for j in range(len(grid[0])):
                if grid[i][j] &gt; 0:
                    top += 1
                left_num = max(left_num, grid[j][i])
            left += left_num
        return top + front + left
</code></pre>
<p>提交结果：48ms        48.04%</p>
<p>最快的解决方案：</p>
<pre><code class="language-python">class Solution:
    def projectionArea(self, grid: 'List[List[int]]') -&gt; 'int':
        &quot;&quot;&quot;
        from top：grid长度之和
        from front: 每行的最大值之和
        from side: 每列的最大值之和
        &quot;&quot;&quot;
        
        top = sum([v!=0 for row in grid for v in row])
        front = sum([max(row) for row in grid])
        side = []
        for i in range(len(grid[0])):
            col = [row[i] for row in grid]
            side.append(max(col))
        return top + front + sum(side)
</code></pre>
<p>思路差不多，只不过人家写的比较简洁，小技巧需要学起来呀！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建多层神经网络与初步尝试使用keras构建CNN]]></title>
        <id>https://tudouvvv.github.io//post/构建深度神经网络与初步尝试使用keras构建CNN</id>
        <link href="https://tudouvvv.github.io//post/构建深度神经网络与初步尝试使用keras构建CNN">
        </link>
        <updated>2018-11-14T06:27:54.000Z</updated>
        <content type="html"><![CDATA[<p>正准备开始写这篇记录，结果发现图床坏了- -，又开始从原来的图床把之前的图片转移到新的图床，浪费了好多时间。</p>
<p>上次用logestic回归和梯度下降法训练了一个神经网络，用来做二分类的问题，最后精度差不多70%左右，这次主要写一个多层的神经网络，训练同样的数据集，看一看会不会对准确度有提升。</p>
<h1 id="多层神经网络">多层神经网络</h1>
<p>多层神经网络中，也分为前向传播和后向传播，前向传播计算损失函数，后向传播通过梯度下降法来更新参数。在每一层中，先通过一个线性的激活单元<code>Z = WX + b</code>，然后再通过一个非线性的激活单元，这里的话由于我们做的是二分类问题，所以最后一层的激活函数选择<code>sigmoid</code>，其它层中选择效果比较好的<code>Relu</code>函数，在实际的操作中，对于一个L层的神经网络，我们需要进行<code>L-1</code>次Relu函数激活。</p>
<p>这是多层神经网络的大概结构：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png" alt=""></p>
<p>前向过程就是不断的通过各层神经网络直到最后计算损失，最主要的就是后向过程，后向过程就是链式求导以便最后使用梯度下降法来更新每一层的参数</p>
<p>对前向过程来说：</p>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/%E5%89%8D%E5%90%91%E8%BF%87%E7%A8%8B.png" alt=""></p>
<p>即根据上一层的激活值通过线性单元和激活函数输出本层的激活值，其中<code>g(Z)</code>代表每一层的激活函数，而后向过程中，我们需要计算每一层<code>dW</code>和<code>db</code>的值以便进行后面的参数更新：</p>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/%E5%90%8E%E5%90%91%E4%BC%A0%E6%92%AD.png" alt=""></p>
<p>讲道理，矩阵学的不是很好，所以一旦把变量矩阵化以后进行求导操作什么的有点迷糊，这里需要再好好学习一下</p>
<p>这样就是整个深层神经网络的基本结构了</p>
<p>我们可以先把激活函数的前向和后向过程写成一个模块，以便方便调用：</p>
<pre><code class="language-python">import numpy as np


def sigmoid(Z):
    A = 1 / (1 + np.exp(-Z))
    cache = Z
    return A, cache


def sigmoid_backward(dA, cache):
    Z = cache
    s = 1 / (1 + np.exp(-Z))
    dZ = dA * s * (1 - s)
    return dZ


def relu(Z):
    A = np.maximum(0, Z)
    cache = Z
    return A, cache


def relu_backward(dA, cache):
    Z = cache
    dZ = np.array(dA, copy=True)
    dZ[Z &lt;= 0] = 0
    return dZ
</code></pre>
<p>接着来开始写我们的多层神经网络，第一步是对我们的数据进行预处理，由于我们输入的是64*64的图片，而且一张彩色图片有rgb三个通道，所以我们要把一张图片上三个通道的信息整合在一起作为一列，把训练集和测试集的图片的信息处理为一个矩阵，作为神经网络的输入，同时可以对输入数据进行缩小，由于像素值表示亮度，每点的像素值最大为255，我们可以每个点的像素值都除以255，使得我们的输入数据全部在[0, 1]之间。<br>
训练集和测试集的样本数据来自已经写好的模块。</p>
<pre><code class="language-python">train_set_x, train_set_y, test_set_x, test_set_y, classes = load_dataset()

train_set_x = train_set_x.reshape(train_set_x.shape[0], -1).T
test_set_x = test_set_x.reshape(test_set_x.shape[0], -1).T

train_set_x = train_set_x / 255
test_set_x = test_set_x / 255
</code></pre>
<p>接着应该初始化我们每一层的参数，之前对于只有一个logestic单元，初始化时可以都为0，但是对多层神经网络来说，如果W初始化为0 则对于任何X，每个隐藏层对应的每个神经元的输出都是相同的，这样即使梯度下降训练，无论训练多少次，这些神经元都是对称的，无论隐藏层内有多少个结点，都相当于在训练同一个函数，所以我们要采用随机初始化。</p>
<p>在多层神经网络中，每一层参数的维度都是确定的，与该层神经元的个数密切相关：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/%E5%8F%82%E6%95%B0%E7%BB%B4%E5%BA%A6.png" alt=""></p>
<p>所以我们这样来初始化每一层的参数：</p>
<pre><code class="language-python">def initialize_parameters(dims):
    L = len(dims)
    parameters = {}
    for l in range(1, L):
        parameters['W' + str(l)] = np.random.randn(dims[l], dims[l-1]) * np.sqrt(1 / dims[l - 1])
        parameters['b'+ str(l)] = np.zeros((dims[l], 1))
    return parameters
</code></pre>
<p><code>dims</code>为一个列表，其中包含每一层神经元的个数，比如<code>[12288, 12, 7, 1]</code></p>
<p>这样就初始化好了每一层的变量，之前说过一个对于该多层神经网络来说，前向传播时会进行<code>L-1</code>次<code>relu</code>激活，一次<code>sigmoid</code>激活，每一次激活包括线性激活和激活函数激活，我们把这个操作定义成一个函数，到时候直接调用函数就可以了。</p>
<p>所以接下来定义每一层的线性激活部分的函数，线性激活部分主要做的就是<code>Z = WA + B</code>:</p>
<pre><code class="language-python">def linear_forward(A, W, b):
    Z = np.dot(W, A) + b
    linear_cache = (A, W, b)
    return Z, linear_cache
</code></pre>
<p>这里要记得保存线性部分的参数，之后做梯度下降法的时候会用到。<br>
然后就是定义激活函数激活的函数，激活函数做的就是<code>A = g(Z)</code>:</p>
<pre><code class="language-python">def activation_forward(A_pre, W, b, activation):
    if activation == 'relu':
        Z, linear_cache = linear_forward(A_pre, W, b)
        A, activation_cache = relu(Z)
    if activation == 'sigmoid':
        Z, linear_cache = linear_forward(A_pre, W, b)
        A, activation_cache = sigmoid(Z)
        
    cache = (linear_cache, activation_cache)
    return A, cache
</code></pre>
<p>在激活函数中调用之前写的线性激活函数，最后返回每一层的输出<code>A</code>以及参数<code>cache</code>。</p>
<p>接下来就可以进行前向过程的编写了，前向过程的输入是我们的图片信息，我们以<code>X</code>表示，以及每一层的参数，我们以<code>parameters</code>表示，这样在经过每一层的传播之后，最终得到我们的输出结果<code>AL</code>，我们要用它来计算损失函数的大小：</p>
<pre><code class="language-python">def L_model_forward(X, parameters):
    caches = []
    A = X
    L = len(parameters) // 2
    for l in range(1, L):
        A_prev = A
        A, cache = activation_forward(A_prev, parameters['W'+str(l)], parameters['b'+str(l)], 'relu')
        caches.append(cache)
        
    AL, cache = activation_forward(A, parameters['W'+str(L)], parameters['b'+str(L)], 'sigmoid')
    caches.append(cache)
    
    return AL, caches
</code></pre>
<p>这样整个前向过程全部完成，接下来应该计算损失函数的大小，由于这是一个二分类问题，我们采用二元交叉熵作为我们的损失函数，它的表达式如下：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt=""></p>
<pre><code class="language-python">def cost_compute(AL, Y):
    m = Y.shape[1]
    cost = (-1 / m) * np.sum(np.multiply(Y, np.log(AL)) + np.multiply((1 - Y), np.log(1 - AL)))
    cost = np.squeeze(cost)

    return cost
</code></pre>
<p>这就是整个前向过程的所有步骤了，我们以降低损失函数为目标，在后向过程中不断使用梯度下降法进行优化，逐渐逼近最低值，目前只是简单的使用梯度下降法，后面会尝试其它的优化方案，比如动量梯度下降或者mini-batch。</p>
<p>完成整个前向过程之后，思考一下后续的步骤，对于后向过程来说，每一个神经元先对激活函数激活的部分进行求导得到<code>dZ</code>，然后在对线性激活的部分求导，得到<code>dW</code>和<code>db</code>，我们首先定义线性激活的后向过程：</p>
<pre><code class="language-python">def linear_backward(dZ, cache):
    A_prev, W, b = cache
    m = A_prev.shape[1]
    dW = np.dot(dZ, A_prev.T) / m
    db = np.sum(dZ, axis=1, keepdims=True) / m
    dA_prev = np.dot(W.T, dZ)
    return dA_prev, dW, db
</code></pre>
<p>接着定义激活函数激活的后向过程，我们之前已经把两个激活函数的后向求导过程定义好了，我们只要调用就好了。之前也说过，每个激活单元分为两个过程，线性激活与函数激活两个过程，我们现在调用了函数激活的后向过程，得到<code>dZ</code>，然后在调用上面定义的线性激活的后向过程，得到<code>dA</code>、<code>dW</code>、<code>db</code>：</p>
<pre><code class="language-python">def activation_backward(dA, cache, activation):
    linear_cache, activation_cache = cache
    if activation == 'relu':
        dZ = relu_backward(dA, activation_cache)
        dA_prev, dW, db = linear_backward(dZ, linear_cache)
    if activation == 'sigmoid':
        dZ = sigmoid_backward(dA, activation_cache)
        dA_prev, dW, db = linear_backward(dZ, linear_cache)

    return dA_prev, dW, db
</code></pre>
<p>然后就可以把全部过程整合在一起，我们可以想一下这个过程，从最后一个<code>sigmoid</code>激活单元来说，它会经历一个上述的<code>activation_backward</code>过程，前提是我们需要求出损失函数对最终输出的求导就好<code>dAL</code>，之后调用上述函数。之后就是<code>L-1</code>次的<code>relu</code>函数的后向传播过程，这样我们就会得到每一层参数的导数，以便通过梯度下降法进行参数的更新：</p>
<pre><code class="language-python">def L_model_backward(AL, Y, caches):
    grads = {}
    L = len(caches)
    m = AL.shape[1]
    Y = Y.reshape(AL.shape)
    dAL = -(np.divide(Y, AL) - np.divide((1 - Y), (1 - AL)))

    current_cache = caches[L - 1]
    grads['dA'+str(L)], grads['dW'+str(L)], grads['db'+str(L)] = activation_backward(dAL, current_cache, 'sigmoid')

    for l in reversed(range(L - 1)):
        current_cache = caches[l]
        grads['dA'+str(l + 1)], grads['dW'+str(l + 1)], grads['db'+str(l + 1)] = activation_backward(grads['dA'+str(l + 2)], current_cache, 'relu')

    return grads
</code></pre>
<p>现在我们来定义参数更新的函数，参数更新需要定义学习率<code>learning_rate</code>，它控制我们每次参数更新的步长：</p>
<pre><code class="language-python">def up_parameters(parameters, grads, learning_rate):
    L = len(parameters) // 2
    for l in range(L):
        parameters['W'+str(l+1)] = parameters['W'+str(l+1)] - learning_rate * grads['dW'+str(l+1)]
        parameters['b'+str(l+1)] = parameters['b'+str(l+1)] - learning_rate * grads['db'+str(l+1)]
    return parameters
</code></pre>
<p>这样所有的过程都已经全部完成了，我们现在只需调用上述的所有过程就好，我们同时还可以定义每迭代100次打印出此时的损失函数的值，同时在迭代结束后打印出损失函数的曲线，看一下我们的训练过程：</p>
<pre><code class="language-python">def L_model(X, Y, dims, learning_rate, num_iternation, print_cost=False, isPlot=False):
    parameters = initialize_parameters(dims)
    costs = []
    for i in range(num_iternation):
        AL, caches = L_model_forward(X, parameters)
        cost = cost_compute(AL, Y)
        grads = L_model_backward(AL, Y, caches)
        parameters = up_parameters(parameters, grads, learning_rate)

        if i % 100 == 0:
            costs.append(cost)
            if print_cost:
                print(&quot;第&quot;, i + 100, &quot;次迭代，成本值为:&quot;, np.squeeze(cost))

    if isPlot:
        plt.plot(np.squeeze(costs))
        plt.ylabel('cost')
        plt.xlabel('iterations (per tens)')
        plt.title(&quot;Learning rate =&quot; + str(learning_rate))
        plt.show()
    return parameters
</code></pre>
<p>这样我们定义好神经网络的结构，直接调用这个函数就好，最后我们需要定义一个<code>predict</code>接口，以便训练好我们的神经网络以后进行测试集的预测：</p>
<pre><code class="language-python">def predict(X, Y, parameters):
    m = Y.shape[1]
    Y_predict = np.zeros((1, m))
    AL, caches = L_model_forward(X, parameters)

    for i in range(0, AL.shape[1]):
        if AL[0, i] &gt; 0.5:
            Y_predict[0, i] = 1
        else:
            Y_predict[0, i] = 0

    print(&quot;准确度为:&quot;, 100 - np.mean(np.abs(Y - Y_predict)) * 100, &quot;%&quot;)
    return Y_predict
</code></pre>
<h3 id="下面是完整的代码">下面是完整的代码：</h3>
<pre><code class="language-python">import numpy as np
from lr_utils import load_dataset
import matplotlib.pyplot as plt
from c9 import sigmoid, sigmoid_backward, relu, relu_backward

train_set_x, train_set_y, test_set_x, test_set_y, classes = load_dataset()

train_set_x = train_set_x.reshape(train_set_x.shape[0], -1).T
test_set_x = test_set_x.reshape(test_set_x.shape[0], -1).T

train_set_x = train_set_x / 255
test_set_x = test_set_x / 255


def initialize_parameters(dims):
    L = len(dims)
    parameters = {}
    for l in range(1, L):
        parameters['W' + str(l)] = np.random.randn(dims[l], dims[l-1]) * np.sqrt(1 / dims[l - 1])
        parameters['b'+ str(l)] = np.zeros((dims[l], 1))
    return parameters


def linear_forward(A, W, b):
    Z = np.dot(W, A) + b
    linear_cache = (A, W, b)
    return Z, linear_cache


def activation_forward(A_pre, W, b, activation):
    if activation == 'relu':
        Z, linear_cache = linear_forward(A_pre, W, b)
        A, activation_cache = relu(Z)
    elif activation == 'sigmoid':
        Z, linear_cache = linear_forward(A_pre, W, b)
        A, activation_cache = sigmoid(Z)

    cache = (linear_cache, activation_cache)
    return A, cache


def L_model_forward(X, parameters):
    caches = []
    A = X
    L = len(parameters) // 2
    for l in range(1, L):
        A_prev = A
        A, cache = activation_forward(A_prev, parameters['W' + str(l)], parameters['b' + str(l)], 'relu')
        caches.append(cache)

    AL, cache = activation_forward(A, parameters['W' + str(L)], parameters['b' + str(L)], 'sigmoid')
    caches.append(cache)

    return AL, caches


def cost_compute(AL, Y):
    m = Y.shape[1]
    cost = (-1 / m) * np.sum(np.multiply(Y, np.log(AL)) + np.multiply((1 - Y), np.log(1 - AL)))
    cost = np.squeeze(cost)

    return cost


def linear_backward(dZ, cache):
    A_prev, W, b = cache
    m = A_prev.shape[1]
    dW = np.dot(dZ, A_prev.T) / m
    db = np.sum(dZ, axis=1, keepdims=True) / m
    dA_prev = np.dot(W.T, dZ)

    return dA_prev, dW, db


def activation_backward(dA, cache, activation):
    linear_cache, activation_cache = cache
    if activation == 'relu':
        dZ = relu_backward(dA, activation_cache)
        dA_prev, dW, db = linear_backward(dZ, linear_cache)
    elif activation == 'sigmoid':
        dZ = sigmoid_backward(dA, activation_cache)
        dA_prev, dW, db = linear_backward(dZ, linear_cache)

    return dA_prev, dW, db


def L_model_backward(AL, Y, caches):
    grads = {}
    L = len(caches)
    m = AL.shape[1]
    Y = Y.reshape(AL.shape)
    dAL = -(np.divide(Y, AL) - np.divide((1 - Y), (1 - AL)))

    current_cache = caches[L - 1]
    grads['dA'+str(L)], grads['dW'+str(L)], grads['db'+str(L)] = activation_backward(dAL, current_cache, 'sigmoid')

    for l in reversed(range(L - 1)):
        current_cache = caches[l]
        grads['dA'+str(l + 1)], grads['dW'+str(l + 1)], grads['db'+str(l + 1)] = activation_backward(grads['dA'+str(l + 2)], current_cache, 'relu')

    return grads


def up_parameters(parameters, grads, learning_rate):
    L = len(parameters) // 2
    for l in range(L):
        parameters['W'+str(l+1)] = parameters['W'+str(l+1)] - learning_rate * grads['dW'+str(l+1)]
        parameters['b'+str(l+1)] = parameters['b'+str(l+1)] - learning_rate * grads['db'+str(l+1)]
    return parameters


def L_model(X, Y, dims, learning_rate, num_iternations, print_cost=False, isPlot=False):
    parameters = initialize_parameters(dims)
    costs = []
    for i in range(num_iternations):
        AL, caches = L_model_forward(X, parameters)
        cost = cost_compute(AL, Y)
        grads = L_model_backward(AL, Y, caches)
        parameters = up_parameters(parameters, grads, learning_rate)

        if i % 100 == 0:
            costs.append(cost)
            if print_cost:
                print(&quot;第&quot;, i + 100, &quot;次迭代，成本值为:&quot;, np.squeeze(cost))

    if isPlot:
        plt.plot(np.squeeze(costs))
        plt.ylabel('cost')
        plt.xlabel('iterations (per tens)')
        plt.title(&quot;Learning rate =&quot; + str(learning_rate))
        plt.show()
    return parameters


def predict(X, Y, parameters):
    m = Y.shape[1]
    Y_predict = np.zeros((1, m))
    AL, caches = L_model_forward(X, parameters)

    for i in range(0, AL.shape[1]):
        if AL[0, i] &gt; 0.5:
            Y_predict[0, i] = 1
        else:
            Y_predict[0, i] = 0

    print(&quot;准确度为:&quot;, 100 - np.mean(np.abs(Y - Y_predict)) * 100, &quot;%&quot;)
    return Y_predict


dims = [12288, 20, 7, 5, 1]
parameters = L_model(train_set_x, train_set_y, dims, learning_rate=0.005, num_iternations=2000, print_cost=True, isPlot=True)

print('训练集准确度：')
Y_train_predict = predict(train_set_x, train_set_y, parameters)
print('~~~~~~~~~~~~~~~~~~')
print('测试集准确度：')
Y_test_predict = predict(test_set_x, test_set_y, parameters)
</code></pre>
<h3 id="训练结果">训练结果</h3>
<pre><code>第 100 次迭代，成本值为: 0.6994873707865432
第 200 次迭代，成本值为: 0.6806558525294543
第 300 次迭代，成本值为: 0.6705312328121265
第 400 次迭代，成本值为: 0.6619037949674021
第 500 次迭代，成本值为: 0.6536510177438547
第 600 次迭代，成本值为: 0.6446148155840906
第 700 次迭代，成本值为: 0.634667166888006
第 800 次迭代，成本值为: 0.6221946752377217
第 900 次迭代，成本值为: 0.6056921109383494
第 1000 次迭代，成本值为: 0.5842339799894992
第 1100 次迭代，成本值为: 0.5575090729216234
第 1200 次迭代，成本值为: 0.5265284524914055
第 1300 次迭代，成本值为: 0.4923067992292893
第 1400 次迭代，成本值为: 0.45628570738509455
第 1500 次迭代，成本值为: 0.419308167347863
第 1600 次迭代，成本值为: 0.38715877890532724
第 1700 次迭代，成本值为: 0.355732703783392
第 1800 次迭代，成本值为: 0.3352978704494966
第 1900 次迭代，成本值为: 0.30310463706295426
第 2000 次迭代，成本值为: 0.29058149758066887
训练集准确度：
准确度为: 97.12918660287082 %
~~~~~~~~~~~~~~~~~~
测试集准确度：
准确度为: 74.0 %
</code></pre>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/%E6%9C%80%E7%BB%88%E7%9A%84%E6%9B%B2%E7%BA%BF.png" alt=""></p>
<p>由于我们每次的参数都是随机初始化的，所以训练的每一次的结果都是不一样的，但是相比较上次使用logestic回归70%的准确度，这次的74%有一点点上升。(但是有的时候也有不好的情况- -)</p>
<h1 id="卷积神经网络">卷积神经网络</h1>
<p>卷积神经网络相比较全连接的神经网络，对图像更加友好。</p>
<ol>
<li>
<p>卷积神经网络中，最重要的就是卷积核(filter)，使用卷积核在图片上移动做卷积运算，得到新的矩阵</p>
</li>
<li>
<p>使用不同的卷积核，我们可以得到不同的边缘特征</p>
</li>
<li>
<p>卷积核中的每个数都是一个参数，我们需要做的就是通过神经网络去学习这些参数</p>
</li>
<li>
<p>卷积以后的维度 X =  (N - F) + 1，这样卷积以后有两个缺点：1、每次卷积完以后图像会缩小；2、图像的角落和边缘信息会丢失。为了解决这些问题，我们可以使用padding，在图像的边缘进行填充，这样卷积以后的维度为 X = (N + 2P - F) + 1。至于填充多少个像素，一般分为Valid 和 Same，Valid卷积不填充像素，Same卷积意味着卷积以后图片的大小不变，即 N = (N + 2P - F) + 1，此时，P = (F - 1)/2，所以卷积核的维度一般选择奇数，一方面可能是为了Padding，另一方面此时的卷积核会有一个中心点。</p>
</li>
<li>
<p>卷积核移动的步长也是一个参数，此时的输出维度 X = (N + 2P - F)/S + 1，【如果不是整数，向下取整】。</p>
</li>
<li>
<p>互相关和卷积：是否旋转镜像，但是对于卷积神经网络来说，我们把互相关的数学运算就叫做卷积</p>
</li>
<li>
<p>对一张图片来说，有三个通道，<code>而卷积核的通道数必须与图片的通道数一致</code>。比如图片是6 × 6 × 3，如果卷积核为 3 × 3 × 3，此时进行卷积时，每个通道分别卷积，然后将每个通道卷积后的结果相加，得到一个4 × 4 × 1的输出结果。这样用多个3 × 3 × 3的卷积核进行卷积，得到多个4 × 4的输出结果，相当于多个channels。</p>
</li>
<li>
<p>卷积以后得到4 × 4的输出结果，此时再加上偏差，相当于 Z = W*X + b，然后应用激活函数，A = g(Z)，最后把这些激活以后的结果堆叠在一起，进行下一层的卷积运算。这样做的好处就是极大的减少了参数的个数，避免过拟合。</p>
</li>
<li>
<p>除了卷积层，一般也经常使用池化层，来缩减模型大小，提高计算速度。池化层有两种方法，一种是Max Pooling，选取区域内的最大值，这样做可以解释为如果过滤器提取到了某个特征，那么保留其最大值。还有一种是Average Pooling，选取平均值，不过不是经常使用。池化层没有需要学习的参数，池化后通道数不会改变。池化层需要选择filter的大小和步长，一般都是取2，这种情况下会缩小一半。</p>
</li>
<li>
<p>卷积神经网络的优点：参数共享和稀疏连接</p>
</li>
</ol>
<h2 id="keras中定义卷积神经网络">Keras中定义卷积神经网络</h2>
<p>在Keras中，定义一个卷积神经网络是非常简单的：</p>
<pre><code>from lr_utils import load_dataset
from keras import optimizers
import matplotlib.pyplot as plt
from keras import models
from keras import layers

train_set_x, train_set_y, test_set_x, test_set_y, classes = load_dataset()

train_set_x = train_set_x / 255
test_set_x = test_set_x / 255

train_set_y = train_set_y.T
test_set_y = test_set_y.T

model = models.Sequential()
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.Flatten())
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))

model.compile(optimizer=optimizers.sgd(lr=0.005),
              loss='binary_crossentropy',
              metrics=['accuracy'])


history = model.fit(train_set_x, train_set_y, epochs=2000, batch_size=209)
train_loss, train_acc = model.evaluate(train_set_x, train_set_y)
test_loss, test_acc = model.evaluate(test_set_x, test_set_y)

print('train_loss', train_loss, 'train_acc', train_acc)
print('test_loss', test_loss, 'test_acc', test_acc)

history_dict = history.history

loss_values = history_dict['loss']
epochs = range(1, len(loss_values) + 1)
plt.plot(epochs, loss_values, 'b', label='Train loss')
plt.title('Training loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.show()

</code></pre>
<p>具体的结构是跟书上的例子一模一样，可以看一些这个卷积神经网络的结构：</p>
<pre><code>Using TensorFlow backend.
_________________________________________________________________
Layer (type)                 Output Shape              Param #
=================================================================
conv2d_1 (Conv2D)            (None, 62, 62, 32)        896
_________________________________________________________________
max_pooling2d_1 (MaxPooling2 (None, 31, 31, 32)        0
_________________________________________________________________
conv2d_2 (Conv2D)            (None, 29, 29, 64)        18496
_________________________________________________________________
max_pooling2d_2 (MaxPooling2 (None, 14, 14, 64)        0
_________________________________________________________________
conv2d_3 (Conv2D)            (None, 12, 12, 64)        36928
_________________________________________________________________
flatten_1 (Flatten)          (None, 9216)              0
_________________________________________________________________
dense_1 (Dense)              (None, 64)                589888
_________________________________________________________________
dense_2 (Dense)              (None, 1)                 65
=================================================================
Total params: 646,273
Trainable params: 646,273
Non-trainable params: 0
</code></pre>
<p>这是它的训练结果，讲道理测试集准确度竟然达到了84%，不过损失函数曲线有点不稳定：</p>
<pre><code>train_loss 0.17385125616520786 train_acc 0.93779904391777
test_loss 0.5197753620147705 test_acc 0.8399999928474426
</code></pre>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/keras_cat.png" alt=""></p>
<p>后面会尝试K-折交叉验证或者加入正则项。</p>
<blockquote>
<blockquote>
<blockquote>
<p>待续</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[神经网络与深度学习-第二周作业]]></title>
        <id>https://tudouvvv.github.io//post/神经网络与深度学习-第二周作业</id>
        <link href="https://tudouvvv.github.io//post/神经网络与深度学习-第二周作业">
        </link>
        <updated>2018-10-19T05:13:35.000Z</updated>
        <content type="html"><![CDATA[<p>学习了本周的内容，对于logistic回归和梯度下降法有了一定的了解，恰好有作业可以把学习的内容串联起来，于是动手写一下，学习过程中遇到了很多问题，感谢阿毛的友情帮助。<br>
参考文章：<a href="https://github.com/Kulbear/deep-learning-coursera/blob/master/Neural%20Networks%20and%20Deep%20Learning/Logistic%20Regression%20with%20a%20Neural%20Network%20mindset.ipynb">Logistic Regression with a Neural Network mindset</a></p>
<h1 id="目标识别图片中有没有猫">目标：识别图片中有没有猫</h1>
<h1 id="步骤">步骤：</h1>
<h2 id="1-准备工作">1、准备工作</h2>
<p>下载了相关文件(数据集)，训练集共有209张图片，测试集50张图片<br>
分类方法：有猫为1，没有猫为0<br>
导入相关的包:</p>
<pre><code class="language-python">import numpy as np
import h5py
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
</code></pre>
<h2 id="2-数据处理">2、数据处理</h2>
<pre><code class="language-python">def load_dataset():
    train_dataset = h5py.File('datasets/train_catvnoncat.h5', &quot;r&quot;) # h5py读取文件，要加r
    train_set_x_orig = np.array(train_dataset[&quot;train_set_x&quot;][:]) # 训练集数据
    train_set_y_orig = np.array(train_dataset[&quot;train_set_y&quot;][:]) # 训练集标签

    test_dataset = h5py.File('datasets/test_catvnoncat.h5', &quot;r&quot;)
    test_set_x_orig = np.array(test_dataset[&quot;test_set_x&quot;][:]) # 测试集数据
    test_set_y_orig = np.array(test_dataset[&quot;test_set_y&quot;][:]) # 测试集标签

    classes = np.array(test_dataset[&quot;list_classes&quot;][:]) # the list of classes

    train_set_y_orig = train_set_y_orig.reshape((1, train_set_y_orig.shape[0]))
    test_set_y_orig = test_set_y_orig.reshape((1, test_set_y_orig.shape[0]))

    return train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes


train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()
</code></pre>
<p>这一部分代码是资料中给的，主要作用是从数据集中读取数据，直接拿来用就好。</p>
<p>我们可以看一下训练集中第88张图片的信息以及图片到底是什么样的：</p>
<pre><code class="language-python">train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()

index = 88
img = train_set_x_orig[index]
print(img.shape)
plt.imshow(img)
plt.show()

&gt;&gt;&gt; (64, 64, 3)
</code></pre>
<p>img储存的是图片信息，计算机要保存一张照片，要保存为三个独立矩阵，因为图片的像素是由三原色(R,G,B)构成的，每个矩阵保存着每个单原色在各像素处的亮度，所以img是一个维度为(64, 64, 3)的数组。</p>
<p>我们可以使用<code>matplotlib</code>这个包的<code>image</code>模块下的<code>imshow</code>函数来对图片信息进行&quot;编译&quot;,输出图片具体的样子，后面要加<code>plt.show()</code>来显示图片：</p>
<center>![](https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-10-19-88%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF.png)</center>
<p>编写代码来输出本次模拟的相关信息：</p>
<pre><code class="language-python">
number_train = train_set_y.shape[1]
number_test = test_set_y.shape[1]
number_px = train_set_x_orig.shape[1]

print(&quot;训练集图片的数量:&quot;, number_train)
print(&quot;测试集图片的数量:&quot;, number_test)
print(&quot;每张图片的大小:&quot;, number_px, &quot;*&quot;, number_px)
print(&quot;训练集数据的维数:&quot;, train_set_x_orig.shape)
print(&quot;训练集标签的维数:&quot;, train_set_y.shape)
print(&quot;测试集数据的维数:&quot;, test_set_x_orig.shape)
print(&quot;测试集标签的维数:&quot;, test_set_y.shape)

&gt;&gt;&gt;

训练集图片的数量: 209
测试集图片的数量: 50
每张图片的大小: 64 * 64
训练集数据的维数: (209, 64, 64, 3)
训练集标签的维数: (1, 209)
测试集数据的维数: (50, 64, 64, 3)
测试集标签的维数: (1, 50)
</code></pre>
<p>由于图片的维度是一个(64, 64, 3)的numpy数组，为了训练的方便，我们需要把一张图片上的信息整合到一起，即构造成一个(64*64*3, 1）的列向量，然后把所有的图片信息放在一个数组中，每一列储存着一张照片的信息。也就是要把训练集和数据集中的数据进行降维处理:</p>
<pre><code class="language-python">train_x_con = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T
test_x_con = test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T
print(&quot;降维后训练集数据的维数:&quot;, train_x_con.shape)
print(&quot;降维后测试集数据的维数:&quot;, test_x_con.shape)

&gt;&gt;&gt; 降维后训练集数据的维数: (12288, 209)
    降维后测试集数据的维数: (12288, 50)
</code></pre>
<p><code>reshape()</code>可以对数组进行重新构造，以训练集的数据为例，由于共有209张图片，所以我们需要得到一个列为209的数组，但是由于数据量太大，我们并不知道有多少行，<code>reshape()</code>方法中有一个机制，即输入负数，它会帮我们算好行数，所以我们可以这样设置 <code>train_x_con = train_set_x_orig.reshape(-1, train_set_x_orig.shape[0])</code>，或者我们设置行数为209，最后加<code>.T</code>转置数列即可：<code>train_x_con = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T</code>。</p>
<p>以前做毕设的时候有对数据进行归一化处理，因为是不同特征的数字，属于奇异样本数据，归一化以后消除不同数据量纲数字大小的影响，加快学习的速度。而在机器学习中，对数据进行标准化也是很重要的，在图片数据集中，由于每个像素点的信息最大为255，所以可以对所有数除以255，让数据集数据位于[0, 1]之间：</p>
<pre><code class="language-python">train_set_x = train_x_con /255
test_set_x = test_x_con /255
</code></pre>
<h2 id="3-记录思路">3、记录思路</h2>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-10-19-LogReg_kiank.png" alt=""></p>
<p>我们所需要用到的算法和函数：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-10-19-%E5%85%AC%E5%BC%8F.png" alt=""></p>
<p>我们需要做的：</p>
<ul>
<li>1、初始化变量w,b</li>
<li>2、前向传播得到概率和成本值J</li>
<li>3、反向传播来得到成本值对w和b的导数</li>
<li>4、通过梯度下降法来更新变量w和b</li>
<li>5、重复步骤2、3、4</li>
</ul>
<h2 id="4-go">4、Go！</h2>
<pre><code class="language-python">def init_variable(dim):
    w = np.zeros((dim, 1))
    b = 0
    return w, b

def sigmoid(z):
    s = 1 / (1 + np.exp(-z))
    return s
</code></pre>
<p>定义函数初始化变量w,b，w是每个输入特征的所占权重，所以应该是一个<code>(64*64*3， 1)</code>的列向量<br>
定义前向传播函数Sigmoid的一般形式，输入参数z可以是一个numpy数组</p>
<p>这样，初始化工作已经完成，可以开始进行学习操作了，定义传播函数propagate得到成本值以及w和b的梯度：</p>
<pre><code class="language-python">def propagate(w, b, X, Y):
    m = X.shape[1]
    
    # 前向传播
    A = sigmoid(np.dot(w.T, X) + b)
    cost = (-1 / m) * np.sum(Y * np.log(A) + (1 - Y) * np.log(1 - A))
    
    # 反向传播
    dw = (1 / m) * np.dot(X, (A - Y).T)
    db = (1 / m) * np.sum(A - Y)

    reci = {
        &quot;dw&quot;: dw,
        &quot;db&quot;: db
    }

    return  reci, cost
</code></pre>
<p>上面用到的公式都是视频中推导过的，<code>np.dot()</code>可以完成两个矩阵的乘法，<code>np.sum()</code>可以进行累加操作。</p>
<p>接下来定义梯度下降函数optimize来进行迭代，即通过最小化成本J来更新 w 和 b：</p>
<pre><code class="language-python">def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost= False):
    costs = []
    for i in range(num_iterations):
        reci, cost = propagate(w, b, X, Y)
        dw = reci[&quot;dw&quot;]
        db = reci[&quot;db&quot;]
        
        w = w - learning_rate * dw
        b = b - learning_rate * db
        
        if i % 100 == 0:
            costs.append(cost)
        if (print_cost) and (i % 100 == 0):
            print(&quot;迭代次数:%d , 误差值: %f&quot;  %(i, cost))

    params = {
        &quot;w&quot;: w,
        &quot;b&quot;: b
    }
    return params, costs
</code></pre>
<p>这里模仿参考文章，每迭代100次输出此时误差值。通过不断地迭代就完成了整个学习过程，设置迭代次数<code>num_iterations</code>可以决定迭代的次数，最后存储迭代结束的变量 w 和 b 用来进行预测。</p>
<p>预测函数predict的主要作用就是通过学习得到变量w和b进行预测得到概率，当概率大于0.5时，我们认为这张图片中有猫，设置标签值为1，当概率小于0.5时，我们认为图片中没有猫，设置标签值为0，最后将所有的标签值进行存储用来进行准确度的比较：</p>
<pre><code class="language-python">def predict(X, Y, w, b):
    m = X.shape[1]
    Y_prediction = np.zeros((1, m))
    w = w.reshape(X.shape[0], 1)

    A = sigmoid(np.dot(w.T, X) + b)

    for i in range(m):
        Y_prediction[0, i] = 1 if A[0, i] &gt; 0.5 else 0

    return Y_prediction
</code></pre>
<p>最后设置main函数来调动所有的‘模块’，并通过对 训练集 和 测试集  正确标签值的比较得到本次学习过程的准确程度，将本次训练后的参数进行保存：</p>
<pre><code class="language-python">def main(X_train, Y_train, X_test, Y_test, num_iterations, learning_rate, print_cost):
    w, b = init_variable(X_train.shape[0])   # 初始化变量
    params, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost)  # 进行学习过程
    w, b = params[&quot;w&quot;], params[&quot;b&quot;]      # 得到学习后的变量

    Y_train_prediction = predict(X_train, Y_train, w, b)  # 对训练集数据进行预测
    Y_test_prediction = predict(X_test, Y_test, w, b)    # 对测试集数据进行预测

    print(&quot;训练集准确度:&quot;, 100 - np.mean(np.abs(Y_train - Y_train_prediction)) * 100, &quot;%&quot;)  # 得到训练集准确度
    print(&quot;测试集准确度:&quot;, 100 - np.mean(np.abs(Y_test - Y_test_prediction)) * 100, &quot;%&quot;)   # 得到测试集准确度

    data = {
            &quot;costs&quot; : costs,
            &quot;Y_prediction_test&quot; : Y_test_prediction,
            &quot;Y_prediciton_train&quot; : Y_train_prediction,
            &quot;w&quot; : w,
            &quot;b&quot; : b,
            &quot;learning_rate&quot; : learning_rate,
            &quot;num_iterations&quot; : num_iterations }
    return data          # 保存相关参数
</code></pre>
<h2 id="5-完整代码">5、完整代码</h2>
<pre><code>import numpy as np
import h5py
import matplotlib.pyplot as plt

def load_dataset():
    train_dataset = h5py.File('datasets/train_catvnoncat.h5', &quot;r&quot;)
    train_set_x_orig = np.array(train_dataset[&quot;train_set_x&quot;][:]) # your train set features
    train_set_y_orig = np.array(train_dataset[&quot;train_set_y&quot;][:]) # your train set labels

    test_dataset = h5py.File('datasets/test_catvnoncat.h5', &quot;r&quot;)
    test_set_x_orig = np.array(test_dataset[&quot;test_set_x&quot;][:]) # your test set features
    test_set_y_orig = np.array(test_dataset[&quot;test_set_y&quot;][:]) # your test set labels

    classes = np.array(test_dataset[&quot;list_classes&quot;][:]) # the list of classes

    train_set_y_orig = train_set_y_orig.reshape((1, train_set_y_orig.shape[0]))
    test_set_y_orig = test_set_y_orig.reshape((1, test_set_y_orig.shape[0]))

    return train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes


train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()
# index = 88
# img = train_set_x_orig[index]
# print(img)
# plt.imshow(img)
# plt.show()

number_train = train_set_y.shape[1]
number_test = test_set_y.shape[1]
number_px = train_set_x_orig.shape[1]

print(&quot;训练集图片的数量:&quot;, number_train)
print(&quot;测试集图片的数量:&quot;, number_test)
print(&quot;每张图片的大小:&quot;, number_px, &quot;*&quot;, number_px)
print(&quot;训练集数据的维数:&quot;, train_set_x_orig.shape)
print(&quot;训练集标签的维数:&quot;, train_set_y.shape)
print(&quot;测试集数据的维数:&quot;, test_set_x_orig.shape)
print(&quot;测试集标签的维数:&quot;, test_set_y.shape)

train_x_con = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T
test_x_con = test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T
print(&quot;降维后训练集数据的维数:&quot;, train_x_con.shape)
print(&quot;降维后测试集数据的维数:&quot;, test_x_con.shape)

train_set_x = train_x_con /255
test_set_x = test_x_con /255


def sigmoid(z):
    s = 1 / (1 + np.exp(-z))
    return s


def init_variable(dim):
    w = np.zeros((dim, 1))
    b = 0
    return w, b


def propagate(w, b, X, Y):
    m = X.shape[1]

    # 前向传播
    A = sigmoid(np.dot(w.T, X) + b)
    cost = (-1 / m) * np.sum(Y * np.log(A) + (1 - Y) * np.log(1 - A))

    # 反向传播
    dw = (1 / m) * np.dot(X, (A - Y).T)
    db = (1 / m) * np.sum(A - Y)

    reci = {
        &quot;dw&quot;: dw,
        &quot;db&quot;: db
    }

    return  reci, cost


def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost= False):
    costs = []
    for i in range(num_iterations):
        reci, cost = propagate(w, b, X, Y)
        dw = reci[&quot;dw&quot;]
        db = reci[&quot;db&quot;]
        w = w - learning_rate * dw
        b = b - learning_rate * db
        if i % 100 == 0:
            costs.append(cost)
        if (print_cost) and (i % 100 == 0):
            print(&quot;迭代次数:%d , 误差值: %f&quot;  %(i, cost))

    params = {
        &quot;w&quot;: w,
        &quot;b&quot;: b
    }
    return params, costs


def predict(X, Y, w, b):
    m = X.shape[1]
    Y_prediction = np.zeros((1, m))
    w = w.reshape(X.shape[0], 1)

    A = sigmoid(np.dot(w.T, X) + b)

    for i in range(m):
        Y_prediction[0, i] = 1 if A[0, i] &gt; 0.5 else 0

    return Y_prediction


def main(X_train, Y_train, X_test, Y_test, num_iterations, learning_rate, print_cost):
    w, b = init_variable(X_train.shape[0])
    params, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost)
    w, b = params[&quot;w&quot;], params[&quot;b&quot;]

    Y_train_prediction = predict(X_train, Y_train, w, b)
    Y_test_prediction = predict(X_test, Y_test, w, b)

    print(&quot;训练集准确度:&quot;, 100 - np.mean(np.abs(Y_train - Y_train_prediction)) * 100, &quot;%&quot;)
    print(&quot;测试集准确度:&quot;, 100 - np.mean(np.abs(Y_test - Y_test_prediction)) * 100, &quot;%&quot;)

    data = {
            &quot;costs&quot; : costs,
            &quot;Y_prediction_test&quot; : Y_test_prediction,
            &quot;Y_prediciton_train&quot; : Y_train_prediction,
            &quot;w&quot; : w,
            &quot;b&quot; : b,
            &quot;learning_rate&quot; : learning_rate,
            &quot;num_iterations&quot; : num_iterations }
    return data

if __name__ == &quot;__main__&quot;:
    data = main(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations=2000, learning_rate=0.005, print_cost=True)
</code></pre>
<h2 id="运行结果">运行结果：</h2>
<pre><code class="language-python">训练集图片的数量: 209
测试集图片的数量: 50
每张图片的大小: 64 * 64
训练集数据的维数: (209, 64, 64, 3)
训练集标签的维数: (1, 209)
测试集数据的维数: (50, 64, 64, 3)
测试集标签的维数: (1, 50)
降维后训练集数据的维数: (12288, 209)
降维后测试集数据的维数: (12288, 50)
迭代次数:0 , 误差值: 0.693147
迭代次数:100 , 误差值: 0.584508
迭代次数:200 , 误差值: 0.466949
迭代次数:300 , 误差值: 0.376007
迭代次数:400 , 误差值: 0.331463
迭代次数:500 , 误差值: 0.303273
迭代次数:600 , 误差值: 0.279880
迭代次数:700 , 误差值: 0.260042
迭代次数:800 , 误差值: 0.242941
迭代次数:900 , 误差值: 0.228004
迭代次数:1000 , 误差值: 0.214820
迭代次数:1100 , 误差值: 0.203078
迭代次数:1200 , 误差值: 0.192544
迭代次数:1300 , 误差值: 0.183033
迭代次数:1400 , 误差值: 0.174399
迭代次数:1500 , 误差值: 0.166521
迭代次数:1600 , 误差值: 0.159305
迭代次数:1700 , 误差值: 0.152667
迭代次数:1800 , 误差值: 0.146542
迭代次数:1900 , 误差值: 0.140872
训练集准确度: 99.04306220095694 %
测试集准确度: 70.0 %
</code></pre>
<p>6、<br>
<code>learning_rate</code>是我们的学习率α，选择学习率也是很重要的，它是我们更新变量的速率，如果太大，那么我们会错过最优解，太小的话又需要增加迭代次数，但是目前我还不知道合理的范围是什么，代码中设置的<code>0.005</code>是参考文章中给的，我自己尝试设置为0.5发现会出错，这方面后续会继续学习。</p>
<p>我们可以画图来看一下本次的成本曲线：</p>
<pre><code class="language-python"># 画图
costs = data['costs']
plt.plot(costs)
plt.ylabel('cost')
plt.xlabel('iterations (per hundreds)')
plt.title(&quot;Learning rate =&quot; + str(data[&quot;learning_rate&quot;]))
plt.show()
</code></pre>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-10-19-%E6%88%90%E6%9C%AC%E6%9B%B2%E7%BA%BFpng.png" alt=""><br>
可以看到伴随着迭代次数的增加，成本值在下降。</p>
<p>我们可以自己找一下图片，设置为64*64的，来测试一下这个的准确度：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-10-19-8_test.png" alt=""><br>
找了8张图片，分别编号1--8，通过上面的predict函数来进行预测结果：</p>
<pre><code class="language-python">import matplotlib.image as mpimg  # 在开始处导入，主要作用是读取图片信息
    
    img1 = mpimg.imread(&quot;test/1.jpg&quot;).reshape(-1, 1)
    img2 = mpimg.imread(&quot;test/2.jpg&quot;).reshape(-1, 1)
    img3 = mpimg.imread(&quot;test/3.jpg&quot;).reshape(-1, 1)
    img4 = mpimg.imread(&quot;test/4.jpg&quot;).reshape(-1, 1)
    img5 = mpimg.imread(&quot;test/5.jpg&quot;).reshape(-1, 1)
    img6 = mpimg.imread(&quot;test/6.png&quot;).reshape(-1, 1)
    img7 = mpimg.imread(&quot;test/7.png&quot;).reshape(-1, 1)
    img8 = mpimg.imread(&quot;test/8.jpg&quot;).reshape(-1, 1)

    img = np.hstack((img1, img2, img3, img4, img5, img6, img7, img8))   # np.hstack()主要进行拼接矩阵的作用

    w = data[&quot;w&quot;]
    b = data[&quot;b&quot;]

    Y_prediction = predict(img, w, b)
    Y_prediction = np.squeeze(Y_prediction)     # np.squeeze()主要进行矩阵降维的作用
    for i in range(len(Y_prediction)):
        if Y_prediction[i] == 1:
            print(&quot;第%i张图片中有猫&quot; %(i+1))
        else:
            print(&quot;第%i张图片中没有猫&quot; %(i+1))
</code></pre>
<p>预测结果：</p>
<pre><code class="language-python">第1张图片中有猫
第2张图片中有猫
第3张图片中有猫
第4张图片中有猫
第5张图片中没有猫
第6张图片中有猫
第7张图片中没有猫
第8张图片中没有猫
</code></pre>
<center>以上!</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python数据库学习]]></title>
        <id>https://tudouvvv.github.io//post/Python数据库学习</id>
        <link href="https://tudouvvv.github.io//post/Python数据库学习">
        </link>
        <updated>2018-09-26T05:25:44.000Z</updated>
        <summary type="html"><![CDATA[<center>程序员进阶之道👆</center>]]></summary>
        <content type="html"><![CDATA[<center>程序员进阶之道👆</center>
<!--more-->
准备学习一些 进阶的知识，刚好看到这个课程，开一篇记录一下学习笔记！  
<p>数据库，即存储数据的仓库，现在一般分为关系型数据库和非关系型数据库。</p>
<h1 id="centermysqlcenter"><center>MySQL</center></h1>
<h1 id="1-在终端使用">1、在终端使用</h1>
<p>首先学习了一些mysql的命令：</p>
<ul>
<li>在终端中登录MySQL：<code>mysql -u root -p</code></li>
<li><code>mysql -V</code>  :输出版本信息并且退出</li>
<li><code>mysql -u</code>  :用户名</li>
<li><code>mysql -p</code> :密码  回车后可以隐藏登录</li>
<li><code>mysql -P</code> :端口号   默认3306，可不加</li>
<li><code>mysql -h</code> :服务器名称  本地使用，默认127.0.0.1</li>
<li>退出  :<code>exit；quit；\q；</code></li>
<li>修改提示符(暂时还不知道有什么用)：<code>prompt xxx</code><br>
常用提示符：<code>\D--&gt;完整的日期 \d--&gt;当前数据库 \h--&gt;服务器名称 \u--&gt;当前用户</code></li>
</ul>
<p>MySQL语句的规范：</p>
<ul>
<li>关键字与函数名称全部大写</li>
<li>数据库名称、表名称、字段名称全部小写</li>
<li>SQL语句必须以分号结尾</li>
</ul>
<p>其它命令：</p>
<ul>
<li>显示当前服务器版本:<code>SELECT VERSION();</code></li>
<li>显示当前日期时间:<code>SELECT NOW();</code></li>
<li>显示当前用户:<code>SELECT USER();</code></li>
<li>显示当前数据库:<code>SELECT DATABASE() ;</code></li>
</ul>
<p>————————————————————————————</p>
<h1 id="2-操作数据库">2、操作数据库</h1>
<p>(Ps.<code>{}必须输入 [] 选择输入</code>)</p>
<h2 id="1-创建数据库">1、创建数据库:</h2>
<pre><code>CREATE {DATABASE | SCHEME}  [IF NOT EXISTS] db_name;
</code></pre>
<h2 id="2-设置编码方式">2、设置编码方式:</h2>
<pre><code>[DEFAULT] CHARACTER SET [=] charset_name;
</code></pre>
<h2 id="3-查看warings">3、查看Warings:</h2>
<pre><code>SHOW WARINIGS;
</code></pre>
<h2 id="4-查看创建数据库时的编码方式">4、查看创建数据库时的编码方式:</h2>
<pre><code>SHOW CREATE DATABASE db_name;
</code></pre>
<h2 id="5-查看当前服务器下的数据库列表">5、查看当前服务器下的数据库列表:</h2>
<pre><code>SHOW {DATABASES | SCHEMES};
</code></pre>
<h2 id="6-修改数据库">6、修改数据库:</h2>
<pre><code>ALTER {DATABASE | SCHEME} [db_name]  
[DEFAULT] CHARACTER SET [=] charset_name；
</code></pre>
<h2 id="7-删除数据库">7、删除数据库:</h2>
<pre><code>DROP {DATABASE | SCHEME} [IF EXISTS] db_name;
</code></pre>
<p>————————————————————————————</p>
<h1 id="3-数据类型">3、数据类型</h1>
<ul>
<li>数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型。</li>
<li>MySQL中定义数据字段的类型对数据库的优化是非常重要的。</li>
<li>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-%E7%B1%BB%E5%9E%8B.png" alt=""><br>
<code>UNSIGNED</code>表示无符号，一般放在数据类型的后面<br>
————————————————————————————</p>
<h1 id="4-数据表">4、数据表</h1>
<p>数据表是数据库的最重要的组成部分之一，是其它对象的基础。</p>
<h2 id="1-使用数据库">1、使用数据库:</h2>
<pre><code>USE db_name;
</code></pre>
<h2 id="2-创建数据表">2、创建数据表:</h2>
<pre><code>CREATE TABLE [IF NOT EXISTS] table_name(
Column_name(列名称） data_type(数据类型) .... ,
...
);
</code></pre>
<center>实例：👇</center>
<center>![](https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8.png)</center>
## 3、查询数据表列表:
```
SHOW TABLES [FROM db_name]
[LIKE 'pattern' | WHERE expr]
```
## 4、查看数据表结构:
```
SHOW COLUMNS FROM tb_name;
```
## 5、数据插入:
```
INSERT [INTO] tbl_name [( col_name,…)] VALUES(VAL,…);
```
## 6、修改数据:
```
UPDATE table_references
SET col_name = expr1[, col_name2 = expr2…]
[WHERE where_definition];   --->很重要
```
## 7、删除数据:
```
DELETE FROM tbl_name
[WHERE where_defination];
```
<p>上面都是MySQL最基础的一些知识，再往后的会慢慢学习。<br>
————————————————————————————</p>
<h1 id="5-用python连接mysql数据库">5、用python连接mysql数据库</h1>
<h2 id="1-mysqldb学习">1、MySQLdb学习</h2>
<p>下载了MysqlDb这个包，因为之前创建了一个数据库并且添加了一些数据：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-news.png" alt=""><br>
所以会尝试连接这个数据库并对这个数据表做一些操作！！！开始用一个新包的话，官方文档有很详细的讲解 。</p>
<p>MySQLdb提供了<code>connect</code>方法来建立一个与数据库的连接，调用这个对象的<code>close</code>方法来关闭一个连接。通过这个连接可以创建出一个游标对象<code>cursor</code>，通过游标对象执行SQL语句来进行数据的增删查改。</p>
<pre><code class="language-python">import MySQLdb
try:
    coon = MySQLdb.connect(
        host='localhost',
        user='root',
        passwd='手动打码处理',
        db='news',
        port=3306,
        charset='utf8'
    )
    cursor = coon.cursor()
    cursor.execute('SELECT * FROM news;')
    rest = cursor.fetchone()
    cursor.close()
    coon.close()
    print(rest)
except MySQLdb.Error as e:
    print('Error: %s' % e)

&gt;&gt;&gt; (1, '丰收节后第二天 习近平考察了这个地方', 'xl', '9月25日，习近平抵达中国“最早迎接太阳的垦区', 1, datetime.datetime(2018, 9, 26, 11, 14, 44), None, '百家')
</code></pre>
<p>刚开始运行的时候总会报错，所以用了一个<code>try</code>语句来捕获错误：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-2029%E9%94%99%E8%AF%AF.png" alt=""><br>
查询后得知这是因为在MySQL8.0改变了认证方式，目前最新的MySQL8.0对用户密码的加密方式为<code>caching_sha2_password</code>, 可能MySQLdb还不支持，所以需要更改为老版本的认证方式<code>mysql_native_password</code>,更改方式：</p>
<pre><code>mysql -u root -p  \登录mysql
use mysql;           
select user,plugin from user where user='root';     \执行命令查看加密方式
alter user 'root'@'localhost' identified with mysql_native_password by 'yourpassword' \执行命令修改加密方式
flush privileges                  \属性权限使配置生效
</code></pre>
<p>反正最后成功解决错误，连接到了本地数据库输出了第一条数据(因为用了<code>fetchone</code>命令)，但是可以看到输出的结果是一个元组，可能会不清楚里面各个元素的含义是什么，要是想建立一种映射关系，我们需要用到<code>cursor</code>的<code>description</code>方法来查看每个字段的查询名，然后把执行sql后的结果与执行<code>cursor.description()</code>后的结果拼成一个字典：</p>
<pre><code class="language-python">    def get_one(self):
        # 准备sql
        sql = 'SELECT * FROM news WHERE news_type = %s ORDER BY create_at DESC'
        # 找到cursor
        cursor = self.conn.cursor()
        # 执行sql
        cursor.execute(sql, ('百家',))
        print(cursor.description)
        # 拿到结果
        rest = dict(zip([k[0] for k in cursor.description], cursor.fetchone()))
        # 处理数据
        print(rest)
        print(rest['title'])
        # 关闭连接，cursor
        cursor.close()
        self.close_conn()
        return rest
&gt;&gt;&gt; (('id', 2, 1, 6, 6, 0, 0), ('title', 253, 71, 600, 600, 0, 0), ('img_url', 253, 2, 600, 600, 0, 0), ('content', 253, 133, 6000, 6000, 0, 0), ('is_valid', 1, 1, 4, 4, 0, 1), ('create_at', 12, 19, 19, 19, 0, 1), ('updated_at', 12, 0, 19, 19, 0, 1), ('news_type', 253, 6, 600, 600, 0, 1))
{'id': 9, 'title': '男子3个月竟&quot;用&quot;水11吨:家中半年没人 水表自己转', 'img_url': 'xl', 'content': '近日，郑州市民刘先生向河南商报记者反映，空空如也的房子，水表却自己转起来，诡异不已。', 'is_valid': 1, 'create_at': datetime.datetime(2018, 9, 26, 11, 21, 59), 'updated_at': None, 'news_type': '百家'}
男子3个月竟&quot;用&quot;水11吨:家中半年没人 水表自己转
</code></pre>
<p>看到执行<code>cursor.description()</code>后的结果是字段的查询名和一串不知道什么意思的数字😰，第一次用了<code>zip()</code>和<code>dict()</code>两个方法，zip()可以把两个元组的对应元素一一打包，返回一个zip对象，而dict可以把两个元素组合起来变成一个字典：</p>
<pre><code class="language-python">a = (1, 2, 3, 4)
b = ('a', 'b', 'c', 'd')
print(type(zip(a, b)))
print(zip(a, b))
print(dict(zip(a, b)))

r = ((1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'))
print(dict(r))

&gt;&gt;&gt; &lt;class 'zip'&gt;
    &lt;zip object at 0x000001F4AADEDC88&gt;
    {1: 'a', 2: 'b', 3: 'c', 4: 'd'}
    {1: 'a', 2: 'b', 3: 'c', 4: 'd'}
</code></pre>
<p>还以通过<code>fetchall()</code>的方法获得多个数据库数据，关键是要看你的sql语句怎么写。</p>
<p>我们可以在sql语句中用<code>%s</code>，这是一种字符串格式化的语法，基本用法是将值插入到%s占位符的字符串中。</p>
<p>并且可以通过写sql语句和<code>commit()</code>来添加数据：</p>
<pre><code class="language-python"> def add(self):
        try:
            # 准备sql
            sql = ('INSERT INTO news (title, img_url, content, is_valid, \
                   news_type) VALUES'
                   '(%s,%s,%s,%s,%s);')
            # 获取连接和cursor
            cursor = self.conn.cursor()
            # 执行sql
            # # 提交数据到数据库
            cursor.execute(sql, ('标题1', 'xl', '内容', 1, '国际'))
            cursor.execute(sql, ('标题2', 'xl', '内容', '你好', '国际', '123'))
            # 提交事务
            self.conn.commit()    # commit的作用是把缓存中的数据存入我们的数据库中
            # 关闭cursor和连接
            cursor.close()
        except:
            print('Error')
            self.conn.commit()  # 只会提交成功的数据，失败的不会提交
            # self.conn.rollback() # 如果提交的数据中出现一个错误，那么都不会被提交到数据库
        self.conn.close()
</code></pre>
<p>在添加数据时一定要注意我们设定的数据表每个字段的类型，不能出错。</p>
<p>完整代码：</p>
<pre><code class="language-python">import MySQLdb


class MysqlSearch():

    def __init__(self):
        self.get_conn()

    def get_conn(self):
        try:
            self.conn = MySQLdb.connect(
                host='127.0.0.1',
                user='root',
                passwd='mysql,,2012',
                db='news',
                port=3306,
                charset='utf8'
            )
        except MySQLdb.Error as e:
            print('Error:%s' % e)

    def close_conn(self):
        try:
            if self.conn:
                self.conn.close()
        except MySQLdb.Error as e:
            print('Error:%s' % e)

    def get_one(self):
        # 准备sql
        sql = 'SELECT * FROM news WHERE news_type = %s ORDER BY create_at DESC'
        # 找到cursor
        cursor = self.conn.cursor()
        # 执行sql
        cursor.execute(sql, ('百家',))
        print(cursor.description)
        # 拿到结果
        rest = dict(zip([k[0] for k in cursor.description], cursor.fetchone()))
        # 处理数据
        print(rest)
        print(rest['title'])
        # 关闭连接，cursor
        cursor.close()
        self.close_conn()
        return rest

    def get_more(self, page, page_size):
        offset = (page - 1) * page_size
        # 准备sql
        sql = 'SELECT * FROM news WHERE news_type = %s ORDER BY create_at DESC\
               LIMIT %s,%s ;'
        # 找到cursor
        cursor = self.conn.cursor()
        # 执行sql
        cursor.execute(sql, ('百家', offset, page_size))
        # print(cursor.description)
        # 拿到结果
        rest = [dict(zip([k[0] for k in cursor.description], row))for row in
                cursor.fetchall()]
        # rest = cursor.fetchall()
        # 处理数
        # print(rest)
        # print(rest['title'])
        # 关闭连接，cursor
        cursor.close()
        self.close_conn()
        return rest      

    def add(self):
        try:
            # 准备sql
            sql = ('INSERT INTO news (title, img_url, content, is_valid, \
                   news_type) VALUES'
                   '(%s,%s,%s,%s,%s);')
            # 获取连接和cursor
            cursor = self.conn.cursor()
            # 执行sql
            # 提交数据到数据库
            cursor.execute(sql, ('标题8', 'xl', '内容', 1, '国际'))
            cursor.execute(sql, ('标题9', 'xl', '内容', '你好', '国际', '123'))
            # 提交事务
            self.conn.commit()    # commit的作用是把缓存中的数据存入我们的数据库中
            # 关闭cursor和连接
            cursor.close()
        except:
            print('Error')
            self.conn.commit()  # 只会提交成功的数据，失败的不会提交
            # self.conn.rollback() # 如果提交的数据中出现一个错误，那么都不会被提交到数据库
        self.close_conn()


def main():
    obj = MysqlSearch()
    # rest = obj.get_one()
    rest = obj.get_more(2, 2)
    print(rest)
    # for item in rest:
    #     print(item)
    #     print('-------')
    # obj.add()

if __name__ == '__main__':
    main()
</code></pre>
<h2 id="2-orm">2、ORM</h2>
<p>ORM：对象关系映射(Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换 。从效果上说，它其实是创建了一个可在编程语言里使用的--“虚拟对象数据库”。</p>
<p>这是百度百科里的介绍，在前面我们用mysqldb这个包的时候，它只是输出了数据库中的数据，我们还是用zip和description强行建立一种映射关系，并且还要写sql语句，而在ORM中，我们不需要关心这些东西，我们只要按照ORM的套路来就行。</p>
<p>常用的ORM实现方法有SqlObject、peewee、Django's ORM  、SQLAlchemy</p>
<h3 id="sqlalchemy学习">SQLAlchemy学习</h3>
<p><code>https://docs.sqlalchemy.org/en/latest/orm/</code>------&gt;官方文档地址<br>
在MySQL中不同字符类型在sqlalchemy中都有对应的类型与之匹配，比如VARCHAR对应String，INT对应Integer。</p>
<h4 id="创建一张表">创建一张表</h4>
<p>如果我们想在某个数据库中创建一个表，我们首先要用到<code>engine</code>来与数据库建立连接，接着继承<code>Base</code>这个基类中的方法来同我们的数据库进行映射，接着定义数据表的每个字段的类型，最后通过下图中的方法来创建数据表：<br>
<a href="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-py%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8.png"></a><br>
我们可以看到<code>Base.metadta.create_all(engine)</code>这条语句就相当于一条sql语句，编写代码来实验一下：</p>
<pre><code class="language-python">from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, DateTime, Boolean

# engine = create_engine('mysql://scott:tiger@localhost/foo') #官方给出的连接方法
# scott 用户名 triger 密码  foo数据库

engine = create_engine('mysql://root:手动打码此处的密码虽然没有什么卵用@localhost:3306/news_test')
Base = declarative_base()  # sqlalchemy定义的一个基类


class News(Base):
    __tablename__ = 'news'
    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    img_url = Column(String(200), nullable=False)
    content = Column(String(2000), nullable=False)
    is_valid = Column(Boolean)
    create_at = Column(DateTime)
    update_at = Column(DateTime)
    news_type = Column(String(20))
    
News.metadata.create_all(engine)
</code></pre>
<p>可以在图形化的mysql数据库中看到，已经成功的创建了一张数据表。<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-%E6%96%B0%E5%BB%BA%E4%B8%80%E5%BC%A0%E6%95%B0%E6%8D%AE%E8%A1%A8.png" alt=""></p>
<h4 id="新增数据">新增数据</h4>
<p>在前面学些mysqldb的时候，无论时新增数据还是删除数据，都需要借助一个游标来完成操作，而在sqlalchemy中，需要借助<code>session</code>：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-%E5%88%9B%E5%BB%BAsession.png" alt=""><br>
我们来试验一下：</p>
<pre><code class="language-python">class AddTest():
    def __init__(self):
        self.session = Session()

    def add(self):
        news_obj = News(
            title='标题1',
            img_url='xxx/xxx/xxx.jpg',
            content='内容1',
            create_at=datetime.datetime.now(),
            news_type='国际'
        )
        self.session.add(news_obj)
        self.session.commit()
        return news_obj
</code></pre>
<p>执行几次以后发现，数据已经被添加到数据库中了：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-26-%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE.png" alt=""></p>
<p>不过这里我有一点疑惑，因为在写sql语句的时候，我们要让id自增必须填入<code>AUTO_INCREMENT</code>再加主键约束才可以，不知道为什么在这里只需要标明是主键约束就可以了。<br>
添加多条数据时，我们可以填写多个<code>session.add()</code>语句，也可以使用<code>session.add_all()</code>语句进行添加：</p>
<pre><code class="language-python">self.session.add_all((news_obj1, news_obj2, news_obj3))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[猫眼电影TOP100爬取]]></title>
        <id>https://tudouvvv.github.io//post/猫眼电影TOP100爬取</id>
        <link href="https://tudouvvv.github.io//post/猫眼电影TOP100爬取">
        </link>
        <updated>2018-09-19T01:43:43.000Z</updated>
        <summary type="html"><![CDATA[<center>今天又是充满希望的一天</center>]]></summary>
        <content type="html"><![CDATA[<center>今天又是充满希望的一天</center>
<!--more-->
<p>昨天刚好看了怎么把爬下来的数据存储到excle中，所以用猫眼电影TOP100拿来练手，可惜，效果不佳：构想的太过美好，以为先把一页的写好，最后加入多页的机制就好。<br>
然后开始写爬取一页存储结果的代码，写完之后再加入爬取多页的代码，结果悲剧了，发现每次爬完一页后它存储结果的时候会把上次的结果给覆盖掉Σ(っ °Д °;)っ，找到了这个逻辑错误的地方，然后思考解决办法，纠结了半天不知道怎么修改，准备睡觉的时候灵机一动~~ 我干嘛存储的时候只存储一页啊，我为啥不设置一个空表，然后把每一页处理完的信息先存入总表，然后对总表再进行分析存储不就解决了吗。<br>
真的是太僵硬了Σ(っ °Д °;)っ<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E6%9D%8E%E5%85%89%E6%B4%99%E8%A1%A8%E6%83%85--%E4%B8%8D%E8%A1%8C%E5%95%8A.gif" alt=""></p>
<p>好吧下面是所有的操作流程。</p>
<h1 id="目的爬取猫眼电影top100的信息">目的：爬取猫眼电影TOP100的信息</h1>
<h1 id="分析过程">分析过程</h1>
<p>打开猫眼电影，找到	TOP100所在的网页(<code>http://maoyan.com/board/4</code>)<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E7%8C%AB%E7%9C%BCTOP100.png" alt="">)</p>
<p>每一页有十部电影，一共十页，打开开发者工具，查看我们要爬取的信息有哪些：</p>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7.png" alt=""><br>
OK，我们需要爬取电影海报链接，电影名，猫眼的ID编号，主演，上映时间，以及评分(我要吐槽一下这个评分，(╯‵□′)╯︵┻━┻为啥要分成两部分啊，好好的在一起不好吗)，每个电影的信息都在<code>&lt;dd&gt;&lt;/dd&gt;</code>这个节点中，然后开始写正则表达式来提取想要的信息(明明前几天才复习过正则表达式，一到用的时候就又忘记了，只能需要什么然后去翻笔记）：</p>
<pre><code class="language-python">import requests
import re
import xlsxwriter as xlw
import time


class Movie():
    root_pattern = '&lt;dd&gt;([\s\S]*?)&lt;/dd&gt;' # 每部电影的所有信息
    pic_pattern = '&lt;img data-src=&quot;(.*?)@160w_220h_1e_1c' #海报信息
    name_pattern = 'alt=&quot;(.*?)&quot; class=&quot;board-img&quot;'  # 名字信息
    id_pattern = 'data-val=&quot;{movieId:([\w]*?)}&quot;'   #编号信息
    star_pattern = '主演：([\s\S]*?)&lt;/p&gt;'     #主演信息
    date_pattern = '&lt;p class=&quot;releasetime&quot;&gt;上映时间：([\s\S]*?)&lt;/p&gt;' #时间信息
    score1_pattern = '&lt;i class=&quot;integer&quot;&gt;(\d\.)&lt;/i&gt;'  #评分信息
    score2_pattern = '&lt;i class=&quot;fraction&quot;&gt;(\d)&lt;/i&gt;'
</code></pre>
<p>定义了一个类来复习一下类的用法，虽然并没有什么作用....这部分代码主要是定义了爬取各项信息的正则表达式。</p>
<p>然后先爬取整个网页的信息，用了<code>requests</code>这个包，也是为了复习刚看到的知识:</p>
<pre><code class="language-python"> def __get(self, url):
        headers = {
                   'User-Agent': 'Mozilla/5.0(Macintosh;Intel Mac OS X 10_13_3) \
                   AppleWebKit/537.36(KHTML. like Gecko)\
                   Chrome/65.0.3325.162 Safari/536.36'
        }
        response = requests.get(url, headers=headers)
        htmls_source = response.text
        return htmls_source
</code></pre>
<p>这里只是简单了用了<code>request</code>的<code>get</code>方法来获取网页，添加了<code>headers</code>来进行伪装，不然就会提示<code>很抱歉，我们检测到您所在的网络环境存在恶意访问</code>的信息(尴尬)......</p>
<p>将网页的原始信息存储为<code>htmls_source</code>，然后对原始信息进行分析，也就是利用正则表达式来提取我们想要的信息：</p>
<pre><code class="language-python">def __analysis(self, htmls_source):
        htmls = re.findall(Movie.root_pattern, htmls_source)
        anchors = []
        for html in htmls:
            pic = re.findall(Movie.pic_pattern, html)
            name = re.findall(Movie.name_pattern, html)
            id = re.findall(Movie.id_pattern, html)[0]
            star = re.findall(Movie.star_pattern, html)
            date = re.findall(Movie.date_pattern, html)
            score1 = re.findall(Movie.score1_pattern, html)
            score2 = re.findall(Movie.score2_pattern, html)
            anchor = {'pic': pic, 'name': name, 'id': id, 'star': star,
                      'date': date, 'score1': score1, 'score2': score2}
            anchors.append(anchor)
        return anchors
</code></pre>
<p>首先利用<code>findall</code>方法和前面定义的父节点的正则表达式<code>root_pattern</code>来爬取单个电影的所有信息，存为一个列表<code>htmls</code>，每个电影的信息都是该列表中的一个元素<code>htmls[i]</code>，然后定义一个空表<code>anchors</code>准备存放爬取的信息，接着对于单个电影的信息<code>html</code>进行正则提取，提取以后存为一个字典命名为<code>anchor</code>并使用<code>append()</code>增加元素的方法将该字典存到我们刚才定义的空表<code>anchors</code>中。</p>
<p>因为正则提取以后的信息并不整齐，比如说<code>'star': ['张国荣,张丰毅,巩俐\n ']</code>中就包括了换行符和很多的空格，我们需要处理一下：</p>
<pre><code class="language-python">    def __refine(self, anchors):
        return map(lambda anchor: {
            'pic': anchor['pic'][0], 'name': anchor['name'][0],
            'id': anchor['id'], 'star': anchor['star'][0].strip(),
            'date': anchor['date'][0],
            'score': anchor['score1'][0].strip() + anchor['score2'][0].strip()
        }, anchors)
</code></pre>
<p>先使用<code>lambda</code>表达式对每个电影信息<code>anchor</code>中的冗余元素进行剔除，然后用<code>map</code>这个类对<code>anchors</code>这个列表中的每个元素进行同样的操作，返回我们最终想要的信息。</p>
<p>接着我设置了一个展示函数将结果展示出来：</p>
<pre><code class="language-python">    def __show(self, anchors):
        for anchor in anchors:
            print('pic:', anchor['pic'], 'name:', anchor['name'], 
                  'id:', anchor['id'], 'star:', anchor['star'],
                  'date:', anchor['date'], 'score:', anchor['score'])
</code></pre>
<p>也就是每次执行后会把结果打印出来，后来觉得还是存储起来比较好，就又定义了一个存储为excle的方法，用了<code>xlsxwriter</code>这个包，其实根本不了解这个包的具体操作，我也是看着别人的代码照葫芦画瓢学的：</p>
<pre><code>def __save_excle(self, anchors, filename):
        workbook = xlw.Workbook('%s.xlsx' % filename)
        # 这里首先对这个Workbook的类进行实例化，创建一个工作薄，然后设置存储的位置，我设置的是同级目录

        sheet = workbook.add_worksheet()
        # 接着创建工作表

        title = ['电影海报链接', '电影名', '猫眼ID编号', '主演', '上映日期', '评分']
        for i in range(0, len(title)):
            sheet.write_string(0, i, title[i],
                               workbook.add_format({'bold': True}))
		#设置表的标题，并且采用字体加粗

        sheet.set_column(0, 0, 50)
        sheet.set_column(1, 1, 20)
        sheet.set_column(2, 2, 10)
        sheet.set_column(3, 3, 45)
        sheet.set_column(4, 4, 20)
        # 设置单独每列的单元格样式，这里我只设置了宽度

        row, col = 1, 0
        # row--&gt;行坐标   col--&gt;列坐标  设置写入的位置

        for anchor in anchors:
            sheet.write_string(row, col, anchor['pic'])
            sheet.write_string(row, col + 1, anchor['name'])
            sheet.write_string(row, col + 2, anchor['id'])
            sheet.write_string(row, col + 3, anchor['star'])
            sheet.write_string(row, col + 4, anchor['date'])
            sheet.write_string(row, col + 5, anchor['score'])
            row += 1
         # 写入我们爬取的数据，由于都是字符串，所以是【write_string】

        workbook.close()
        # 关闭并保存
</code></pre>
<p>也是一边写，一边看别人怎么写，一边看xlsxwriter的介绍文档，写完之后发现可以用哈哈哈，然后就是定义了爬取多页的一个流程：</p>
<pre><code class="language-python">    def go(self):
        fin_achors = []
        for i in range(10):
            url = 'http://maoyan.com/board/4?offset={}'.format(i*10)
            htmls_source = Movie.__get(self, url)
            anchors = Movie.__analysis(self, htmls_source)
            anchors = Movie.__refine(self, anchors)
            time.sleep(1)
            fin_achors.extend(anchors)
        # Movie.__show(self, fin_achors)
        Movie.__save_excle(self, fin_achors, '猫眼电影TOP100')
</code></pre>
<p>查看每一页的url后发现规律(吐槽斗鱼，每一页的url都相同，只能以后学了其它东西再尝试爬取了)，定义一个总的列表<code>fin_anchors</code>来存放爬取十页后的信息，设置一个for循环，将每一页的爬取信息利用<code>extend()</code>方法存放到我们定义的总表中，因为害怕爬取速度太快出现什么问题，所以增加了一个延时等待<code>time.sleep(1)</code>，然后对总表进行打印或者是存为excle的操作。</p>
<p>其实最后能解决问题也是因为看到了<code>extend()</code>这个方法，因为出错的时候有尝试将两个列表相加的操作，结果只是列表相加而不是元素的聚合，前面也用过<code>append()</code>这个方法，上网查了一下两者的区别：</p>
<pre><code class="language-python">list.append(object) 向列表中添加一个对象object
list.extend(sequence) 把一个序列seq的内容添加到列表中

music_media = ['compact disc', '8-track tape', 'long playing record']
new_media = ['DVD Audio disc', 'Super Audio CD']
music_media.append(new_media)
print music_media
&gt;&gt;&gt;['compact disc', '8-track tape', 'long playing record', ['DVD Audio disc', 'Super Audio CD']]
使用append的时候，是将new_media看作一个对象，整体打包添加到music_media对象中。

music_media = ['compact disc', '8-track tape', 'long playing record']
new_media = ['DVD Audio disc', 'Super Audio CD']
music_media.extend(new_media)
print music_media
&gt;&gt;&gt;['compact disc', '8-track tape', 'long playing record', 'DVD Audio disc', 'Super Audio CD']
使用extend的时候，是将new_media看作一个序列，将这个序列和music_media序列合并，并放在其后面。
</code></pre>
<h1 id="最终代码">最终代码</h1>
<pre><code class="language-python">import requests
import re
import xlsxwriter as xlw
import time


class Movie():
    root_pattern = '&lt;dd&gt;([\s\S]*?)&lt;/dd&gt;'
    pic_pattern = '&lt;img data-src=&quot;(.*?)@160w_220h_1e_1c'
    name_pattern = 'alt=&quot;(.*?)&quot; class=&quot;board-img&quot;'
    id_pattern = 'data-val=&quot;{movieId:([\w]*?)}&quot;'
    star_pattern = '主演：([\s\S]*?)&lt;/p&gt;'
    date_pattern = '&lt;p class=&quot;releasetime&quot;&gt;上映时间：([\s\S]*?)&lt;/p&gt;'
    score1_pattern = '&lt;i class=&quot;integer&quot;&gt;(\d\.)&lt;/i&gt;'
    score2_pattern = '&lt;i class=&quot;fraction&quot;&gt;(\d)&lt;/i&gt;'
    
    def __get(self, url):
        headers = {
                   'User-Agent': 'Mozilla/5.0(Macintosh;Intel Mac OS X 10_13_3) \
                   AppleWebKit/537.36(KHTML. like Gecko)\
                   Chrome/65.0.3325.162 Safari/536.36'
        }
        response = requests.get(url, headers=headers)
        htmls_source = response.text
        return htmls_source

    def __analysis(self, htmls_source):
        htmls = re.findall(Movie.root_pattern, htmls_source)
        anchors = []
        for html in htmls:
            pic = re.findall(Movie.pic_pattern, html)
            name = re.findall(Movie.name_pattern, html)
            id = re.findall(Movie.id_pattern, html)[0]
            star = re.findall(Movie.star_pattern, html)
            date = re.findall(Movie.date_pattern, html)
            score1 = re.findall(Movie.score1_pattern, html)
            score2 = re.findall(Movie.score2_pattern, html)
            anchor = {'pic': pic, 'name': name, 'id': id, 'star': star,
                      'date': date, 'score1': score1, 'score2': score2}
            anchors.append(anchor)
        return anchors

    def __refine(self, anchors):
        return map(lambda anchor: {
            'pic': anchor['pic'][0], 'name': anchor['name'][0],
            'id': anchor['id'], 'star': anchor['star'][0].strip(),
            'date': anchor['date'][0],
            'score': anchor['score1'][0].strip() + anchor['score2'][0].strip()
        }, anchors)

    def __show(self, anchors):
        for anchor in anchors:
            print('pic:', anchor['pic'], 'name:', anchor['name'], 
                  'id:', anchor['id'], 'star:', anchor['star'],
                  'date:', anchor['date'], 'score:', anchor['score'])

    def __save_excle(self, anchors, filename):
        workbook = xlw.Workbook('%s.xlsx' % filename)
        sheet = workbook.add_worksheet()
        title = ['电影海报链接', '电影名', '猫眼ID编号', '主演', '上映日期', '评分']
        for i in range(0, len(title)):
            sheet.write_string(0, i, title[i],
                               workbook.add_format({'bold': True}))
        sheet.set_column(0, 0, 50)
        sheet.set_column(1, 1, 20)
        sheet.set_column(2, 2, 10)
        sheet.set_column(3, 3, 45)
        sheet.set_column(4, 4, 20)
        
        row, col = 1, 0
        for anchor in anchors:
            sheet.write_string(row, col, anchor['pic'])
            sheet.write_string(row, col + 1, anchor['name'])
            sheet.write_string(row, col + 2, anchor['id'])
            sheet.write_string(row, col + 3, anchor['star'])
            sheet.write_string(row, col + 4, anchor['date'])
            sheet.write_string(row, col + 5, anchor['score'])
            row += 1
        workbook.close()

    def go(self):
        fin_achors = []
        for i in range(10):
            url = 'http://maoyan.com/board/4?offset={}'.format(i*10)
            htmls_source = Movie.__get(self, url)
            anchors = Movie.__analysis(self, htmls_source)
            anchors = Movie.__refine(self, anchors)
            time.sleep(1)
            fin_achors.extend(anchors)
        # Movie.__show(self, fin_achors)
        Movie.__save_excle(self, fin_achors, '猫眼电影TOP100')

movie = Movie()
movie.go()
</code></pre>
<h1 id="最终结果">最终结果</h1>
<h2 id="目录信息">目录信息</h2>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%9C.png" alt=""><br>
我这里设置的是同级目录，也可以在<code>__save_excle</code>中修改成别的目录</p>
<h2 id="爬取信息">爬取信息</h2>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E7%88%AC%E5%8F%96%E7%BB%93%E6%9E%9C.png" alt=""></p>
<p>明天尝试爬一下豆瓣的TOP250哈哈哈哈哈<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E5%86%B2%E9%B8%AD.jpg" alt=""></p>
<h1 id="爬取豆瓣后续">爬取豆瓣后续：</h1>
<p>本来以为是改几个变量的值就可以了 = = 没想到还是遇到了点儿问题<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E8%B1%86%E7%93%A3top250_%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E.png" alt=""><br>
分析正则表达式的时候使用排名第一的<code>肖申克的救赎</code>进行分析的，按照流程，一切都很正常，然后我准备储存进excle的时候出现了问题：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E5%AD%98%E5%82%A8%E5%87%BA%E9%94%99.png" alt=""><br>
噢，看来是存储主演姓名的时候出错了，出错原因并不清楚，然后百度了一下：</p>
<pre><code>Python不支持dict的key为list或dict类型，因为list和dict类型是unhashable（不可哈希）的。
</code></pre>
<p>虽然不知道啥叫不可哈希，但是也差不多清楚了，可能是我的<code>star</code>名的<code>key</code>值没有转换过来，去看了一下，果然：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-star.png" alt=""><br>
数据精炼的时候，我的<code>star</code>还是列表，应该取列表里的元素的，于是我在后面加入了<code>[0]</code>,以为这下可以成功了，结果又出错了：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-list_out_of_range.png" alt=""><br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E9%BB%91%E4%BA%BA%E9%97%AE%E5%8F%B7.jpg" alt=""><br>
这又是什么错误？？？列表超出范围？？？什么鬼？？？于是我又百度了一下，找到了原因：</p>
<pre><code>这个错误出现大约有两种情况： 
第1种可能情况 
list[index]index超出范围

第2种可能情况 
list是一个空的 没有一个元素 
进行list[0]就会出现该错误
</code></pre>
<p>嗯？？？难道是我的<code>star</code>是空的？？？不可能啊，当时还打印出<code>anchors[0]</code>看过的啊，有值啊，难道是别的电影？？？于是我打开豆瓣TOP250，看了一下：<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E6%B2%A1%E6%9C%89star%E5%80%BC.png" alt=""><br>
果然，我发现有一部电影的<code>star</code>有一点不一样，这什么鬼啊，导演名字这么长？？？为什么后面三个点...以后就没东西了啊，除非你点进这部电影的详情页，否则你是看不到主演姓名的(暂时发现是这样)，所以又遇到了一个问题：</p>
<pre><code>爬虫有的时候会匹配到空值，这个时候应该怎么处理？？
</code></pre>
<p>最后我写了一个<code>if</code>语句来判断如果<code>star</code>值为空，那么强行给<code>star</code>赋值为<code>None</code>，额，好像有点儿奇怪，反正先这样吧：</p>
<pre><code class="language-python">star = re.findall(star_pattern, html)
    if star == []:
        star = 'None'
</code></pre>
<p>就这样，成功的解决了问题，并且这一次我是把每个部分的函数拆个一个一个模块来写的:<br>
<img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-%E6%A8%A1%E5%9D%97.png" alt=""></p>
<p>最后成功获得了豆瓣TOP250的详细名单：</p>
<p><img src="https://raw.githubusercontent.com/Tudouvvv/Pic_path/master/2018-09-19-top250.png" alt=""></p>
]]></content>
    </entry>
</feed>