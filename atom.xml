<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tudouvvv.github.io/</id>
    <title>Tudouvvv</title>
    <updated>2019-11-07T12:08:20.277Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tudouvvv.github.io/"/>
    <link rel="self" href="https://tudouvvv.github.io//atom.xml"/>
    <subtitle>人生还长，慢慢来</subtitle>
    <logo>https://tudouvvv.github.io//images/avatar.png</logo>
    <icon>https://tudouvvv.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Tudouvvv</rights>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week5]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week5</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week5">
        </link>
        <updated>2019-11-06T12:13:03.000Z</updated>
        <content type="html"><![CDATA[<h4 id="57-数字序列中某一位的数字">57. 数字序列中某一位的数字</h4>
<p>题目描述：数字以0123456789101112131415…的格式序列化到一个字符序列中。<br>
在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。<br>
请写一个函数求任意位对应的数字。</p>
<pre><code>样例
输入：13
输出：1
</code></pre>
<p>思路：</p>
<ol>
<li>首先确定它是几位数</li>
<li>确定是几位数的第几个数</li>
<li>确定是那个数的第几位</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int digitAtIndex(int n) {
         long long i = 1, s = 9, base = 1;//i表示是几位数，s表示位数共有多少个，base表示位数的起始值。
         while(n &gt; i * s) {   // 9, 90, 900, 9000, 90000, i * s表示位数总共占多少位。
             n -= i * s;         // 1000 - 9 - 90 * 2 - 900 * 3 ,当i= 3 时不符合条件，说明是在三位数里面。
             i ++;                
             s *= 10;
             base *= 10;
         }
         int number = base + (n + i - 1) / i - 1; //求位数的第几个数， 1000 - 9 - 180 = n , n / 3 + base - 1（考虑0故减1）, 向上取整 n + i - 1。
         int r = n % i ? n % i : i;              // 除不尽就是第几位，除尽力了就是最后一位。
         for (int j = 0; j &lt; i - r; j ++) number /= 10; //求数的第i - r位，取出第i - r位。

         return number % 10;
    }
};
</code></pre>
<h4 id="58-把数组排成最小的数">58. 把数组排成最小的数</h4>
<p>题目描述：<br>
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>
例如输入数组[3, 32, 321]，则打印出这3个数字能排成的最小数字321323。</p>
<pre><code>样例
输入：[3, 32, 321]
输出：321323
</code></pre>
<p>注意：输出数字的格式为字符串。<br>
思路：这道题本来想的是先寻找所有可能的取值，然后在进行大小的比较，后来超时了。<br>
看到的做法是定义一个新的排序规则，str(a) + str(b) &lt; str(b) + str(a)，这样的话就会使得最小的数排在前面，然后拼起来就好了。</p>
<pre><code class="language-c++">class Solution {
public:
    
    static bool cmp(int a, int b){
        string as = to_string(a), bs = to_string(b);
        return as + bs &lt; bs + as;
    }
        
    string printMinNumber(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end(), cmp);
        string res;
        for (auto x : nums) res += to_string(x);
        return res;
    }
};
</code></pre>
<h4 id="59-把数字翻译成字符串">59. 把数字翻译成字符串</h4>
<p>题目描述：给定一个数字，我们按照如下规则把它翻译为字符串：<br>
0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。<br>
一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。<br>
请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
<pre><code>样例
输入：&quot;12258&quot;
输出：5
</code></pre>
<p>思路：这道题之前做过，可以用动态规划来做。</p>
<pre><code class="language-python">class Solution:
    def getTranslationCount(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        n = len(s);
        f = [0 for _ in range(n + 2)]
        f[0] = 1
        for i in range(1, n + 1):
            f[i] = f[i - 1]
            t = int(s[i - 1]) + int(s[i - 2]) * 10
            if (t &gt;= 10 and t &lt;= 25): f[i] += f[i - 2]
        return f[i]
</code></pre>
<pre><code class="language-c++">class Solution {
public:
    int getTranslationCount(string s) {
        int n = s.size();
        vector&lt;int&gt; f(n + 1);
        f[0] = 1;
        for (int i = 1; i &lt;= n; i ++){
            f[i] = f[i - 1];
            if (i &gt; 1){
                int t = (s[i - 1] - '0') + (s[i - 2] - '0') * 10;
                if (t &gt;= 10 &amp;&amp; t &lt;= 25) f[i] += f[i - 2];
            }
        }
        return f[n];
    }
};
</code></pre>
<h4 id="60-礼物的最大价值">60. 礼物的最大价值</h4>
<p>题目描述：一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。<br>
你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。<br>
给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？<br>
注意：<br>
m, n &gt; 0</p>
<pre><code>样例：
输入：
[
  [2,3,1],
  [1,7,1],
  [4,6,1]
]
输出：19
解释：沿着路径 2→3→7→6→1 可以得到拿到最大价值礼物。
</code></pre>
<p>思路：因为只能向右或者向下走，所以每个点的状态只能通过它上面的格子或者左边的格子转移过来。</p>
<pre><code class="language-c++">class Solution {
public:
    int getMaxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size(), m = grid[0].size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt; (m + 1));
        for (int i = 1; i &lt;= n; i ++)
            for (int j = 1; j &lt;= m; j ++)
            {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + grid[i - 1][j - 1];
            }
        return f[n][m];
    }
};
</code></pre>
<h4 id="61-最长不含重复字符的子字符串">61. 最长不含重复字符的子字符串</h4>
<p>题目描述：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>
假设字符串中只包含从’a’到’z’的字符。</p>
<pre><code>样例
输入：&quot;abcabc&quot;
输出：3
</code></pre>
<p>思路: 两个指针，一个一直往前走，用字典存储它里面每个字母出现的次数，如果遇见了之前遇见的，那么另一个指针就往前走，直到该字母的出现次数再度变为一。</p>
<pre><code class="language-c++">class Solution {
public:
    int longestSubstringWithoutDuplication(string s) {
        unordered_map &lt;char, int&gt; hash;
        int res = 0;
        for (int i = 0, j = 0; i &lt; s.size(); i ++){
            hash[s[i]] ++;
            while (hash[s[i]] &gt; 1) hash[s[j ++]] --;
            res = max(res, i - j + 1);
        }
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week4（1道不会做）]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week4</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week4">
        </link>
        <updated>2019-11-04T02:27:34.000Z</updated>
        <content type="html"><![CDATA[<h4 id="46-二叉搜索树的后序遍历序列">46. 二叉搜索树的后序遍历序列</h4>
<p>题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。<br>
如果是则返回true，否则返回false。<br>
假设输入的数组的任意两个数字都互不相同。</p>
<pre><code>样例
输入：[4, 8, 6, 12, 16, 14, 10]
输出：true
</code></pre>
<p>思路：后序遍历的顺序是左右根，所以输入的最后一位肯定是根节点，然后输入的前面一部分小于根节点，是左子树；后面一部分大于跟节点，是右子树。先找到这个分界点，然后看后面这部分是否满足要求&gt;root，然后对左子树和右子树进行迭代即可。</p>
<pre><code class="language-c++">class Solution {
public:
    bool verifySequenceOfBST(vector&lt;int&gt; sequence) {
        if (sequence.empty()) return true;
        int l = 0, r = sequence.size() - 1;
        return dfs(sequence, l, r);
    }
    
    bool dfs(vector&lt;int&gt; &amp;sequence, int l, int r){
        if (l &gt;= r) return true;
        auto root = sequence[r];
        int k = 0;
        while (k &lt; r &amp;&amp; sequence[k] &lt; root) k++;
        for (int i = k; i &lt; r; i ++){
            if (sequence[i] &lt; root) return false;
        }
        return dfs(sequence, l, k - 1) &amp;&amp; dfs(sequence, k, r - 1);
    }
};
</code></pre>
<h4 id="47-二叉树中和为某一值的路径">47. 二叉树中和为某一值的路径</h4>
<p>题目描述：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>
从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<pre><code>样例
给出二叉树如下所示，并给出num=22。
      5
     / \
    4   6
   /   / \
  12  13  6
 /  \    / \
9    1  5   1
输出：[[5,4,12,1],[5,6,6,5]]
</code></pre>
<p>思路：遍历一棵树，不同的是遍历的时候加了一些限制条件，需要找到一个从根节点开始到叶节点的路径，需要记录这个路径。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;

    vector&lt;vector&lt;int&gt;&gt; findPath(TreeNode* root, int sum) {
        dfs(root, sum);
        return ans;
    }
    
    void dfs(TreeNode* root, int sum){
        if (! root) return;
        path.push_back(root-&gt;val);
        sum -= root-&gt;val;
        if (! root-&gt;left &amp;&amp; ! root-&gt;right &amp;&amp; !sum) ans.push_back(path);
        dfs(root-&gt;left, sum);
        dfs(root-&gt;right, sum);
        path.pop_back();
        sum += root-&gt;val;
    }
};
</code></pre>
<h4 id="48-复杂链表的复刻leecode138">48. 复杂链表的复刻（Leecode138）</h4>
<p>题目描述：请实现一个函数可以复制一个复杂链表。<br>
在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者null。<br>
注意：<br>
函数结束后原链表要与输入时保持一致。<br>
思路：题意就是让我们把一个复杂链表复制再返回，因为有额外指针的关系，我们可以这样来做：<br>
<img src="https://tudouvvv.github.io//post-images/1572873769602.png" alt=""><br>
首先每个节点可以在后面复制一个它，再接到下一个节点上，本来可能是1-&gt;2-&gt;3，现在变成了1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3，假如1.random = 3，那么现在，1.next.random = 1.random.next，之后再把下面这些多加的节点拿出来就好了。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list with a random pointer.
 * struct ListNode {
 *     int val;
 *     ListNode *next, *random;
 *     ListNode(int x) : val(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *copyRandomList(ListNode *head) {
        for (auto p = head; p;){
            auto np = new ListNode(p-&gt;val);
            auto next = p-&gt;next;
            p-&gt;next = np;
            np-&gt;next= next;
            p = next;
        }
        
        for (auto p = head; p; p = p-&gt;next-&gt;next){
            if (p-&gt;random) p-&gt;next-&gt;random = p-&gt;random-&gt;next;
        }
        auto dummy = new ListNode(-1);
        auto cur = dummy;
        for (auto p = head; p; p = p-&gt;next){
            cur-&gt;next = p-&gt;next;
            cur = cur-&gt;next;
            p -&gt; next = p-&gt;next-&gt;next;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<h4 id="49-二叉搜索树与双向链表">49. 二叉搜索树与双向链表</h4>
<p>题目描述: 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>
要求不能创建任何新的结点，只能调整树中结点指针的指向。<br>
注意：<br>
需要返回双向链表最左侧的节点。<br>
例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。<br>
<img src="https://tudouvvv.github.io//post-images/1572919419174.png" alt=""><br>
思路:</p>
<ol>
<li>二叉搜索树的中序遍历就是双向链表的顺序，唯一不同的是，在中序遍历的时候需要把当前节点的左指针指向前一个点，前一个点的右指针指向当前点。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* convert(TreeNode* root) {
        stack&lt;TreeNode*&gt; q;
        if (! root || (! root-&gt;left &amp;&amp; ! root-&gt;right)) return root;
        auto dummy = new TreeNode(0);
        auto head = dummy;
        while (root || q.size()){
            if (root) q.push(root), root = root-&gt;left;
            else{
                root = q.top();
                q.pop();
                auto cur = root;
                cur-&gt;left = dummy;
                dummy-&gt;right = cur;
                dummy = cur;
                root = root-&gt;right;
            }
        }
        head-&gt;right-&gt;left = NULL;
        return head-&gt;right;
    }
};
</code></pre>
<ol start="2">
<li>也可以通过递归的方式，设定一个pair，它存的是当前节点的子树的最左边的点和最右边的点，左子树需要把左子树的pair.second-&gt;right = root，root-&gt;left = pair.second，右子树同理。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* convert(TreeNode* root) {
        if (! root) return NULL;
        auto sides = dfs(root);
        return sides.first;
    }
    
    pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode * root){
        if (!root-&gt;left &amp;&amp; !root-&gt;right) return {root, root};
        if (root-&gt;left &amp;&amp; root-&gt;right){
            auto lside = dfs(root-&gt;left), rside = dfs(root-&gt;right);
            lside.second-&gt;right = root, root-&gt;left = lside.second;
            rside.first-&gt;left = root, root-&gt;right = rside.first;
            return {lside.first, rside.second};
        }
        if (root-&gt;left){
            auto lside = dfs(root-&gt;left);
            lside.second-&gt;right = root, root-&gt;left = lside.second;
            return {lside.first, root};
        }
        if (root-&gt;right){
            auto rside = dfs(root-&gt;right);
            rside.first-&gt;left = root, root-&gt;right = rside.first;
            return {root, rside.second};
        }
        
    }
};
</code></pre>
<h4 id="50-序列化二叉树">50. 序列化二叉树</h4>
<p>题目描述：请实现两个函数，分别用来序列化和反序列化二叉树。<br>
您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。</p>
<pre><code>样例
你可以序列化如下的二叉树
    8
   / \
  12  2
     / \
    6   4

为：&quot;[8, 12, 2, null, null, 6, 4, null, null, null, null]&quot;
</code></pre>
<p>思路：</p>
<ol>
<li>序列化按照中序遍历的顺序，从根开始，遇见空的就添加'#,'，否则就添加'root.val' + ','。<br>
比较困难的是反序列化的步骤，需要判断各种情况：</li>
</ol>
<ul>
<li>遇见了'#'，那么返回NULL，向后跳两个字符 u += 2；</li>
<li>遇见了'-'，那么需要标记一下这是个负数，然后对字符进行恢复，比如从'123'恢复成123，在 c++ 中，可以这样: <code>int t = 0, t = t * 10 + str[i]</code>，最后在根据正负号确定节点的val</li>
<li>迭代</li>
</ul>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string res;
        dfs_1(root, res);
        return res;
    }
    
    void dfs_1(TreeNode* root, string &amp;res){
        if(!root) 
        {
            res += &quot;#,&quot;;
            return;
        }
        res += to_string(root-&gt;val) + ',';
        dfs_1(root-&gt;left, res);
        dfs_1(root-&gt;right, res);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs_2(data, u);
    }
    
    TreeNode* dfs_2(string data, int &amp;u){
        if (data[u] == '#'){
            u += 2;
            return NULL;
        }
        int t = 0;
        bool is_minus = false;
        if (data[u] == '-'){
             u ++;
             is_minus = true;
        }
        while (data[u] != ','){
            t = t * 10 + data[u] - '0';
            u ++;
        }
        u ++;
        if (is_minus) t = -t;
        auto root = new TreeNode(t);
        root-&gt;left = dfs_2(data, u);
        root-&gt;right = dfs_2(data, u);
        return root;
    } 
};
</code></pre>
<ol start="2">
<li>使用python来写的话，可以用split函数把节点值都给分开。</li>
</ol>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:

    def serialize(self, root):
        &quot;&quot;&quot;Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        &quot;&quot;&quot;
        if not root:
            return 'None';
        return str(root.val) + ',' +  self.serialize(root.left) + ',' + self.serialize(root.right);
        

    def deserialize(self, data):
        &quot;&quot;&quot;Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        &quot;&quot;&quot;
        self.i = -1
        data = data.split(',')
        return self.dfs(data);
        
    def dfs(self, data):
        if self.i &gt;= len(data): 
            return
        self.i += 1
        root = None
        if data[self.i] != 'None':
            root = TreeNode(int(data[self.i]))
            root.left = self.dfs(data)
            root.right = self.dfs(data)
        return root       
</code></pre>
<h4 id="51-数字排列">51. 数字排列</h4>
<p>题目描述：输入一组数字（可能包含重复数字），输出其所有的排列方式。</p>
<pre><code>样例
输入：[1,2,3]
输出：
      [
        [1,2,3],
        [1,3,2],
        [2,1,3],
        [2,3,1],
        [3,1,2],
        [3,2,1]
      ]
</code></pre>
<pre><code class="language-c++">class Solution {
public:

    int n ;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    vector&lt;bool&gt; st;
    
    vector&lt;vector&lt;int&gt;&gt; permutation(vector&lt;int&gt;&amp; nums) {
        n = nums.size();
        path = vector&lt;int&gt;(n);
        st = vector&lt;bool&gt;(n);
        sort(nums.begin(), nums.end());
        dfs(nums, 0, 0);
        return ans;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int u, int start){
        if (u == n){
            ans.push_back(path);
            return ;
        }
        
        for (int i = start; i &lt; n; i ++){
            if (! st[i]){
                st[i] = true;
                path[i] = nums[u];
                dfs(nums, u + 1, nums[u] == nums[u + 1] ? i + 1 : 0);
                st[i] = false;
            }
        }
    }
};
</code></pre>
<h4 id="52-数组中出现次数超过一半的数字">52. 数组中出现次数超过一半的数字</h4>
<p>题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>
假设数组非空，并且一定存在满足条件的数字。<br>
思考题：<br>
假设要求只能使用 O(n) 的时间和额外 O(1) 的空间，该怎么做呢？</p>
<pre><code>样例
输入：[1,2,1,1,3]
输出：1
</code></pre>
<p>思路：</p>
<ol>
<li>开心消消乐：首先取第一个元素为标记元素，记录次数n = 1，然后和后面的元素进行比较，一样的时候，次数加一，不一样的时候次数减一，当次数为0的时候，换标记元素为当前元素，记录次数n归一，继续，因为题目中告诉我们一定存在这样一个数字超过一半，所以这样消消乐下来，剩下的一定就是我们想要的。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int moreThanHalfNum_Solution(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return NULL;
        if (nums.size() == 1) return nums[0];
        
        int res = nums[0];
        int n = 1;
        for (int i = 1; i &lt; nums.size(); i ++){
            if (nums[i] == res) n ++;
            else n --;
            if (n == 0){
                res = nums[i];
                n = 1;
            }
        }
        return res;
    }
};
</code></pre>
<ol start="2">
<li>排序然后输出中间元素就是的，但是这样时间复杂度就不满足要求了。</li>
</ol>
<h4 id="53-最小的k个数">53. 最小的k个数</h4>
<p>题目描述:输入n个整数，找出其中最小的k个数。<br>
注意：<br>
数据保证k一定小于等于输入数组的长度;<br>
输出数组内元素请按从小到大顺序排序;</p>
<pre><code>样例
输入：[1,2,3,4,5,6,7,8] , k=4
输出：[1,2,3,4]
</code></pre>
<p>思路：创建一个大根堆，遍历输入元素，push进堆里，如果发现堆里元素超过了k，那么就pop掉，这样就能保证堆内元素一定是最小的k个。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; getLeastNumbers_Solution(vector&lt;int&gt; input, int k) {
        priority_queue&lt;int&gt; heap;
        for (auto c : input){
            heap.push(c);
            if (heap.size() &gt; k) heap.pop();
        }
        
        vector&lt;int&gt; res;
        while (heap.size()){
            res.push_back(heap.top());
            heap.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
</code></pre>
<h4 id="54-数据流中的中位数">54. 数据流中的中位数</h4>
<p>题目描述：如何得到一个数据流中的中位数？<br>
如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>
如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<pre><code>样例
输入：1, 2, 3, 4
输出：1,1.5,2,2.5
解释：每当数据流读入一个数据，就进行一次判断并输出当前的中位数。
</code></pre>
<p>思路: 构建一个对顶堆，上面是一个小根堆，存的是比较大的数，下面是一个大根堆，存的是比较小的数，保证小根堆最多只比大根堆多一个数，这样两个堆的top处存的就是中间的两个数，然后再判断奇偶就可以了。</p>
<pre><code class="language-c++">class Solution {
public:

    priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;
    priority_queue &lt;int&gt; down;
    
    void insert(int num){
        if (down.empty() || num &gt; down.top()) up.push(num);
        else{
            down.push(num);
            up.push(down.top());
            down.pop();
        }
        if (up.size() &gt; down.size() + 1){
            down.push(up.top());
            up.pop();
        }
    }

    double getMedian(){
        if ((down.size() + up.size()) % 2 == 1) return up.top();
        else return (down.top() + up.top()) / 2.;
    }
};
</code></pre>
<h4 id="55-连续子数组的最大和">55. 连续子数组的最大和</h4>
<p>题目描述：输入一个 非空 整型数组，数组里的数可能为正，也可能为负。<br>
数组中一个或连续的多个整数组成一个子数组。<br>
求所有子数组的和的最大值。<br>
要求时间复杂度为O(n)。</p>
<pre><code>样例
输入：[1, -2, 3, 10, -4, 7, 2, -5]
输出：18
</code></pre>
<p>思路：</p>
<ol>
<li>只有前面的和对我是有益的（大于0），我才会去加它，否则就抛弃前面的所有数字。遍历整个数组，如果前面的数字大于0，那么就加上，相当于求一个前缀和，但是不同的是只看是否大于0，这样整个数组中最大的元素就是连续子数组的最大和；</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans = INT_MIN;
        for (int i = 1; i &lt; nums.size(); i ++){
            if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1];
        }
        for (auto x : nums){
            ans = max(ans, x);
        }
        return ans;
    }
};
</code></pre>
<ol start="2">
<li>设定一个s表示前面n - 1位数字的和，每次加元素之前判断一下s是否大于0，如果小于0，那么归零s，从现在开始重新加。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int s = 0, ans = INT_MIN;
        for (auto x : nums){
            if (s &lt; 0) s = 0;
            s += x;
            ans = max(ans, s);
        }
        return ans;
    }
};
</code></pre>
<h4 id="56-从1到n整数中1出现的次数">56. 从1到n整数中1出现的次数</h4>
<p>题目描述：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。<br>
例如输入12，从1到12这些整数中包含“1”的数字有1，10，11和12，其中“1”一共出现了5次。</p>
<pre><code>样例
输入： 12
输出： 5
</code></pre>
<p>思路:</p>
<ol>
<li>暴力搜索(❌)TLE了</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int numberOf1Between1AndN_Solution(int n) {
        if (n == 1) return 1;
        int cnt = 0;
        for (int i = 1; i &lt;= n; i ++){
            auto tmp = to_string(i);
            for (auto x : tmp){
                if (x == '1') cnt ++;
            }
        }
        return cnt;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week3]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week3</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-week3">
        </link>
        <updated>2019-10-31T08:34:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="35-反转链表">35. 反转链表</h4>
<p>题目描述：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<pre><code>样例
输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>思路:之前做过这道题，每次反转两个，然后向后移一位，指导翻转完所有的，这个时候让尾部指向NULL, 即head -&gt; next = NULL, 然后设定新的头结点。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (! head) return head;
        auto a = head, b = head -&gt; next;
        while (b){
            auto c = b -&gt; next;
            b -&gt; next = a;
            a = b, b = c;
        }
        head -&gt; next = NULL;
        head = a;
        return head;
    }
};
</code></pre>
<h4 id="36-合并两个排序的链表">36. 合并两个排序的链表</h4>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<pre><code>样例
输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5
输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5
</code></pre>
<p>思路: 设定一个新的空结点，每次l1和l2比较完，就在后面接上小的，最后比完后有可能两个链表还有一个不为空，把它接在后面即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* merge(ListNode* l1, ListNode* l2) {
        auto dummy = new ListNode(-1);
        auto cur = dummy;
        while (l1 != NULL &amp;&amp; l2 != NULL){
            if (l1-&gt;val &lt; l2-&gt;val){
                cur -&gt; next = l1;
                l1 = l1 -&gt; next;
            }
            else {
                cur -&gt; next = l2;
                l2 = l2 -&gt; next;
            }
            cur = cur -&gt; next;
        }
        if (l1 == NULL) cur -&gt; next = l2;
        else cur -&gt; next = l1;
        return dummy -&gt; next;
    }  
};
</code></pre>
<h4 id="37-树的子结构">37. 树的子结构</h4>
<p>题目描述: 输入两棵二叉树A，B，判断B是不是A的子结构。<br>
我们规定空树不是任何树的子结构。</p>
<pre><code>样例
树A：

     8
    / \
   8   7
  / \
 9   2
    / \
   4   7
树B：

   8
  / \
 9   2
返回 true ,因为B是A的子结构。
</code></pre>
<p>思路：通过递归的方式来做，首先看根节点，不行就看左子树或者右子树；判断的时候要判断左右是否都能匹配。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if (! pRoot1 || ! pRoot2) return false;
        if (isPart(pRoot1, pRoot2)) return true;
        return hasSubtree(pRoot1-&gt;left, pRoot2) || hasSubtree(pRoot1-&gt;right, pRoot2);
    }
    
    bool isPart(TreeNode* p, TreeNode* q){
        if (! q) return true;
        if (! p || p-&gt;val != q-&gt;val) return false;
        return isPart(p-&gt;left, q-&gt;left) &amp;&amp; isPart(p-&gt;right, q-&gt;right);
    }
};
</code></pre>
<h4 id="38-二叉树的镜像">38. 二叉树的镜像</h4>
<p>输入一个二叉树，将它变换为它的镜像。</p>
<pre><code>样例
输入树：
      8
     / \
    6  10
   / \ / \
  5  7 9 11

 [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] 
输出树：
      8
     / \
    10  6
   / \ / \
  11 9 7  5

 [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]
</code></pre>
<p>思路：镜像就是从上往下，交换左右节点即可。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void mirror(TreeNode* root) {
        if  (! root) return ;
        swap(root-&gt;left, root-&gt;right);
        mirror(root-&gt;left);
        mirror(root-&gt;right);
    }
};
</code></pre>
<h4 id="39-对称的二叉树">39. 对称的二叉树</h4>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。<br>
如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<pre><code>样例
如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：
    1
   / \
  2   2
 / \ / \
3  4 4  3

如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：
    1
   / \
  2   2
   \ / \
   4 4  3
</code></pre>
<p>思路：之前做过这道题，关于树的题，一般都是通过递归的方式，不断地深入直到叶节点为止。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (! root) return true;
        return dfs(root-&gt;left, root-&gt;right);
    }
    
    bool dfs(TreeNode* p, TreeNode* q){
        if (!p || !q) return !p &amp;&amp; !q;
        if (p-&gt;val != q-&gt;val) return false;
        return dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);
    }
};
</code></pre>
<h4 id="40-顺时针打印矩阵">40. 顺时针打印矩阵</h4>
<p>题目描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<pre><code>样例
输入：
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]

输出：[1,2,3,4,8,12,11,10,9,5,6,7]
</code></pre>
<p>思路：定义一个顺时针的方向，然后就开始移动，每次出界或者是遇到了之前遇到的数字就换一个方向。换方向可以通过(d + 1) % 4来实现，因为只有四个方向hh.</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) {
        vector&lt;int&gt; res;
        
        if (matrix.empty() || matrix[0].empty()) return res;
        int n = matrix.size(), m = matrix[0].size();
        vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(m));
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        int x = 0, y = 0, d = 1;
        for (int k = 0; k &lt; n * m; k ++){
            res.push_back(matrix[x][y]);
            st[x][y] = true;
            
            int a = x + dx[d], b = y + dy[d];
            if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || st[a][b]){
                d = (d + 1) % 4;
                a = x + dx[d], b = y + dy[d];
            }
            x = a, y = b;
        }
        return res;
    }
};
</code></pre>
<h4 id="41-包含min函数的栈">41. 包含min函数的栈</h4>
<p>题目描述：设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p>
<p>push(x)–将元素x插入栈中<br>
pop()–移除栈顶元素<br>
top()–得到栈顶元素<br>
getMin()–得到栈中最小元素</p>
<pre><code>样例
MinStack minStack = new MinStack();
minStack.push(-1);
minStack.push(3);
minStack.push(-4);
minStack.getMin();   --&gt; Returns -4.
minStack.pop();
minStack.top();      --&gt; Returns 3.
minStack.getMin();   --&gt; Returns -1.
</code></pre>
<p>思路：之前做过这道题，可以另开一个新栈存储最小值，第一个表示第一个数的最小的，第二个表示前两个数的最小值...</p>
<pre><code class="language-c++">class MinStack {
public:

    stack&lt;int&gt; stk, min_stk;
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        stk.push(x);
        if (min_stk.empty()) min_stk.push(x);
        else min_stk.push(min(x, min_stk.top()));
    }
    
    void pop() {
        stk.pop();
        min_stk.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return min_stk.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
</code></pre>
<h4 id="42-栈的压入-弹出序列">42. 栈的压入、弹出序列</h4>
<p>题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。<br>
假设压入栈的所有数字均不相等。<br>
例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>
注意：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。</p>
<pre><code>样例
输入：[1,2,3,4,5]
      [4,5,3,2,1]

输出：true
</code></pre>
<p>思路：由于输入输出都已经给了，所以只需要进行判断就可以了，开一个栈，每次压入元素，然后判断与输出的头元素是不是相同，相同的就pop，然后输出向后移一位在判断，不同的话就再压。如果输出的序列是正确的，那么栈最后应该为空，否则就是不正确的。</p>
<pre><code class="language-c++">class Solution {
public:
    bool isPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) {
        if (pushV.size() != popV.size()) return false;
        stack&lt;int&gt; stk;
        int i = 0;
        for (auto x : pushV){
            stk.push(x);
            while (stk.size() &amp;&amp; stk.top() == popV[i]){
                stk.pop();
                i ++;
            }
        } 
        return stk.empty();
    }
};
</code></pre>
<h4 id="43-不分行从上往下打印二叉树">43. 不分行从上往下打印二叉树</h4>
<p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>
<pre><code>样例
输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]
    8
   / \
  12  2
     /
    6
   /
  4
输出：[8, 12, 2, 6, 4]
</code></pre>
<p>思路：先把根节点的值放进一个队列中，然后把它的值更新到res中，然后pop掉，顺便把它的左右儿子也push进队列中，遍历整个树。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; printFromTopToBottom(TreeNode* root) {
        vector&lt;int&gt; res;
        queue&lt;TreeNode*&gt; q;
        if (! root) return res;
        q.push(root);
        while (q.size()){
            auto t = q.front();
            q.pop();
            res.push_back(t-&gt;val);
            if (t-&gt;left) q.push(t-&gt;left);
            if (t -&gt;right) q.push(t-&gt;right);
        }
        return res;
    }
};
</code></pre>
<h4 id="44-分行从上往下打印二叉树">44. 分行从上往下打印二叉树</h4>
<p>题目描述：从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p>
<pre><code>样例
输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]
    8
   / \
  12  2
     /
    6
   /
  4

输出：[[8], [12, 2], [6], [4]]
</code></pre>
<p>思路：相比较上一题，这道题就需要去遍历每一层的元素放进level，然后再push进最终的答案.</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(q.size()){
            vector&lt;int&gt; level;
            int t = q.size();
            for (int i = 0; i &lt; t; i++){
                auto k = q.front();
                q.pop();
                level.push_back(k-&gt;val);
                if (k-&gt;left) q.push(k-&gt;left);
                if (k-&gt;right) q.push(k-&gt;right);
            }
            res.push_back(level);
        }
        return res;
    }
};
</code></pre>
<h4 id="45-之字形打印二叉树">45. 之字形打印二叉树</h4>
<p>题目描述：请实现一个函数按照之字形顺序从上向下打印二叉树。<br>
即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<pre><code>样例
输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]
    8
   / \
  12  2
     / \
    6   4
输出：[[8], [2, 12], [6, 4]]
</code></pre>
<p>思路：改了一下上一道代码，最后添加一行判断的语句，因为只需要把偶数行的输出翻转就可以了。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(q.size()){
            vector&lt;int&gt; level;
            int t = q.size();
            for (int i = 0; i &lt; t; i++){
                auto k = q.front();
                q.pop();
                level.push_back(k-&gt;val);
                if (k-&gt;left) q.push(k-&gt;left);
                if (k-&gt;right) q.push(k-&gt;right);
            }
            res.push_back(level);
        }
        int len = res.size();
        for (int i = 0; i &lt; len; i ++){
            if (i % 2 == 1) reverse(res[i].begin(), res[i].end());
        }
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week2(2道题不会做)]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day2</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day2">
        </link>
        <updated>2019-10-29T03:04:52.000Z</updated>
        <content type="html"><![CDATA[<h4 id="24-机器人的运动范围">24. 机器人的运动范围</h4>
<p>题目描述: 地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。<br>
一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。<br>
但是不能进入行坐标和列坐标的数位之和大于 k 的格子。<br>
请问该机器人能够达到多少个格子？</p>
<pre><code>样例
输入：k=18, m=40, n=40
输出：1484
解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。
      但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
</code></pre>
<p>注意:</p>
<ul>
<li>0&lt;=m&lt;=50</li>
<li>0&lt;=n&lt;=50</li>
<li>0&lt;=k&lt;=100<br>
分析：去枚举每个格子，要记得只能从合法格子进入非法格子，不能从非法格子进入合法格子。</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        if (! rows || ! cols) return 0;
        int count = 1;
        // 表示格子状态
        int st[rows][cols] = {0};
        st[0][0] = 1;
        for (int i = 0; i &lt; rows; i ++)
            for (int j = 0; j &lt; cols; j ++)
            {
                int p = i / 10 + i % 10 + j / 10 + j % 10;
                // 只能从左边或者上边进入
                if (p &lt;= threshold &amp;&amp; (st[i - 1][j] == 1 || st[i][j - 1] == 1))
                {
                    count ++;
                    st[i][j] = 1;
                }
            }
        return count;
    }
};
</code></pre>
<p>也可以通过宽搜的方式来进行遍历：</p>
<pre><code class="language-c++">class Solution {
public:

    int get_single(int x){
        int s  = x / 10 + x % 10;
        return s;
    }
    
    int get_sum(pair&lt;int, int&gt; p){
        return get_single(p.first) + get_single(p.second);
    }
    
    int movingCount(int threshold, int rows, int cols)
    {
        if (! rows || ! cols) return 0;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols));
        int res = 0;
        q.push({0, 0});
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        
        while (q.size()){
            auto t = q.front();
            q.pop();
            if (get_sum(t) &gt; threshold || st[t.first][t.second]) continue;
            res ++;
            st[t.first][t.second] = true;
            for (int i = 0; i &lt; 4; i++)
            {
                int x = t.first + dx[i], y = t.second + dy[i];
                if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols) q.push({x, y});
            }
        }
        return res;
    }
};
</code></pre>
<h4 id="25-剪绳子">25. 剪绳子</h4>
<p>题目描述：给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。<br>
每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？<br>
例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
<pre><code>样例
输入：8
输出：18
</code></pre>
<p>思路：尽可能分更多的3的绳子，if n &gt;= 5, 那么3 * (n - 3) = 3n - 9 &gt; n.</p>
<pre><code class="language-c++">class Solution {
public:
    int maxProductAfterCutting(int n) {
        if (n &lt;= 3) return 1 * (n - 1);
        int res = 1;
        if (n % 3 == 1)
        {
            res *= 4;
            n -= 4;
        }
        if (n % 3 == 2)
        {
            res *= 2;
            n -= 2;
        }
        while (n)
        {
            res *= 3;
            n -= 3;
        }
        return res;
    }
};
</code></pre>
<h4 id="26-二进制中1的个数">26. 二进制中1的个数</h4>
<p>题目描述：输入一个32位整数，输出该数二进制表示中1的个数。<br>
注意：<br>
负数在计算机中用其绝对值的补码来表示。</p>
<p>ps.什么叫补码呢？这得从原码，反码说起。<br>
原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。<br>
比如 00000000 00000000 00000000 00000101 是 5的 原码。<br>
反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。<br>
取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）</p>
<pre><code>样例1
输入：9
输出：2
解释：9的二进制表示是1001，一共有2个1。
样例2
输入：-2
输出：31
解释：-2在计算机里会被表示成11111111111111111111111111111110，
      一共有31个1。
</code></pre>
<p>思路：每次与 1 &amp;，就相当于看看二进制末尾是不是1，然后右移一位，但是有个问题就是正数右移会在前面补0是ok的，但是负数会在前面补1，这样就会多算好多，所以可以把负数变为无符号整数，如果是正数不会变，如果是负数，那么会变为绝对值的反码，但是依然表示为正数，这样就可以了。</p>
<pre><code class="language-c++">class Solution {
public:
    int NumberOf1(int n) {
        int res = 0;
        unsigned int un = n;
        while (un){
            res += un &amp; 1, un &gt;&gt;= 1;
        }
        return res;
    }
};
</code></pre>
<p>并且由于题目中说了这是一个32位的整数，所以也可以一位一位的进行判断：</p>
<pre><code class="language-c++">class Solution {
public:
    int NumberOf1(int n) {
        int res = 0;
        for (int i = 32; i &gt; 0; i --){
            res += n &gt;&gt; i &amp; 1;
        }
        return res;
    }
};
</code></pre>
<h4 id="27-数值的整数次方">27. 数值的整数次方</h4>
<p>题目描述: 实现函数double Power(double base, int exponent)，求base的 exponent次方。<br>
不得使用库函数，同时不需要考虑大数问题。<br>
注意：<br>
不会出现底数和指数同为0的情况</p>
<pre><code>样例1
输入：10 ，2
输出：100

样例2
输入：10 ，-2  
输出：0.01
</code></pre>
<p>思路：就正常相乘就可以了，判断一下指数的正负，&lt; 0 的话翻一下就好了。</p>
<pre><code class="language-c++">class Solution {
public:
    double Power(double base, int exponent) {
        if (exponent == 0) return 1;
        if (exponent &gt; 0) return help(base, exponent);
        else return 1 / help(base, -exponent);
    }
    
    double help(double base, int exponent){
        int k = base;
        while (-- exponent){
            base *= k;
        }
        return base;
    }
};
</code></pre>
<p>也可以不用这么麻烦：</p>
<pre><code class="language-c++">class Solution {
public:
    double Power(double base, int exponent) {
        double res = 1;
        bool minus = false;
        if (exponent &lt; 0) minus = true, exponent = -exponent;
        while (exponent --){
            res *= base;
        }
        if (minus) return 1 / res;
        return res;
    }
};
</code></pre>
<h4 id="28-在o1时间删除链表结点">28. 在O(1)时间删除链表结点</h4>
<p>题目描述：给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。<br>
假设链表一定存在，并且该节点一定不是尾节点。<br>
思路：之前做过这道题，因为不知道它之前的节点，所以可以把它后面的节点赋值给它，然后删掉它后面的点，曲线救国。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    }
};
</code></pre>
<h4 id="29-删除链表中重复的节点">29. 删除链表中重复的节点</h4>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。</p>
<pre><code>样例1
输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出：1-&gt;2-&gt;5

样例2
输入：1-&gt;1-&gt;1-&gt;2-&gt;3
输出：2-&gt;3
</code></pre>
<p>思路：值得注意的重复的节点不会保留，所以头结点是会变的，需要创建虚拟头结点。需要两个指针，p指向一段末尾，q指向一段的开头，如果发现q的这一段长度大于一，那么q移动到另一段的开头，p直接指向q就可以删掉这一段。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplication(ListNode* head) {
        auto dummy = new ListNode(-1);
        dummy-&gt;next = head;
        
        auto p = dummy;
        while (p-&gt;next){
            auto q = p-&gt;next;
            while (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;
            if (p-&gt;next-&gt;next == q) p = p-&gt;next;
            else p-&gt;next = q;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<h4 id="30-正则表达式匹配">30. 正则表达式匹配</h4>
<p>题目描述：请实现一个函数用来匹配包括'.'和'<em>'的正则表达式。<br>
模式中的字符'.'表示任意一个字符，而'</em>'表示它前面的字符可以出现任意次（含0次）。<br>
在本题中，匹配是指字符串的所有字符匹配整个模式。<br>
例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</p>
<pre><code>样例
输入：
s=&quot;aa&quot;
p=&quot;a*&quot;

输出:true
</code></pre>
<h4 id="32-调整数组顺序使奇数位于偶数前面">32. 调整数组顺序使奇数位于偶数前面</h4>
<p>题目描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序。<br>
使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<pre><code>样例
输入：[1,2,3,4,5]
输出: [1,3,5,2,4]
</code></pre>
<p>思路：返回的顺序只要奇数在前，偶数在后面，不需要内部有序。设定两个指针，第一个l之前全是奇数，第二个r后面全是偶数，每次l++，r--，这样每次交换两个指针位置的数字即可。</p>
<pre><code class="language-c++">class Solution {
public:
    void reOrderArray(vector&lt;int&gt; &amp;array) {
        int l = 0, r = array.size();
        while (l &lt; r){
            while (l &lt; r &amp;&amp; array[l] % 2 == 1) l ++;
            while (l &lt; r &amp;&amp; array[r] % 2 == 0) r --;
            if (l &lt; r){
                int tmp = array[l];
                array[l] = array[r], array[r] = tmp;
            }
        }
    }
};
</code></pre>
<h4 id="33-链表中倒数第k个节点">33. 链表中倒数第k个节点</h4>
<p>题目描述: 输入一个链表，输出该链表中倒数第k个结点。<br>
注意：<br>
k &gt;= 0;<br>
如果k大于链表长度，则返回 NULL;</p>
<pre><code>样例
输入：链表：1-&gt;2-&gt;3-&gt;4-&gt;5 ，k=2
输出：4
</code></pre>
<p>思路：倒数第k个就是正数第n - k个，所以先遍历一遍找出链表的长度，然后再遍历一遍，找到第n-k个返回即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* findKthToTail(ListNode* head, int k) {
        auto p = head;
        int n = 0;
        for (auto t = head; t; t = t-&gt;next) n++;
        if (k &gt; n) return NULL;
        for (int i = 0; i &lt; n - k; i ++) p = p-&gt;next;
        return p;
    }
};
</code></pre>
<h4 id="34-链表中环的入口结点">34. 链表中环的入口结点</h4>
<p>题目描述：给定一个链表，若其中包含环，则输出环的入口节点。<br>
若其中不包含环，则输出null。<br>
思路：之前做过这道题，LC链表专题。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *entryNodeOfLoop(ListNode *head) {
        auto fast = head, slow = head;
        while (fast)
        {
            fast = fast -&gt; next;
            slow = slow -&gt; next;
            if (fast) fast = fast -&gt; next;
            else break;
            
            if (fast == slow){
                slow = head;
                while (slow != fast)
                {
                    slow = slow -&gt; next;
                    fast = fast -&gt; next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指offer刷题-Week1]]></title>
        <id>https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day1</id>
        <link href="https://tudouvvv.github.io//post/jian-zhi-offer-shua-ti-day1">
        </link>
        <updated>2019-10-25T00:54:07.000Z</updated>
        <content type="html"><![CDATA[<h4 id="13-找出数组中重复的数字">13. 找出数组中重复的数字</h4>
<p>给定一个长度为 n 的整数数组 nums，数组中所有的数字都在 0∼n−1 的范围内。<br>
数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。<br>
请找出数组中任意一个重复的数字。<br>
注意：如果某些数字不在 0∼n−1 的范围内，或数组中不包含重复数字，则返回 -1；</p>
<pre><code>样例
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。
返回 2 或 3。
</code></pre>
<p>思路：刚开始看到这道题就想用字典来做，用字典存储每个数字出现的次数，然后&gt;1的话返回即可。</p>
<pre><code class="language-c++">class Solution {
public:
    unordered_map&lt;int, int&gt; hash;
    int duplicateInArray(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return -1;
        for (auto num : nums)
        {   
            if (num &gt; 0 || num &lt; nums.size() - 1)
                hash[num] ++;
            else return -1;
        }
        int t = 0;
        for (int i = 0; i &lt; nums.size(); i ++)
        {
            t = max(t, hash[nums[i]]);
            if (t &gt; 1) return nums[i];
        }
        if (t == 1) return -1;
    }
};
</code></pre>
<p>一个更妙的解题方法：因为一共有n个数，n个坑，所以可以把每个数放在属于自己的位置上，如果出现两个相同的数字，那么返回即可。</p>
<pre><code class="language-c++">class Solution {
public:
    int duplicateInArray(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        for (auto num : nums) 
        {
            if (num &lt; 0 || num &gt; n - 1) return -1;
        }
        for (int i = 0; i &lt; n; i ++)
        {
            while (i != nums[i] &amp;&amp; nums[nums[i]] != nums[i]) swap(nums[i], nums[nums[i]]);
            if (i != nums[i] &amp;&amp; nums[i] == nums[nums[i]]) return nums[i];
        }
        return -1;
    }
};
</code></pre>
<p>update:</p>
<pre><code class="language-python">class Solution(object):
    def duplicateInArray(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype int
        &quot;&quot;&quot;
        n = len(nums)
        for x in nums:
            if (x &lt; 0 or x &gt; n - 1): return -1
        i = 0
        for i in range(n):
            while (i != nums[i] and nums[nums[i]] != nums[i]):
                x, y = nums[i], nums[nums[i]]
                nums[nums[i]], nums[i] = x, y
            if (i != nums[i] and nums[i] == nums[nums[i]]):
                return nums[i]
        return -1
</code></pre>
<h4 id="14-不修改数组找出重复的数字">14. 不修改数组找出重复的数字</h4>
<p>给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。<br>
请找出数组中任意一个重复的数，但不能修改输入的数组。</p>
<pre><code>样例
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。
返回 2 或 3。
</code></pre>
<p>思考题：如果只能使用 O(1) 的额外空间，该怎么做呢？<br>
思路：之前做过这道题，用二分即可。</p>
<pre><code class="language-c++">class Solution {
public:
    int duplicateInArray(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return -1;
        int n = nums.size();
        int l = 1, r = n - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            int cnt = 0;
            for (auto num : nums)
            {
                if (num &gt;= l &amp;&amp; num &lt;= mid) cnt ++;
            }
            if (cnt &gt; mid - l + 1) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<h4 id="15-二维数组中的查找">15. 二维数组中的查找</h4>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>样例
输入数组：
[
  [1,2,8,9]，
  [2,4,9,12]，
  [4,7,10,13]，
  [6,8,11,15]
]
</code></pre>
<p>如果输入查找数值为7，则返回true，<br>
如果输入查找数值为5，则返回false。<br>
思路:刚开始看到这道题以为和<a href="https://leetcode.com/problems/search-a-2d-matrix/">LeetCode74</a>一模一样，用二分写了，后来发现不一样hh。<br>
一个很妙的方法：每次都用右上角(左下角)的点进行比较，因为这个点的左边一行比它小，下边一列比它大，所以如果大于它，那么可以去掉一行，小于它可以去掉一列，直到找到答案。</p>
<pre><code class="language-c++">class Solution {
public:
    bool searchArray(vector&lt;vector&lt;int&gt;&gt; array, int target) {
        if (array.empty() || array[0].empty()) return false;
        int i = 0, j = array[0].size() - 1;
        while (i &lt; array.size() &amp;&amp; j &gt;= 0)
        {
            if (array[i][j] == target) return true;
            if (array[i][j] &gt; target) j --;
            else i ++;
        }
        return false;
    }
};
</code></pre>
<h4 id="16-替换空格">16. 替换空格</h4>
<p>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。<br>
你可以假定输入字符串的长度最大是1000。<br>
注意输出字符串的长度可能大于1000。</p>
<pre><code>样例
输入：&quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;
</code></pre>
<p>思路：可以设定一个新的字符串，每次遇见空格就加'%20'，其它的就加上即可。</p>
<pre><code class="language-c++">class Solution {
public:
    string replaceSpaces(string &amp;str) {
        string res;
        for (auto c : str)
        {
            if (c == ' ') res += &quot;%20&quot;;
            else res += c;
        }
        return res;
    }
};
</code></pre>
<p>也可以首先计算出替换空格后的字符串长度，然后扩充原来的字符串，用两个指针直接在原字符串上进行修改。</p>
<pre><code class="language-c++">class Solution {
public:
    string replaceSpaces(string &amp;str) {
        int len = 0;
        for (auto c : str)
        {
            if (c == ' ') len += 3;
            else len += 1;
        }
        int i = str.size() - 1, j = len - 1;
        str.resize(len);
        while (i &gt;= 0)
        {
            if (str[i] == ' ')
            {
                str[j --] = '0';
                str[j --] = '2';
                str[j --] = '%';
            }
            else str[j --] = str[i];
            i --;
        }
        return str;
    }
};
</code></pre>
<p>当然用python来写肯定更简单</p>
<pre><code class="language-python">class Solution(object):
    def replaceSpaces(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        res = s.split(' ')
        return '%20'.join(res)
</code></pre>
<h4 id="17-从尾到头打印链表">17. 从尾到头打印链表</h4>
<p>题目描述:输入一个链表的头结点，按照<code>从尾到头</code>的顺序返回节点的值。<br>
返回的结果用数组存储。</p>
<pre><code>样例
输入：[2, 3, 5]
返回：[5, 3, 2]
</code></pre>
<p>思路：首先反转链表，最后遍历一次，把每个节点的值放进列表中即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; printListReversingly(ListNode* head) {
        if (! head) return {};
        vector&lt;int&gt; res;
        auto a = head, b = head -&gt;next;
        while (b)
        {
            auto c = b-&gt;next;
            b -&gt; next = a;
            a = b;
            b = c;
        }
        head -&gt; next = NULL;
        head = a;
        for (auto p = head; p; p = p-&gt;next) res.push_back(p-&gt;val);
        return res;
    }
};
</code></pre>
<p>也可以不用翻转列表，直接先得到正常顺序的节点值列表，然后翻转这个列表即可。</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; printListReversingly(ListNode* head) {
        vector &lt;int&gt; res;
        for (auto p = head; p; p = p-&gt;next) res.push_back(p-&gt;val);
        reverse(res.begin(), res.end());
        return res;
    }
};
</code></pre>
<h4 id="18-重建二叉树">18. 重建二叉树</h4>
<p>题目描述：输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。<br>
注意:<br>
二叉树中每个节点的值都互不相同；<br>
输入的前序遍历和中序遍历一定合法；</p>
<pre><code>样例
给定：
前序遍历是：[3, 9, 20, 15, 7]
中序遍历是：[9, 3, 15, 20, 7]
返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]
返回的二叉树如下所示：
    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>思路：之前做过这道题，因为前序遍历的第一个数字肯定是根节点，然后在中序遍历中找到这个数，那么它的左边就是左子树，右边就是右子树，然后不断递归即可。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map &lt;int, int&gt; pos;
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        int n = preorder.size();
        for (int i = 0; i &lt; n; i ++) pos[inorder[i]] = i;
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);
    }
    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir)
    {
        if (pl &gt; pr) return NULL;
        int val = preorder[pl];
        int k = pos[val];
        int len = k - il;
        auto root = new TreeNode(val);
        root-&gt;left = dfs(preorder, inorder, pl + 1, pl + len, il, k - 1);
        root-&gt;right = dfs(preorder, inorder, pl + len + 1, pr, k + 1, ir);
        return root;
    }
};
</code></pre>
<h4 id="19-二叉树的下一个节点">19. 二叉树的下一个节点</h4>
<p>题目描述：给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。<br>
注意：<br>
如果给定的节点是中序遍历序列的最后一个，则返回空节点;<br>
二叉树一定不为空，且给定的节点一定不是空节点；</p>
<pre><code>样例
假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。
则应返回值等于3的节点。
解释：该二叉树的结构如下，2的后继节点是3。
  2
 / \
1   3
</code></pre>
<p>思路：树的后继：当前节点在中序遍历中的下一个节点，即整颗二叉搜索树中比我大的最小的元素。<br>
要分情况讨论<br>
<img src="https://tudouvvv.github.io//post-images/1572309512253.png" alt=""></p>
<ol>
<li>如图，如果当前节点有右儿子，那么右子树最左侧的节点就是当前节点的后继，比如F的后继就是H；</li>
<li>如果没有的话，就要去寻找它的父节点的，如果当前节点是它父节点的左子树，那么它的父节点就是后继,比如H的后继就是E，否则，就一直向上寻找，比如D，它是它父节点的右子树，那么就继续向上找，直到找到是左子树的父节点，它的父节点是C，C是父节点F的左子树，所以F就是D的后继。</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* p) {
        if (p-&gt;right)
        {
            p = p-&gt;right;
            while (p-&gt;left) p = p-&gt;left;
            return p;
        }
        while (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father;
        return p-&gt;father;
    }
};
</code></pre>
<h4 id="20-用两个栈实现队列">20. 用两个栈实现队列</h4>
<p>题目描述: 请用栈实现一个队列，支持如下四种操作：<br>
push(x) – 将元素x插到队尾；<br>
pop() – 将队首的元素弹出，并返回该元素；<br>
peek() – 返回队首元素；<br>
empty() – 返回队列是否为空；<br>
注意：<br>
你只能使用栈的标准操作：push to top，peek/pop from top, size 和 is empty；<br>
如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；<br>
输入数据保证合法，例如，在队列为空时，不会进行pop或者peek等操作；<br>
思路：用两个栈来做，当需要pop的时候可以把原始栈内元素push进cache栈中，然后pop就是队首元素，然后再恢复，peek操作也一样。</p>
<pre><code class="language-c++">class MyQueue {
public:
    stack&lt;int&gt; stk, help;
    /** Initialize your data structure here. */
    MyQueue() {
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stk.push(x);
    }
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        while (! stk.empty())
        {
            int k = stk.top();
            help.push(k);
            stk.pop();
        }
        int t = help.top();
        help.pop();
        while (! help.empty())
        {
            int k = help.top();
            stk.push(k);
            help.pop();
        }
        return t;
    }
    
    /** Get the front element. */
    int peek() {
        while (! stk.empty())
        {
            int k = stk.top();
            help.push(k);
            stk.pop();
        }
        int t = help.top();
        while (! help.empty())
        {
            int k = help.top();
            stk.push(k);
            help.pop();
        }
        return t;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return stk.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * bool param_4 = obj.empty();
 */
</code></pre>
<p>可以写一个函数，来进行两个栈内元素互换的操作。</p>
<pre><code class="language-c++">class MyQueue {
public:
    /** Initialize your data structure here. */
    stack&lt;int&gt; stk, cache;
    MyQueue() {
        
    }
    
    void copy(stack&lt;int&gt; &amp;a, stack&lt;int&gt; &amp;b){
        while (a.size()){
            b.push(a.top());
            a.pop();
        }
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stk.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        copy(stk, cache);
        int val = cache.top();
        cache.pop();
        copy(cache, stk);
        return val;
    }
    
    /** Get the front element. */
    int peek() {
        copy(stk, cache);
        int val = cache.top();
        copy(cache, stk);
        return val;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return stk.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * bool param_4 = obj.empty();
 */
</code></pre>
<h4 id="21-斐波那契数列">21. 斐波那契数列</h4>
<p>题目描述：输入一个整数 n ，求斐波那契数列的第 n 项。<br>
假定从0开始，第0项为0。(n&lt;=39)</p>
<pre><code>样例
输入整数 n=5 
返回 5
</code></pre>
<p>思路：设定一个初始值全为1，大小为n的vector，有几个特殊情况需要判断一下，如果n = 0，返回0， 如果n = 1 或者 n = 2，返回1，然后就用迭代方法计算即可，其实也可以用一个滚动数组来节省空间。</p>
<pre><code class="language-c++">class Solution {
public:
    int Fibonacci(int n) {
        vector&lt;int&gt; res(n, 1);
        if (n == 0) return 0;
        if (n == 1 || n == 2) return 1;
        for (int i = 2; i &lt; n; i ++)
        {
            res[i] = res[i - 1] + res[i - 2];
        }
        return res[n - 1];
    }
};
</code></pre>
<p>滚动数组：</p>
<pre><code class="language-c++">class Solution {
public:
    int Fibonacci(int n) {
        int a = 0, b = 1;
        while (n --)
        {
            int c = a + b;
            a = b, b = c;
        }
        return a;
    }
};
</code></pre>
<p>ps.<a href="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法</a></p>
<h4 id="22-旋转数组的最小数字">22. 旋转数组的最小数字</h4>
<p>题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>
输入一个升序的数组的一个旋转，输出旋转数组的最小元素。<br>
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>
数组可能包含重复项。<br>
注意：数组内所含元素非负，若数组大小为0，请返回-1。</p>
<pre><code>样例
输入：nums=[2,2,2,0,1]
输出：0
</code></pre>
<p>思路:之前做过这道题，唯一不同的是，这道题中有重复元素，所以如果用二分做的话，需要先把后面的重复元素删掉，保证二分的性质。</p>
<pre><code class="language-c++">class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return -1;
        int l = 0, r = nums.size() - 1;
        while (nums[r] == nums[0]) r--;
        if (nums[r] &gt; nums[0]) return nums[0];
        int k = r;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt; nums[k]) r = mid;
            else l = mid + 1;
        }
        return nums[l];
    }
};
</code></pre>
<h4 id="23-矩阵中的路径">23. 矩阵中的路径</h4>
<p>题目描述: 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>
路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。<br>
如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。</p>
<pre><code>注意：
输入的路径不为空；
所有出现的字符均为大写英文字母；
</code></pre>
<p>思路: 之前做过这道题但是都忘记了... 就是先枚举起点，然后在上下左右的去寻找后面的单词。</p>
<pre><code class="language-c++">class Solution {
public:
    bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str) {
        if (matrix.empty() || matrix[0].empty()) return false;
        int n = matrix.size(), m = matrix[0].size();
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; m; j++)
                if (dfs(matrix, str, i, j, 0))
                    return true;
        return false;
    }
    
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string &amp; str, int x, int y, int u){
        if (matrix[x][y] != str[u]) return false;
        if (u == str.size() - 1) return true;
        char t = matrix[x][y];
        matrix[x][y] = '*';
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        for (int i = 0; i &lt; 4; i ++)
        {
            int a = x + dx[i], b = y + dy[i];
            if (a &gt;= 0 &amp;&amp; a &lt; matrix.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; matrix[0].size())
            {
                if (dfs(matrix, str, a, b, u + 1)) return true;
            }
        }
        matrix[x][y] = t;
        return false;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[做作的日常①]]></title>
        <id>https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang</id>
        <link href="https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang">
        </link>
        <updated>2019-10-07T12:45:12.000Z</updated>
        <content type="html"><![CDATA[<p>十一就要结束了呀！！！<br>
时间呀时间，你慢点撒！</p>
<ol>
<li>求斐波那契数列的前1000个数（当时连斐波那契数列是啥都不知道hh）<br>
斐波那契数列是这样一个数列：1, 1, 2, 3, 5, 8, ..., ...<br>
即f(1) = 1, f(2) = 1, f(n) = f(n - 1) + f(n - 2)这样一个递推关系式<br>
可以开一个1000个空间的数组，也可以用while循环来做，但是没啥区别，都是要通过迭代的方式来进行。<br>
Python</li>
</ol>
<pre><code class="language-python">class Solution:
    def Fibonacci_sequence(self, nums):
        f = [0 for _ in range(nums)]
        if nums == 1:
            return [1]
        if nums == 2:
            return [1, 1]
        f[0], f[1] = 1, 1
        for i in range(2, nums):
            f[i] = f[i - 1] + f[i - 2]
        return f
</code></pre>
<ol start="2">
<li>求前1000个质数<br>
质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。<br>
可以写一个函数来判断一个数是不是质数，然后主函数用一个while循环进行判断，直到有1000个数，而且判断的时候只需要从2到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>即可。<br>
Python</li>
</ol>
<pre><code class="language-python">class Solution:
    def Prime(self, nums):
        f = [2]
        if nums == 1:
            return f
        i = 3
        while len(f) &lt; nums:
            if self.is_prime(i): f.append(i)
            i += 1
        return f

    def is_prime(self, n):
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第八周(动态规划专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第八周(动态规划专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第八周(动态规划专题)">
        </link>
        <updated>2019-09-27T09:32:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="53-maximum-subarray"><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></h4>
<p>题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<pre><code>示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre>
<p>分析：</p>
<ol>
<li>要计算连续的最大和，其实就是要看加了某个数之后的和与该数的大小，如果变小了那就没必要了，所以每次进行判断，如果前面的数&gt;0，那么就加上它，这样遍历一遍，整个数组中最大的值就是我们要找的答案。<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans = INT_MIN;
        for(int i = 1; i &lt; nums.size(); i ++)
        {
            if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1];
        }
        for (auto num : nums)  ans = max(ans, num);
        return ans;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        for i in range(1, len(nums)):
            if nums[i - 1] &gt; 0:
                nums[i] += nums[i - 1]
        return max(nums)
</code></pre>
<ol start="2">
<li>动态规划<br>
从集合的角度来考虑DP问题，最重要的就是要求出状态转移方程是什么样子的，对每个nums[i]来说，它的连续子数组的和共有以下情况:</li>
</ol>
<ul>
<li>nums[1] + nums[2] + ... + nums[i]</li>
<li>nums[2] + nums[3] + ... + nums[i]</li>
<li>...</li>
<li>0 + nums[i]<br>
我们去掉nums[i]来找这些情况中的最大和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> ，这些情况中的最大和就等于nums[i - 1]情况下的最大和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以状态转移方程就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f(x) = max(0,  f(x-1)) + nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int res= INT_MIN, last = 0;
        for (int i = 0; i &lt; nums.size(); i ++)
        {
            int now = max(0, last) + nums[i];
            res = max(res, now);
            last = now;
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        res = -float('inf')
        last = 0
        for i in range(len(nums)):
            now = max(0, last) + nums[i]
            res = max(res, now)
            last = now
        return res
</code></pre>
<h4 id="120-triangle"><a href="https://leetcode.com/problems/triangle/">120. Triangle</a></h4>
<p>题目描述：给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<pre><code>例如，给定三角形：
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
</code></pre>
<p>分析：首先记录第一行的数字res = triangle[0][0]，初始时i = 0，然后从第二行开始，res += min(char[i], char[i + 1])，这是它相邻的两个位置，记录min_char的index，然后替换i，继续枚举。<br>
Python❌</p>
<pre><code class="language-python">class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        if not list: return 0
        res = triangle[0][0]
        i = 0
        for char in triangle[1:]:
            min_char = min(char[i], char[i + 1])
            res += min_char
            i = char.index(min_char)
        return res
</code></pre>
<p>但是不知道为什么有个案例过不了<code>[[-1],[2,3],[1,-1,-3]]</code>，讲道理不是应该-1 + 2 + -1 = 0 嘛，不知道为什么答案是-1。<br>
✅ps.我明白了，这并不是一个贪心算法的过程，而是要看全局，所以正确的路径应该是-1 + 3 + -3 = -1。<br>
所以这也是一道用dp解决的问题：<br>
<img src="https://tudouvvv.github.io//post-images/1569826922552.png" alt=""><br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(n));
        f[0][0] = nums[0][0];
        for(int i = 1; i &lt; n; i ++)
            for(int j = 0; j &lt;= i; j ++)
            {
                f[i][j] = INT_MAX;
                if (j &gt; 0) f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j]);
                if (j &lt; i) f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j]);
            }
        long long res = INT_MAX;
        for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1][i]);
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def minimumTotal(self, nums: List[List[int]]) -&gt; int:
        n = len(nums)
        f = [[0 for _ in range(n)] for _ in range(n)]
        f[0][0] = nums[0][0]
        for i in range(1, n):
            for j in range(i + 1):
                f[i][j] = float('inf')
                if j &gt; 0: f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j])
                if j &lt; i: f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j])
        res = float('inf')
        for i in range(n):
            res = min(res, f[n - 1][i])
        return res
</code></pre>
<p>因为我们最后只需要最后一行的数据进行判断，并且每行的结果只依赖于上一行的结果，所以完全不需要开n行数组，只需要开两行，然后滚动就行，这就是滚动数组：</p>
<pre><code class="language-c++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;long long&gt;&gt; f(2, vector&lt;long long&gt;(n));
        f[0][0] = nums[0][0];
        for(int i = 1; i &lt; n; i ++)
            for(int j = 0; j &lt;= i; j ++)
            {
                f[i &amp; 1][j] = INT_MAX;
                if (j &gt; 0) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j - 1] + nums[i][j]);
                if (j &lt; i) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j] + nums[i][j]);
            }
        long long res = INT_MAX;
        for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1 &amp; 1][i]);
        return res;
    }
};
</code></pre>
<h4 id="63-unique-paths-ii"><a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a></h4>
<p>题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>
<img src="https://tudouvvv.github.io//post-images/1569829741021.png" alt=""><br>
网格中的障碍物和空位置分别用 1 和 0 来表示。<br>
说明：m 和 n 的值均不超过 100。</p>
<pre><code>示例:
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</code></pre>
<p>分析：<img src="https://tudouvvv.github.io//post-images/1569830381210.png" alt=""><br>
对于状态计算来说，分为两种情况：</p>
<ol>
<li>最后一步从上往下走: f[i][j] += f[i - 1][j]</li>
<li>最后一步从左往右走: f[i][j] += f[i][j - 1]<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; g) {
        int n = g.size(), m = g[0].size();
        vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(m));
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; m; j ++)
            {
                if (g[i][j]) continue;
                if (!i &amp;&amp; !j) f[i][j] = 1;
                if (i &gt; 0) f[i][j] += f[i - 1][j];
                if (j &gt; 0) f[i][j] += f[i][j - 1];
            }
        return f[n - 1][m - 1];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int:
        n = len(g)
        m = len(g[0])
        f = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if g[i][j]: continue;
                if i == 0 and j == 0: f[i][j] = 1
                if (i &gt; 0): f[i][j] += f[i - 1][j]
                if (j &gt; 0): f[i][j] += f[i][j - 1]
        return f[n - 1][m - 1]
</code></pre>
<h4 id="91-decode-ways"><a href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a></h4>
<p>题目描述：一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>
'A' -&gt; 1<br>
'B' -&gt; 2<br>
...<br>
'Z' -&gt; 26<br>
给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<pre><code>示例:
输入: &quot;226&quot;
输出: 3
解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。
</code></pre>
<p>分析：还是用DP的思路来解决：<br>
<img src="https://tudouvvv.github.io//post-images/1569833953551.png" alt=""><br>
首先状态表示，f[i]表示所有由前i个数字解码得到的字符串的个数，然后是状态计算，共有两种情况:最后一个字母是一个数字f[i - 1]，最后一个字母是两个数字f[i - 2]，特别还是要考虑边界条件。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector&lt;int&gt; f(n + 1);
        f[0] = 1;
        for (int i = 1; i &lt;= n; i ++)
        {
            if (s[i - 1] != '0') f[i] += f[i - 1];
            if (i &gt;= 2)
            {
                int t = (s[i - 2] - '0') * 10 + s[i - 1] - '0';
                if (t &gt;= 10 and t &lt;= 26) f[i] += f[i - 2];
            }
        }
        return f[n];    
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        n = len(s)
        f = [0 for _ in range(n + 1)]
        f[0] = 1
        
        for i in range(1, n + 1):
            if s[i - 1] != '0': f[i] += f[i - 1]
            if i &gt; 1:
                t = int(s[i - 2]) * 10 + int(s[i - 1])
                if 10 &lt;= t &lt;=26:
                    f[i] += f[i - 2]
        return f[n]
</code></pre>
<h4 id="198-house-robber"><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></h4>
<p>题目描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<pre><code>示例:
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</code></pre>
<p>分析：我把奇数的加一起，偶数的加一起，max一下不就可以了嘛</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        res1 = 0
        res2 = 0
        for i in range(len(nums)):
            if i % 2 == 0:
                res1 += nums[i]
            else:
                res2 += nums[i]
        return max(res1, res2)
</code></pre>
<p>好吧，少考虑了情况，如果是[2, 1, 1, 2]的话就不需要隔一个偷一个了。<br>
考虑用DP来做，用两个数组分别表示状态：<br>
<img src="https://tudouvvv.github.io//post-images/1570085349472.png" alt=""><br>
那么在进行状态计算的时候，f[i]因为表示不取nums[i]的最大值，所以就等于nums[i-1]的最大值，所以f[i] = max(f[i - 1], g[i - 1])<br>
g[i]表示选了nums[i]的最大值，既然选了nums[i]，那么肯定没有选nums[i - 1]，于是g[i] = f[i - 1] + nums[i]。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; f(n + 1), g(n + 1);
        
        for (int i = 1; i &lt;=n; i ++ )
        {
            f[i] = max(f[i - 1], g[i - 1]);
            g[i] = f[i - 1] + nums[i - 1];
        }
        
        return max(f[n], g[n]);
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [0 for _ in range(n + 1)]
        g = [0 for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            f[i] = max(f[i - 1], g[i - 1])
            g[i] = f[i - 1] + nums[i - 1]
            
        return max(f[n], g[n])
</code></pre>
<h4 id="300-longest-increasing-subsequence"><a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></h4>
<p>题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<pre><code>示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
</code></pre>
<p>Note:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。<br>
分析：用DP来解决，首先状态表示f[i]：表示以第i个数结尾的上升子序列的最大值；然后是状态更新，我们要遍历从0到i的所有数，如果nums[j] &lt; nums[i]， 就说明它可i以被放进去，那么f[i] = max(f[i], f[j] + 1)，最后再遍历f，找出最大值即可。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; f(n, 1);
        
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; i; j ++)
                if (nums[j] &lt; nums[i])
                {
                    f[i] = max(f[i], f[j] + 1);
                }
        
        int res = 0;
        for (int i = 0; i &lt; n; i ++) res = max(res, f[i]);
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [1 for _ in range(n)]
        
        for i in range(n):
            for j in range(i):
                if nums[j] &lt; nums[i]:
                    f[i] = max(f[i], f[j] + 1)
        
        res = 0
        for i in range(n): res = max(res, f[i])
        return res
</code></pre>
<h4 id="72-edit-distance"><a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a></h4>
<p>题目描述：给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>
你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<pre><code>示例:
输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出: 3
解释: 
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')
</code></pre>
<p>分析：首先集合表示：f[i, j]表示将第一个字符串的前i个字母，变成第二个字符串的前j个字母的方案的最小值，那么在进行状态计算时，我们考虑最后一步的情况，由于它共有三种操作方式，所以最后一步的情况如下：</p>
<ol>
<li>插入：我在第一个字符串中插入一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i个字符和第二个字符串的前j - 1个字符相同，所以f[i, j] = f[i, j - 1] + 1</li>
<li>删除：我在第一个字符串中删除一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i - 1个字符和第二个字符串的前j的字符相同，所以f[i, j] = f[i - 1, j] + 1</li>
<li>替换：替换又分为两种情况：1）第一个字符串的第i个字符和第二个字符串的第j个字符是相同的，不需要替换了，所以f[i, j] = f[i - 1, j - 1]; 2）第一个字符串的第i个字符和第二个字符串的第j个字符是不同的，需要替换一下，所以f[i, j] = f[i - 1, j - 1] + 1;<br>
最后只需要在上面四种方案中求一个最小值代表状态即可。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));
        for (int i = 0; i &lt;= n; i ++) f[i][0] = i;
        for (int i = 0; i &lt;= m; i ++) f[0][i] = i;
        for (int i = 1; i &lt;= n; i ++)
            for (int j = 1; j &lt;= m; j ++)
            {
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1;
                f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i -1] != word2[j - 1]));
            }
        
        return f[n][m];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        n, m = len(word1), len(word2)
        f = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
        for i in range(n + 1): f[i][0] = i
        for i in range(m + 1): f[0][i] = i
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1
                f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i - 1] != word2[j - 1]));
        return f[n][m]
</code></pre>
<h4 id="518-coin-change-2"><a href="https://leetcode.com/problems/coin-change-2/">518. Coin Change 2</a></h4>
<p>题目描述：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。<br>
Note:<br>
你可以假设：</p>
<ul>
<li>0 &lt;= amount (总金额) &lt;= 5000</li>
<li>1 &lt;= coin (硬币面额) &lt;= 5000</li>
<li>硬币种类不超过 500 种</li>
<li>结果符合 32 位符号整数</li>
</ul>
<pre><code>示例:
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre>
<p>分析：首先状态表示f[i,j]表示为用前i个硬币凑出总钱数为j的凑法的数量，那么在状态表示时，有很多种情况：</p>
<ol>
<li>用了0个第i个硬币，所以f[i, j] = f[i - 1, j];</li>
<li>用了t个第i个硬币，所以f[i, j] = f[i - 1, j - t * coins[i]];<br>
所以，f[i ,j] = f[i - 1, j] + f[i - 1, j - c] + f[i - 1, j - 2c] + ... + f[i - 1, j - kc]<br>
但是，f[i, j - c] = f[i - 1, j - c] + f[i - 1, j - 2c]  + ... + f[i - 1, j - kc]<br>
所以，我们可以用f[i, j - c]的状态替换掉后面一堆东西，于是f[i, j] = f[i - 1, j] + f[i, j - c]<br>
由于这里i只与上一层有关系，所以可以用滚动数组来求解，同时f[i - 1, j] 与 f[i , j]表示的j都是一样的，所以可以用一个一维的滚动数组来简化f[j] = f[j] + f[j - c]。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        int m = amount;
        vector&lt;int&gt; f(m + 1);
        f[0] = 1;
        for (auto c : coins)
            for (int j = c; j &lt;= m; j ++)
                f[j] += f[j - c];
        return f[m];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        m = amount
        f = [0 for _ in range(m + 1)]
        f[0] = 1
        for coin in coins:
            for j in range(coin, m + 1):
                f[j] += f[j - coin]
        return f[m]
</code></pre>
<h4 id="664-strange-printer"><a href="https://leetcode.com/problems/strange-printer/">664. Strange Printer</a></h4>
<p>题目描述：有台奇怪的打印机有以下两个特殊要求：<br>
打印机每次只能打印同一个字符序列。<br>
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。<br>
给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。</p>
<pre><code>示例:
输入: &quot;aba&quot;
输出: 2
解释: 首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 'a'。
</code></pre>
<p>分析：f[l][r]表示将[L, R]染成最终模样的方式的最小值：<br>
<img src="https://tudouvvv.github.io//post-images/1570433988785.png" alt=""><br>
首先是把端点染成想要的颜色，f[l][r] = f[l + 1][r] + 1<br>
然后另一种情况是染[l, k]，l和k处的颜色相同的话，f[l][r]= f[l][k - 1] + f[k + 1][r]<br>
最后求两者的最小值即可。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int strangePrinter(string s) {
        int n = s.size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1));
        if (s.empty()) return 0;
        for (int len = 1; len &lt;= n; len ++)
            for (int l = 0; l + len - 1 &lt; n; l ++)
            {
                int r = l + len - 1;
                f[l][r] = f[l + 1][r] + 1;
                for (int k = l + 1; k &lt;= r; k ++)
                    if (s[l] == s[k])
                        f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r]);
            }
        return f[0][n - 1];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def strangePrinter(self, s: str) -&gt; int:
        n = len(s)
        if n == 0: return 0
        f = [[0 for _ in range(n + 1)]for _ in range(n + 1)]
        for lens in range(1, n + 1):
            for l in range(0, n - lens + 1):
                r = l + lens - 1
                f[l][r] = f[l + 1][r] + 1
                for k in range(l + 1, r + 1):
                    if s[l] == s[k]:
                        f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r])
                        print(f)
        return f[0][n - 1]
</code></pre>
<h4 id="10-regular-expression-matching存疑">❌<a href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching</a>(存疑)</h4>
<p>题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p>
<pre><code>'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
</code></pre>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。<br>
Note:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li>
</ul>
<pre><code>示例:
输入:
s = &quot;aa&quot;
p = &quot;a*&quot;
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。
</code></pre>
<p>分析：考虑用DP来做，f[i][j]表示s的第i个字符与p的第j个字符是否匹配，我们现在已经得知了之前的状态，也就是f[i - 1][j - 1]，现在要考虑的就是s[i]与p[j]的关系：</p>
<ol>
<li>如果s[i] = p[j], 那么f[i][j] = f[i - 1][j - 1]</li>
<li>如果p[j] = '.', 那么f[i][j] = f[i - 1][j - 1]</li>
<li>如果p[j] = '*', 那么我们要考虑s[i] 与 p[j - 1]的关系：
<ol>
<li>如果s[i] != p[j - 1], 那么f[i][j] = f[i - 1][j - 2]，此时*表示匹配0个前面的字母</li>
<li>如果p[j - 1] = '.' || p[j - 1] = s[i]：</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第七周(基本数据结构专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第七周(基本数据结构专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第七周(基本数据结构专题)">
        </link>
        <updated>2019-09-23T07:09:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-two-sum"><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h4>
<p>题目描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<pre><code>示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<p>分析：可以设计一个字典来保存值与索引的映射关系，然后去找target-nums[i]是否在字典中，如果在并且该值不等于nums[i]的话(避免重复利用)，就说明这是一个答案。<br>
Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        dicts = {}
        for i, v in enumerate(nums):
            dicts[v] = i
        for i in range(len(nums)):
            if target - nums[i] in dicts and dicts[target - nums[i]] != i:
                return [i, dicts[target-nums[i]]]
</code></pre>
<p>也可以用hash表来做：<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hash;
        for (int i = 0; i &lt; nums.size(); i ++)
        {
            if (hash.count(target - nums[i]))  return{hash[target - nums[i]], i};
            hash[nums[i]] = i;
        }
        return {-1, -1};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        dicts = {}
        for i in range(len(nums)):
            if target - nums[i] in dicts:
                return [dicts[target - nums[i]], i]
            dicts[nums[i]] = i
        return [-1, -1]
</code></pre>
<p>Ps.</p>
<ul>
<li>if (hash.count(key)) 是判断hash表中是否存在关键字key；</li>
<li>if (hash[key]) 是判断key对应的value值是否是真，如果key在hash表中不存在，则会先为其创建默认值，比如int的默认值是0，vector<int>的默认值是vector<int>()；<br>
在C++中，如果想往哈希表中插入一对(key, value)，一般写hash[key] = value；<br>
如果想查找一个key是否存在，一般有两种写法：</li>
<li>if (hash.find(key) != hash.end())</li>
<li>if (hash.count(key) != 0)<br>
第二种写法短一些，所以用得比较多。<br>
来源：<a href="https://www.acwing.com/">AcWing</a></li>
</ul>
<h4 id="187-repeated-dna-sequences"><a href="https://leetcode.com/problems/repeated-dna-sequences/">187. Repeated DNA Sequences</a></h4>
<p>题目描述：所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。<br>
编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</p>
<pre><code>示例:=
输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;
输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]
</code></pre>
<p>分析：如果是确定的十个字母长的字符串，那是否可以从前往后枚举，至多就有n - 1中情况，这样是不是有点慢。<br>
好吧，确实是这样做的，先把字符串中长度为10的子串拿出啦插入到hash表中，然后统计次数，最后输出次数大于等于2的子串就可以了。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; findRepeatedDnaSequences(string s) {
        unordered_map &lt;string, int&gt; hash;
        vector&lt;string&gt; res;
        for (int i = 0; i + 10 &lt;= s.size(); i ++)
        {
            string str = s.substr(i, 10);
            hash[str] ++;
            if (hash[str] == 2) res.push_back(str);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findRepeatedDnaSequences(self, s: str) -&gt; List[str]:
        dicts = {}
        res  = []
        for i in range(len(s) - 9):
            substr = s[i : i + 10]
            dicts.setdefault(substr, 0)
            dicts[substr] += 1
            if dicts[substr] == 2: res.append(substr)
        return res
</code></pre>
<h4 id="706-design-hashmap"><a href="https://leetcode.com/problems/design-hashmap/">706. Design HashMap</a></h4>
<p>题目描述：不使用任何内建的哈希表库设计一个哈希映射<br>
具体地说，你的设计应该包含以下的功能</p>
<ul>
<li>put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。</li>
<li>get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。</li>
<li>remove(key)：如果映射中存在这个键，删除这个数值对。<br>
Note:</li>
<li>所有的值都在 [1, 1000000]的范围内。</li>
<li>操作的总数目在[1, 10000]范围内。</li>
<li>不要使用内建的哈希库。</li>
</ul>
<pre><code>示例：
MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);         
hashMap.get(1);            // 返回 1
hashMap.get(3);            // 返回 -1 (未找到)
hashMap.put(2, 1);         // 更新已有的值
hashMap.get(2);            // 返回 1 
hashMap.remove(2);         // 删除键为2的数据
hashMap.get(2);            // 返回 -1 (未找到) 
</code></pre>
<p>分析：为了避免插入的时候冲突，使用拉链法，用一个链表来存储映射到该位置的元素。</p>
<ol>
<li>对于put(key, value)操作:<br>
先求出key的哈希值(取模)，然后遍历该位置上的链表:<br>
如果链表中包含key，则更新其对应的value；<br>
如果链表中不包含key，则直接将（key，value）插入该链表中。</li>
<li>对于get(key)操作:<br>
求出key对应的哈希值后，遍历该位置上的链表.<br>
如果key在链表中，则返回其对应的value，否则返回-1。</li>
<li>对于remove(key)，求出key的哈希值后，遍历该位置上的链表，如果key在链表中，则将其删除。</li>
</ol>
<p>Python</p>
<pre><code class="language-python">class MyHashMap:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.hash = [[] for _ in range(20011)]
        # 开辟一个大数组，长度为质数，注意这里不能用 [[]] * 20011，会被覆盖
        # 一般定义成离2的整次幂比较远的质数，这样取模之后冲突的概率比较低。

    def put(self, key: int, value: int) -&gt; None:
        &quot;&quot;&quot;
        value will always be non-negative.
        &quot;&quot;&quot;
        index = key % 20011
        for item in self.hash[index]:
            if item[0] == key:
                item[1] = value
                return
        self.hash[index].append([key, value])

    def get(self, key: int) -&gt; int:
        &quot;&quot;&quot;
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        &quot;&quot;&quot;
        index = key % 20011
        for item in self.hash[index]:
            if item[0] == key:
                return item[1]
        return -1

    def remove(self, key: int) -&gt; None:
        &quot;&quot;&quot;
        Removes the mapping of the specified value key if this map contains a mapping for the key
        &quot;&quot;&quot;
        index = key % 20011
        delete = []
        for item in self.hash[index]:
            if item[0] == key:
                self.hash[index].remove(item)

# Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)
</code></pre>
<h4 id="652-find-duplicate-subtrees"><a href="https://leetcode.com/problems/find-duplicate-subtrees/">652. Find Duplicate Subtrees</a></h4>
<p>题目描述：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。<br>
两棵树重复是指它们具有相同的结构以及相同的结点值。<br>
分析:<br>
首先把所有的子树枚举出来，然后把该子树用hash映射成一个整数。然后在建一个hash表示每个子树出现的次数，寻找子树时可以使用前序遍历的深度优先搜索。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    int cnt = 0;
    unordered_map&lt;string, int&gt; hash;
    unordered_map&lt;int, int&gt; count;
    vector &lt;TreeNode*&gt; ans;
    
    string dfs(TreeNode* root)
    {
        if (!root) return to_string(hash[&quot;#&quot;]);
        
        auto left = dfs(root-&gt;left);
        auto right = dfs(root-&gt;right);
        string tree = to_string(root-&gt;val) + ',' + left + ',' + right;
        if (! hash.count(tree)) hash[tree] = ++ cnt;
        int t = hash[tree];
        count[t] ++ ;
        if (count[t] == 2) ans.push_back(root);
        
        return to_string(t);
        
    }
    
    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) {
        hash[&quot;#&quot;] = ++ cnt;
        dfs(root);
        return ans;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -&gt; List[TreeNode]:
        self.cnt = 0
        hashs = {}
        count = {}
        ans = []
        hashs['#'] = self.cnt = self.cnt + 1
        
        def dfs(root):
            if not root: return str(hashs['#'])
            
            left = dfs(root.left)
            right = dfs(root.right)
            
            tree = str(root.val) + ',' + left + ',' + right
            self.cnt += 1
            hashs.setdefault(tree, self.cnt)
            t = hashs[tree]
            count.setdefault(t, 0)
            count[t] += 1
            if count[t] == 2: ans.append(root)
            
            return str(t)
        
        dfs(root);
        return ans;
</code></pre>
<h4 id="560-subarray-sum-equals-k"><a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a></h4>
<p>题目描述：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<br>
Note:</p>
<ul>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li>
</ul>
<pre><code>示例:
输入: nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
</code></pre>
<p>分析：滑动窗口嘛//前缀和！！！<br>
用前缀和加hash的方式可以做，每次记录s[i] - k出现的次数，因为假设s[j] = s[i] - k, 那么说明从j+1 到 i的和为k。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int subarraySum(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; hash;
        int res = 0;
        hash[0] = 1;
        
        for (int i = 0, sum = 0; i &lt; nums.size(); i ++)
        {
            sum += nums[i];
            res += hash[sum - k];
            hash[sum] ++;
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        hashs = {}
        res = 0
        count = 0
        hashs[0] = 1
        for i in range(len(nums)):
            count += nums[i]
            if count - k in hashs:
                res += hashs[count - k]
            if count in hashs:
                hashs[count] += 1
            else: hashs[count] = 1
        return res
</code></pre>
<h4 id="547-friend-circles"><a href="https://leetcode.com/problems/friend-circles/">547. Friend Circles</a>(存疑)</h4>
<p>题目描述：班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br>
给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br>
Note:</p>
<ul>
<li>N 在[1,200]的范围内。</li>
<li>对于所有学生，有M[i][i] = 1。</li>
<li>如果有M[i][j] = 1，则有M[j][i] = 1。</li>
</ul>
<pre><code>示例:
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
</code></pre>
<p>分析：<br>
并查集：1）合并两个集合；2）判断两个点是否在同一个集合中。<br>
所以刚开始每个都是单独的集合，如果两个点之间为1，说明它们在一个集合之中，于是合并它们，集合个数减一。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    vector&lt;int&gt; p;
    
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int n = M.size();
        int res = n;
        for (int i = 0; i &lt; n; i ++) p.push_back(i);
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; i; j ++)
            {
                if (M[i][j] == 0) continue;
                if (find(i) != find(j))
                {
                    p[find(i)] = find(p[j]);
                    res --;
                }
            }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findCircleNum(self, M: List[List[int]]) -&gt; int:
        p = []
        res = n = len(M)
        for i in range(n):
            p.append(i)
            
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]
        
        for i in range(n):
            for j in range(i):
                if M[i][j] == 0: continue
                if find(i) != find(j):
                    p[find(i)] = find(j)
                    res -= 1
        return res
</code></pre>
<h4 id="684-redundant-connection"><a href="https://leetcode.com/problems/redundant-connection/">684. Redundant Connection</a></h4>
<p>题目描述：在本问题中, 树指的是一个连通且无环的无向图。<br>
输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。<br>
结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。<br>
返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>
<pre><code>示例：
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
</code></pre>
<p>分析：并查集应用：<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    vector&lt;int&gt; p;
    
    int find(int x)
    {
        if (p[x] != x)  p[x] = find(p[x]);
        return p[x];
    }
    
    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n = edges.size();
        
        for (int i = 0; i &lt;= n; i ++) p.push_back(i);
        
        for (auto e : edges)
        {
            int a = e[0], b = e[1];
            if (find(a) == find(b)) return {a, b};
            p[find(a)] = find(b);
        }
        
        return {-1, -1};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:
        p = []
        n = len(edges)
        for i in range(n + 1): p.append(i)
        
        def find(x):
            if p[x] != x: p[x] = find(p[x])
            return p[x]
        
        for e in edges:
            a = e[0]
            b = e[1]
            if find(a) == find(b): return [a, b];
            p[find(a)] = find(b)
        return [-1, -1]
</code></pre>
<h4 id="692-top-k-frequent-words"><a href="https://leetcode.com/problems/top-k-frequent-words/">692. Top K Frequent Words</a></h4>
<p>Ps.对一个堆来说:</p>
<ol>
<li>查找最大值O(1)</li>
<li>插入一个数O(logn)</li>
<li>删除一个数O(logn)<br>
题目描述：给一非空的单词列表，返回前 k 个出现次数最多的单词。<br>
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。<br>
Note：</li>
</ol>
<ul>
<li>假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。</li>
<li>输入的单词均由小写字母组成。</li>
</ul>
<pre><code>示例：
输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2
输出: [&quot;i&quot;, &quot;love&quot;]
解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。
</code></pre>
<p>分析：可不可以用hash来做！！！<br>
我们要找出出现次数最多的k个单词，用小根堆来维护出现次数最多的k个单词。</p>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) {
        unordered_map&lt;string, int&gt; hash;
        typedef pair&lt;int, string&gt; PIS;
        priority_queue&lt;PIS&gt; heap;
        
        for (auto word : words) hash[word] ++;
        
        for (auto item : hash)
        {
            PIS t(-item.second, item.first);
            heap.push(t);
            if (heap.size() &gt; k) heap.pop();
        }
        
        vector&lt;string&gt; res(k);
        for (int i = k - 1; i &gt;= 0; i --)
        {
            res[i] = heap.top().second;
            heap.pop();
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution(object):
    def topKFrequent(self, words, k):
        count = collections.Counter(words)
        heap = [(-freq, word) for word, freq in count.items()]
        heapq.heapify(heap)
        # print(heapq.nsmallest(3, heap))
        return [heapq.heappop(heap)[1] for _ in range(k)]
</code></pre>
<p>也可以直接用排序来做：<br>
Python</p>
<pre><code class="language-python">class Solution:
    def topKFrequent(self, words: List[str], k: int) -&gt; List[str]:
        d = {}
        for word in words: 
            d[word] = d.get(word, 0) + 1
        res = sorted(d, key = lambda word : (-d[word], word))
        return res[:k]
</code></pre>
<h4 id="295-find-median-from-data-stream"><a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream</a></h4>
<p>题目描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<br>
例如，<br>
[2,3,4] 的中位数是 3<br>
[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>
设计一个支持以下两种操作的数据结构：<br>
void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>
double findMedian() - 返回目前所有元素的中位数。</p>
<pre><code>示例：
addNum(1)
addNum(2)
findMedian() -&gt; 1.5
addNum(3) 
findMedian() -&gt; 2
</code></pre>
<p>分析：init一个列表，每次add的时候就往里加元素，find的时候判断长度是否为偶数，可能需要注意的是添加数以后列表应该也是有序的。<br>
Python</p>
<pre><code class="language-python">class MedianFinder:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.res = []

    def addNum(self, num: int) -&gt; None:
        self.res.append(num)

    def findMedian(self) -&gt; float:
        self.res = sorted(self.res)
        n = len(self.res)
        if n % 2 == 0:
            return float((self.res[n//2] + self.res[n//2 - 1]) * 0.5)
        else:
             return self.res[int(n/2)]

# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
</code></pre>
<p>然后超时了，因为每次都要对列表进行排序，耗费的时间太多。<br>
正确的解法：构建一个对顶堆：<br>
<img src="https://tudouvvv.github.io//post-images/1569500324525.png" alt=""><br>
如图，上面是一个小根堆，保存数值较大的一部分，下面是一个大根堆，保存数值较小的一部分，每部分的元素个数都是n / 2，这样中间的元素就是我们要找的数。<br>
如果 x&gt;= 下面的根节点，插入上面的堆，反之插入下面的堆，然后维护两个堆的个数即可。<br>
C++</p>
<pre><code class="language-c++">class MedianFinder {
public:
    
    priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;
    priority_queue &lt;int&gt; down;
    
    /** initialize your data structure here. */
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if (down.empty() || num &gt; down.top()) up.push(num);
        else
        {
            down.push(num);
            up.push(down.top());
            down.pop();
        }
        if (up.size() &gt; down.size() + 1)
        {
            down.push(up.top());
            up.pop();
        }
    }
    
    double findMedian() {
        if (down.size() + up.size() &amp; 1) return up.top();
        else return (down.top() + up.top()) / 2.0;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj-&gt;addNum(num);
 * double param_2 = obj-&gt;findMedian();
 */
</code></pre>
<p>Python</p>
<pre><code class="language-python">from heapq import heappush, heappop
class MedianFinder:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.up = []
        self.down = []

    def addNum(self, num: int) -&gt; None:
        if (len(self.down) == 0 or -num &lt; self.down[0]): 
            heappush(self.up, num);
        else:
            heappush(self.down, -num)
            heappush(self.up, -self.down[0])
            heappop(self.down)
            
        if len(self.up) &gt; len(self.down) + 1:
            heappush(self.down, -self.up[0])
            heappop(self.up)

    def findMedian(self) -&gt; float:
        if len(self.up) + len(self.down) &amp; 1: return self.up[0]
        else: 
            return (self.up[0] - self.down[0]) * 0.5

# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
</code></pre>
<h4 id="352-data-stream-as-disjoint-intervals"><a href="https://leetcode.com/problems/data-stream-as-disjoint-intervals/">352. Data Stream as Disjoint Intervals</a></h4>
<p>题目描述：给定一个非负整数的数据流输入 a1，a2，…，an，…，将到目前为止看到的数字总结为不相交的区间列表。<br>
例如，假设数据流中的整数为 1，3，7，2，6，…，每次的总结为：</p>
<ol>
<li>[1, 1]</li>
<li>[1, 1], [3, 3]</li>
<li>[1, 1], [3, 3], [7, 7]</li>
<li>[1, 3], [7, 7]</li>
<li>[1, 3], [6, 7]<br>
分析：根据题意，在第四步的时候，应该加一个区间[2, 2]，但是由于[1, 2, 3]是连续的，所以合并区间，变为了[1, 3]。<br>
用平衡树来维护所有区间，构建两个字典，L和R，分别对左右端点进行映射，L中的value是左端点，R中的value是右端点，然后当有新的x插入的时候，一共有四种情况：<br>
<img src="https://tudouvvv.github.io//post-images/1569506788992.png" alt=""><br>
比如说一个区间是[x, y]，那么L[y] = x, R[x] = y。<br>
C++</li>
</ol>
<pre><code class="language-c++">class SummaryRanges {
public:
    /** Initialize your data structure here. */
    
    map&lt;int, int&gt; L, R;
    
    SummaryRanges() {
        
    }
    
    void addNum(int x) {
        if (L.size())
        {
            auto it = L.lower_bound(x);
            if (it != L.end() &amp;&amp; it-&gt;second &lt;= x) return;
        }
        
        int left = L.count(x - 1), right = R.count(x + 1);
        
        if (left &amp;&amp; right)
        {
            R[L[x - 1]] = R[x + 1];
            L[R[x + 1]] = L[x - 1];
            L.erase(x - 1), R.erase(x + 1);
        }
        else if (left)
        {
            R[L[x - 1]] = x;
            L[x] = L[x - 1];
            L.erase(x - 1);
        }
        else if (right)
        {
            L[R[x + 1]] = x;
            R[x] = R[x + 1];
            R.erase(x + 1);
        }
        else
        {
            R[x] = L[x] = x;
        }
        
    }
    vector&lt;vector&lt;int&gt;&gt; getIntervals() {
        vector&lt;vector&lt;int&gt;&gt; res;
        for (auto item : R) res.push_back({item.first, item.second});
        return res;
    }
};

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges* obj = new SummaryRanges();
 * obj-&gt;addNum(val);
 * vector&lt;vector&lt;int&gt;&gt; param_2 = obj-&gt;getIntervals();
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第六周( 滑动窗口、双指针、单调队列和单调栈专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第六周</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第六周">
        </link>
        <updated>2019-09-05T08:42:03.000Z</updated>
        <content type="html"><![CDATA[<h4 id="167-two-sum-ii-input-array-is-sorted"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167. Two Sum II - Input array is sorted</a></h4>
<p>题目描述：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>
Note：</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<pre><code>示例:
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
</code></pre>
<p>分析：暴力做法：设置两个for循环，来遍历数对，由于是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的复杂度，所以超时了。<br>
双指针算法：我们设定两个指针i和j，i &lt;= j ，并且nums[i] + nums[j] &gt;= target，当i增大时，j势必会减小，这样就有一个单调性，直到我们找到答案。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        for (int i = 0, j = numbers.size() - 1; i &lt; numbers.size(); i ++)
        {
            while (j - 1 &gt; i &amp;&amp; numbers[j - 1] + numbers[i] &gt;= target) j --;
            if (numbers[i] + numbers[j] == target) return{i + 1, j + 1};
        }
        return {};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        j = len(numbers) - 1
        for i in range(len(numbers)):
            while j - 1 &gt; i and numbers[j - 1] + numbers[i] &gt;= target:
                j -= 1
            if numbers[i] + numbers[j] == target: 
                return [i + 1, j + 1]
        return []
</code></pre>
<h4 id="88-merge-sorted-array"><a href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a></h4>
<p>题目描述：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>
Note：<br>
说明:</p>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li>
</ul>
<pre><code>示例:
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]
</code></pre>
<p>分析：先用两个指针分别指向每个数组的最后一位，表示该数组的最大值；每次把两个指针指向的最大值拿出来，然后放在后面。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i &gt;= 0 &amp;&amp; j &gt;= 0)
            if (nums1[i] &gt; nums2[j]) nums1[k -- ] = nums1[i --];
            else nums1[k --] = nums2[j --];
        while (j &gt;= 0) nums1[k --] = nums2[j --];        
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        while m &gt; 0 and n &gt; 0:
            if nums1[m - 1] &gt; nums2[n - 1]:
                nums1[m + n - 1] = nums1[m - 1]
                m -= 1
            else:
                nums1[m + n - 1] = nums2[n - 1]
                n -= 1
        if n &gt; 0:
            nums1[:n] = nums2[:n]
</code></pre>
<h4 id="26-remove-duplicates-from-sorted-array"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></h4>
<p>题目描述：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<pre><code>示例 :
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p>分析：可以设置一个指针target指向最小的数字，每次与它进行判断，如果比它大，那么这就是一个新的数，替换target，并且交换位置。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int target = nums[0];
        int count = 1;
        for (int i = 1; i &lt; nums.size(); i ++)
        {
            if (nums[i] &gt; target)
            {
                target = nums[i];
                int tmp = nums[count];
                nums[count] = nums[i];
                nums[i] = tmp;
                count += 1;
            }
        }
        return count;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if not nums:
            return 0
        min_target = nums[0]
        count = 1
        i = 1
        while i &lt; len(nums):
            if nums[i] &gt; min_target:
                min_target = nums[i]
                nums[count], nums[i] = nums[i], nums[count]
                count += 1
            i += 1
        return count
</code></pre>
<p>其实，不需要这么麻烦，设定一个指针k指向前面不同的数的最后一位的下一位，从前往后遍历，每次与它的前一个数进行比较，不同的话替换前面的指针k指向的数，k + 1即可；</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int k = 1;
        for (int j = 1; j &lt; nums.size(); j ++)
        {
        if (nums[j] != nums[j - 1]) nums[k ++] = nums[j];
        }
        return k;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums: return 0
        k = 1;
        for i in range(1, len(nums)):
            if nums[i] != nums[i - 1]:
                nums[k] = nums[i];
                k += 1
        return k;
</code></pre>
<h4 id="76-minimum-window-substring"><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></h4>
<p>题目描述：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。<br>
Note：</p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<pre><code>示例：
输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;
输出: &quot;BANC&quot;
</code></pre>
<p>分析：暴力写法：枚举S所有的子串，再去看是否包含T里所有的字母。<br>
滑动窗口算法：i和j表示窗口的左右两个边界，j随i的变化而变化，设定一个hash表表示t中字母的数量，cnt表示有多少个不同的字母；然后遍历s，设定一个变量c表示遇到了几个我们需要的字母，当遇到需要的字母时<code>if hash[s[i]] == 1: c ++</code>，然后<code>hash[s[i]] --</code>表示需要的数量-1，这样不断挪动右窗口的边界就行，那做做窗口怎么更新呢？当我们一直往右走时，总会遇到一段拥有所有的字母，此时再往右走，hash中包含我们需要的字母的数值就会变为负值，此时进行判断，如果左边界的字母的hash值是负值，那就说明这个字母我们不需要，因为右边已经有了或者不是我们需要的，然后往右挪动一下，hash++即可。每次挪动右边记得要更新答案。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map&lt;char, int&gt; hash;
        string res;
        for (auto c : t) hash[c] ++;
        int cnt = hash.size();
        for (int i = 0, j = 0, c = 0; i &lt; s.size(); i ++)
        {
            if (hash[s[i]] == 1) c++;
            hash[s[i]] --;
            while (hash[s[j]] &lt; 0) hash[s[j ++]] ++;
            if (c == cnt)
            {
                if (res.empty() || res.size() &gt; i - j + 1) res = s.substr(j, i - j + 1);
            }
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">import collections

class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        hash_dict = collections.Counter(t)
        res = &quot;&quot;
        cnt = len(hash_dict)
        j = 0
        c = 0
        for i in range(len(s)):
            if (hash_dict[s[i]] == 1): c += 1
            hash_dict[s[i]] -= 1
            while j &lt; len(s) and hash_dict[s[j]] &lt; 0:
                hash_dict[s[j]] += 1
                j += 1
            if c == cnt:
                if (not res) or len(res) &gt; i - j + 1:
                    res = s[j : i+1]
        return res     
</code></pre>
<h4 id="32-longest-valid-parentheses"><a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a></h4>
<p>题目描述：给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。</p>
<pre><code>示例 :
输入: &quot;)()())&quot;
输出: 4
解释: 最长有效括号子串为 &quot;()()&quot;
</code></pre>
<p>分析：刚开始考虑用栈来做...<br>
括号序列的一个性质：</p>
<ul>
<li>不论怎么匹配，左右括号一定是确定的</li>
<li>一个括号序列合法&lt;=&gt;所有前缀和&gt;=0，且总和=0(左括号为1，右括号为-1)<br>
所以我们可以用这个性质来做，start表示当前枚举的开头位置，cnt表示前缀和，然后开始遍历，计算start--&gt;i的前缀和cnt，如果cnt&lt;0，那就说明当前这一段不合法，start = i + 1，cnt = 0继续遍历；如果cnt &gt; 0那就说明当前合法，继续做；如果cnt = 0， 那就说明[start, i]这一段是合法序列，更新答案即可；但是会有这样一种情况，左括号的数量大于右括号的数量<code>(((())</code>这样cnt永远&gt;0，是更新不了答案的，所以还需要反着再来一遍。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    
    int work(string s)
    {
        int res = 0;
        for (int i = 0, start = 0, cnt = 0; i &lt; s.size(); i ++)
        {
            if (s[i] == '(') cnt ++ ;
            else
            {
                cnt -- ;
                if (cnt &lt; 0) start = i + 1, cnt = 0;
                else if (cnt == 0)  res = max(res, i - start + 1);
            }
        }
        return res;
    }
    
    int longestValidParentheses(string s) {
        int res = work(s);
        reverse(s.begin(), s.end());
        for (auto &amp;c : s) c ^= 1;
        return max(res, work(s));
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        res = self.work(s);
        s = s[::-1];
        s_reverse = &quot;&quot;
        for char in s:
            char = chr(ord(char) ^ 1)
            s_reverse += char
        return max(res, self.work(s_reverse))
    
    def work(self, s):
        res, start, cnt = 0, 0, 0
        for i in range(len(s)):
            if s[i] == '(': cnt += 1
            else:
                cnt -= 1
                if cnt &lt; 0: start, cnt = i + 1, 0
                elif cnt == 0:
                    res = max(res, i - start + 1)
        return res      
</code></pre>
<p>用栈来做：<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int longestValidParentheses(string s) {
        stack&lt;int&gt; stack;
        int ans = 0;
        int base = -1;
        for (int i = 0; i &lt; s.size(); i ++ )
        {
            if (s[i] == '(') stack.push(i);
            else 
                if (stack.size() &gt; 0)
                {
                    stack.pop();
                    if (stack.size() == 0) ans = max(ans, i - base);
                    else ans = max(ans, i - stack.top());
                }
                else base = i;
        }
        return ans;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        stack = []
        ans = 0
        base = -1
        for i, c in enumerate(s):
            if c == '(': stack.append(i)
            elif stack:
                stack.pop()
                if stack:
                    ans = max(ans, i - stack[-1])
                else:
                    ans = max(ans, i - base)
            else:
                base = i
        return ans
</code></pre>
<h4 id="155-min-stack"><a href="https://leetcode.com/problems/min-stack/">155. Min Stack</a></h4>
<p>题目描述：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) -- 将元素 x 推入栈中。</li>
<li>pop() -- 删除栈顶的元素。</li>
<li>top() -- 获取栈顶元素。</li>
<li>getMin() -- 检索栈中的最小元素。</li>
</ul>
<pre><code>示例:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</code></pre>
<p>分析：本来的想法是建立一个列表，通过append和del操作来构造所需要的函数。<br>
后来发现可以直接调用push和pop操作，不过唯一不同的是，在进行getMin操作时，可以新建一个栈，存的当前栈的最小值，第一个元素表示第一个数的最小值（也就是第一个数），第二个元素存的是前两个数的最小值，以此类推...<br>
C++</p>
<pre><code class="language-c++">class MinStack {
public:
    
    stack&lt;int&gt; stk, stk_min;
    
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        stk.push(x);
        if (stk_min.empty()) stk_min.push(x);
        else stk_min.push(min(x, stk_min.top()));
    }
    
    void pop() {
        stk.pop();
        stk_min.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return stk_min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(x);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
</code></pre>
<p>Python</p>
<pre><code class="language-python">class MinStack:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stk = []
        self.stk_min = []

    def push(self, x: int) -&gt; None:
        self.stk.append(x)
        if self.stk_min:
            self.stk_min.append(min(x, self.stk_min[-1]))
        else: self.stk_min.append(x)

    def pop(self) -&gt; None:
        self.stk.pop()
        self.stk_min.pop()

    def top(self) -&gt; int:
        return self.stk[-1]

    def getMin(self) -&gt; int:
        return self.stk_min[-1]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
</code></pre>
<h4 id="84-largest-rectangle-in-histogram"><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram</a></h4>
<p>题目描述：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>
求在该柱状图中，能够勾勒出来的矩形的最大面积。<br>
<img src="https://tudouvvv.github.io//post-images/1568512602453.png" alt=""></p>
<pre><code>示例:
输入: [2,1,5,6,2,3]
输出: 10
</code></pre>
<p>分析：<br>
单调栈：查找每个数左/右侧第一个比它小/大的数<br>
单调队列：查找滑动窗口中的最值<br>
这道题首先要考虑的是如何能枚举出来所有的矩形：</p>
<ol>
<li>枚举所有柱形的上边界作为整个矩形的上边界，然后求出左右边界（往左右可以扩充的位置）</li>
<li>找出左边离它最近的，比它小的柱形</li>
<li>找出右边离它最近的，比它小的柱形<br>
比如输入[2,1,5,6,2,3]，构建一个栈，每次push元素的时候都要比栈顶元素大，如果没有，就pop栈直到栈中没有比它大的元素，再进栈，这样就构成了一个单调栈。<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        int n = heights.size();
        vector&lt;int&gt; left(n), right(n);
        
        stack&lt;int&gt; stk;
        for (int i = 0; i &lt; n; i ++)
        {
            while (stk.size() &amp;&amp; heights[stk.top()] &gt;= heights[i])  stk.pop();
            if (stk.empty()) left[i] = -1;
            else left[i] = stk.top();
            stk.push(i);
        }
        while(stk.size()) stk.pop();
        for (int i = n - 1; i &gt;= 0; i --)
        {
            while (stk.size() &amp;&amp; heights[stk.top()] &gt;= heights[i]) stk.pop();
            if (stk.empty()) right[i] = n;
            else right[i] = stk.top();
            stk.push(i);
        }
        
        int res = 0;
        for (int i = 0; i &lt; n; i ++)  res = max(res, heights[i] * (right[i] - left[i] - 1));
        
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def largestRectangleArea(self, heights: List[int]) -&gt; int:
        n = len(heights)
        right, left = [0] * n, [0] * n
        stk = []
        for i in range(n):
            while (len(stk) and heights[stk[-1]] &gt;= heights[i]): stk.pop()
            if not stk: left[i] = -1
            else: left[i] = stk[-1]
            stk.append(i)
        while len(stk): stk.pop()
        
        for i in range(n-1, -1, -1):
            while (len(stk) and heights[stk[-1]] &gt;= heights[i]): stk.pop()
            if not stk: right[i] = n
            else: right[i] = stk[-1]
            stk.append(i)
        res = 0
        for i in range(n): res = max(res, heights[i] * (right[i] - left[i] - 1))

        return res
</code></pre>
<h4 id="42-trapping-rain-water"><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a></h4>
<p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
<img src="https://tudouvvv.github.io//post-images/1568259976116.png" alt=""></p>
<pre><code>示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
</code></pre>
<p>分析：找到数组中的低谷，低谷就是雨水可以存在的位置。</p>
<ul>
<li>三次线性扫描<br>
每个矩形上方的水的数量是由它自己、它左边最高的位置以及它右边最高的位置决定的，所以我们需要首先得到每个位置左边最高位置和右边最高位置，然后水的数量就等于 <code>min(left[i], right[i]) - height[i]</code>。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        int res = 0;
        
        if (n == 0) return 0;
        
        vector&lt;int&gt; left(n), right(n);
        left[0] = height[0];
        for (int i = 1; i &lt; n; i ++)
            left[i] = max(left[i - 1], height[i]);
        right[n - 1] = height[n - 1];
        for (int i = n - 2; i &gt;= 0; i --)
            right[i] = max(right[i + 1], height[i]);
        for (int i = 0; i &lt; n; i ++)
            res += min(left[i], right[i]) - height[i];
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def trap(self, height: List[int]) -&gt; int:
        n = len(height)
        res = 0
        left, right = [0] * n, [0] * n
        
        if not height: return 0
        
        left[0] = height[0]
        for i in range(n):
            left[i] = max(left[i - 1], height[i])
        right[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            right[i] = max(right[i + 1], height[i])
            
        for i in range(n):
            res += min(left[i], right[i]) - height[i]
        
        return res
</code></pre>
<ul>
<li>单调栈（存疑）</li>
</ul>
<h4 id="239-sliding-window-maximum"><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h4>
<p>题目描述：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>
返回滑动窗口中的最大值。</p>
<pre><code>示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>分析：</p>
<ul>
<li>暴力解法：枚举所有的情况，python可以进行切片操作，然后用max得到该窗口内的最大值。<br>
Python</li>
</ul>
<pre><code class="language-python">class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        if not nums:
            return []
        res = []
        n = len(nums)
        for i in range(n - k + 1):
            res.append(max(nums[i:i + k]))
        return res
</code></pre>
<ul>
<li>单调队列<br>
单调队列是一个普通的双端队列，即队头和队尾都可以添加和弹出元素。维护这样一个队列：队头元素最大，队尾最小，这样在每个窗口中，只需要push队头元素即可。<br>
每次添加元素时都需要进行检查：1）合法性检查：即如果队头元素下标已经不在窗口范围内，应该出队；2）单调性检查：如果nums[i]大于或等于队尾元素下标所对应的值，则当前队尾再也不可能充当某个滑动窗口的最大值了，故需要队尾出队。始终保持队中元素从队头到队尾单调递减。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        vector&lt;int&gt; res;
        deque&lt;int&gt; q;
        for(int i = 0; i &lt; nums.size(); i ++)
        {
            while (q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front();
            while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();
            q.push_back(i);
            if (i &gt;= k - 1)  res.push_back(nums[q.front()]);
        }
        
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        res = []
        q = []
        n = len(nums)
        for i in range(n):
            if(len(q) and i - k + 1 &gt; q[0]): 
                q.pop(0)
            while(len(q) and nums[i] &gt;= nums[q[-1]]): 
                q.pop()
            q.append(i)
            if i &gt;= k - 1: 
                res.append(nums[q[0]])
        return res
</code></pre>
<h4 id="918-maximum-sum-circular-subarray"><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/">918. Maximum Sum Circular Subarray</a>(存疑)</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第五周(DFS+回溯专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第五周(DFS+回溯专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第五周(DFS+回溯专题)">
        </link>
        <updated>2019-08-28T03:18:25.000Z</updated>
        <content type="html"><![CDATA[<p>搜索 != 递归</p>
<h4 id="17-letter-combinations-of-a-phone-number"><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h4>
<p>题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>
数字到字母的映射与以前电话九宫格按键相同，1不对应任何字母。</p>
<pre><code>示例：
输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre>
<p>分析：用循环来来做这道题，首先设置空列表表示答案，先取出数字，再取出字母，最后再拿出列表中的元素，把它们拼接在一起，更新列表即可。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    string chars[8] = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
    
    vector&lt;string&gt; letterCombinations(string digits) {
        if (digits.empty()) return vector&lt;string&gt;();
        
        vector &lt;string&gt; states(1, &quot;&quot;);
        for (auto u : digits)
        {
            vector &lt;string&gt; now;
            for (auto c : chars[u - '2'])
                for (auto s : states)
                    now.push_back(s + c);
            states = now;
        }
        return states;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        chars = [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;]
        if not digits: return []
        states = [&quot;&quot;]
        for u in digits:
            now = []
            for c in chars[int(u) - 2]:
                for s in states:
                    now.append(s + c)
            states = now
        return states
</code></pre>
<h4 id="79-word-search"><a href="https://leetcode.com/problems/word-search/">79. Word Search</a></h4>
<p>题目描述：给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<pre><code>示例：
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
给定 word = &quot;ABCCED&quot;, 返回 true.
给定 word = &quot;SEE&quot;, 返回 true.
给定 word = &quot;ABCB&quot;, 返回 false.
</code></pre>
<p>分析：首先枚举起点，从起点开始，依次搜索下一个点的位置，在枚举的过程中，要保证和目标单词匹配。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    int n, m;
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};   
    
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if (board.empty() || board[0].empty()) return false;
        
        n = board.size(), m = board[0].size();
        
        for (int i=0; i &lt; n; i++)
            for (int j=0; j &lt; m; j ++)
                if (dfs(board, i, j, word, 0))
                    return true;
        return false;
    }
    
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string&amp; word, int u)
    {
        if (board[x][y] != word[u]) return false;
        if (u == word.size() - 1) return true;
        
        board[x][y] = '.';
        for (int i=0; i &lt; 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m)
                if (dfs(board, a, b, word, u + 1))
                    return true;
        }
        board[x][y] = word[u];
        
        return false;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def exist(self, board: List[List[str]], word: str) -&gt; bool:
        dx = [-1, 0, 1, 0]
        dy = [0, 1, 0, -1]
        n = len(board)
        m = len(board[0])
        if n == 0 or m == 0:
            return False
        
        def dfs(x, y, u):
            if board[x][y] != word[u]: return False
            if u == len(word) - 1: return True
            board[x][y] = '.'
            for i in range(4):
                a = x + dx[i]
                b = y + dy[i]
                if a &gt;= 0 and a &lt; n and b &gt;=0 and b &lt; m:
                    if dfs(a, b, u+1):
                        return True
            board[x][y] = word[u]
            return False
        
        for i in range(n):
            for j in range(m):
                if dfs(i, j, 0):
                    return True
        return False
</code></pre>
<h4 id="46-permutations"><a href="https://leetcode.com/problems/permutations/">46. Permutations</a></h4>
<p>题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<pre><code>示例:
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
<p>分析：有两种顺序：1. 枚举每个位置上放哪个数。2. 枚举每个数放在哪个位置上。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    int n;
    vector&lt;bool&gt; st;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        n = nums.size();
        st = vector&lt;bool&gt;(n);        
        dfs(nums, 0);
        
        return ans;
    }
    void dfs(vector&lt;int&gt; &amp;nums, int u)
    {
        if (u == n)
        {
            ans.push_back(path);
            return;
        }
        for (int i = 0; i &lt; n; i++)
            if (!st[i])
            {
                st[i] = true;
                path.push_back(nums[i]);
                dfs(nums, u + 1);
                path.pop_back();
                st[i] = false;
            }
    }
};
</code></pre>
<p>Python (这里需要注意的是，当ans.append(path)时，只是引用了path的地址，当path变化的时候，ans中的path也是会变化的，所以如果不对path进行深拷贝的话，那么最后path会变成空，最后ans里面添加的数值都会变成空)</p>
<pre><code class="language-python">class Solution:
    def permute(self, nums: List[int]) -&gt; List[List[int]]:
        n = len(nums)
        st = [0] * n
        path = []
        ans = []
        
        def dfs(u):
            if u == n:
                path_copy = path[::1]
                ans.append(path_copy)
                # ans.append(copy.deepcopy(path))
                return
            for i in range(n):
                if not st[i]:
                    st[i] = True
                    path.append(nums[i])
                    dfs(u + 1)
                    path.pop()
                    st[i] = False
        
        dfs(0)
        return ans
</code></pre>
<h4 id="47-permutations-ii"><a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a></h4>
<p>题目描述：给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<pre><code>示例：
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>
<p>分析：枚举每个数放在哪个位置上去，搜索的时候不能重复。</p>
<ul>
<li>先将所有相同数放在一起：排序</li>
<li>人为规定相同数字的相对顺序：不变<br>
dfs(u, start)</li>
<li>u表示枚举到了哪个数字。</li>
<li>start表示当前可以从哪个位置开始搜，比如把第一个1放在了第五个位置上，那么第二个1就必须从第六个位置开始搜。枚举新的数字时，start = 0，枚举相同的数字时，start 从下一位开始。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    
    int n;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    vector&lt;bool&gt; st;
    
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        n = nums.size();
        st = vector&lt;bool&gt; (n);
        path = vector&lt;int&gt; (n);
        
        sort(nums.begin(), nums.end());
        dfs(nums, 0, 0);
        return ans;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int u, int start){
        if (u == n)
        {
            ans.push_back(path);
            return;
        }
        
        for (int i = start; i &lt; n; i++)
            if (!st[i])
            {
                st[i] = true;
                path[i] = nums[u];
                dfs(nums, u + 1, u + 1 &lt; n &amp;&amp; nums[u + 1] == nums[u] ? i + 1 : 0);
                st[i] = false;
            }
    }
};
</code></pre>
<h4 id="78-subsets"><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></h4>
<p>题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>
Note：</p>
<ul>
<li>解集不能包含重复的子集。</li>
<li>空集是一个特殊的子集。</li>
</ul>
<pre><code>示例:
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre>
<p>分析：可以用二进制表示所有的可能性，比如上面有三位数字，那么共有的可能性就有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 中可能性，二进制表示的可能性如下：</p>
<pre><code>000   -&gt;   []
001   -&gt;   [1]
010   -&gt;   [2]
011   -&gt;   [1, 2]
100   -&gt;   [3]
101   -&gt;   [1, 3]
110   -&gt;   [1, 2]
111   -&gt;   [1, 2, 3]
</code></pre>
<p>所以通过枚举所有的二进制表示，然后如果位上是1，那么就把该位表示的数字放进来。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        for (int i = 0; i &lt; 1 &lt;&lt; nums.size(); i ++)
        {
            vector&lt;int&gt; now;
            for (int j = 0; j &lt; nums.size(); j ++)
                if (i &gt;&gt; j &amp; 1)
                    now.push_back(nums[j]);
            res.push_back(now);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res = []
        for i in range(1 &lt;&lt; len(nums)):
            now = []
            for j in range(len(nums)):
                if i &gt;&gt; j &amp; 1:
                    now.append(nums[j])
            res.append(now)
        return res
</code></pre>
<h4 id="90-subsets-ii"><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h4>
<p>题目描述：给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>
Note：</p>
<ul>
<li>解集不能包含重复的子集。</li>
</ul>
<pre><code>示例:
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre>
<p>分析：先统计每个数字出现的次数，次数之积就是所有可能的方案。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        dfs(nums, 0);
        return ans;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int u){
        if (u == nums.size())
        {
            ans.push_back(path);
            return;
        }
        
        // 计算当前数字的个数
        int k = 0;
        while (u + k &lt; nums.size() &amp;&amp; nums[u+k] == nums[u]) k++;
        for (int i = 0; i &lt;= k; i ++)
        {
            dfs(nums, u + k);
            path.push_back(nums[u]);
        }
        
        // 恢复现场
        for (int i = 0; i &lt;= k; i++) path.pop_back();
    }
};
</code></pre>
<p>Python(存疑)</p>
<h4 id="216-combination-sum-iii"><a href="https://leetcode.com/problems/combination-sum-iii/">216. Combination Sum III</a></h4>
<p>题目描述：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。<br>
Note：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<pre><code>示例 :
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
</code></pre>
<p>分析：</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {
        dfs(k, 1, n);
        return ans;
    } 
    
    void dfs(int k, int start, int n){
        if (!k)
        {
            if (!n) ans.push_back(path);
            return;
        }
        
        for (int i = start; i &lt;= 9; i ++)
        {
            path.push_back(i);
            dfs(k - 1, i + 1, n - i);
            path.pop_back();
        }
    }
};
</code></pre>
<h4 id="52-n-queens-ii"><a href="https://leetcode.com/problems/n-queens-ii/">52. N-Queens II</a></h4>
<p>题目描述：n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击(任意两个皇后都不能处于同一行、同一列或同一斜线上)。</p>
<pre><code>示例:

输入: 4
输出: 2
解释: 4 皇后问题存在如下两个不同的解法。
[
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
</code></pre>
<p>分析：由于攻击的关系，所以每行每列只能摆一个皇后。依次枚举每一行皇后的位置，需要满足以下条件：</p>
<ul>
<li>每一列只能有一个皇后- &gt;设置数组col[n]表示是否有皇后</li>
<li>每一条斜线上只能有一个皇后 - &gt; 由于有两个方向的斜线，所以用d[2n-1]和ud[2n-1]表示。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int ans = 0, n;
    vector&lt;bool&gt; col, d, ud;
    
    int totalNQueens(int _n) {
        n = _n;
        col = vector&lt;bool&gt; (n);
        d = ud = vector&lt;bool&gt; (n * 2);
        
        dfs(0);
        return ans;
    }
    
    void dfs(int u)
    {
        if (u == n)
        {
            ans ++;
            return;
        }
        for (int i = 0; i &lt; n; i++)
            if (!col[i] &amp;&amp; !d[u + i] &amp;&amp; !ud[u - i + n])
            {
                col[i] = d[u + i] = ud[u - i + n] = true;
                dfs(u + 1);
                col[i] = d[u + i] = ud[u - i + n] = false;
            }
    }
};
</code></pre>
<h4 id="37-sudoku-solver"><a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a></h4>
<p>题目描述：编写一个程序，通过已填充的空格来解决数独问题。<br>
一个数独的解法需遵循如下规则：<br>
数字 1-9 在每一行只能出现一次。<br>
数字 1-9 在每一列只能出现一次。<br>
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>
空白格用 '.' 表示。<br>
Note:</p>
<ul>
<li>给定的数独序列只包含数字 1-9 和字符 '.' 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 9x9 形式的。<br>
分析：搜索顺序：从前往后枚举每个空格该填哪个数。需要维护每一行、每一列以及每个九宫格的状态，因为每行、每列、每个九宫格中的数字不能重复，所以设定<code>row[9][9]（一共九行，每行九个数字）、col[9][9]、cell[3][3][9]（3 × 3的格子，每个格子有九个数字）</code>来表示状态。<br>
Ps. 八皇后、数独都是精确覆盖问题，可以用Dancing Links来解决。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    bool row[9][9] = {0}, col[9][9] = {0}, cell[3][3][9] = {0};
    
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        for (int i = 0; i &lt; 9; i++)
            for (int j = 0; j &lt; 9; j++)
            {
                char c = board[i][j];
                if (c != '.')
                {
                    int t = c - '1';
                    row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true;
                }
            }
        dfs(board, 0, 0);
    }
    
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y)
    {
        if (y == 9)  x++, y = 0;
        if (x == 9) return true;
        if (board[x][y] != '.') return dfs(board, x, y + 1);
        
        for (int i = 0; i &lt; 9; i ++)
            if (!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / 3][y / 3][i])
            {
                board[x][y] = '1' + i;
                row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true;
                if (dfs(board, x, y + 1)) return true;            
                row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false;
                board[x][y] = '.';
            }
        return false;
    }
};
</code></pre>
<h4 id="473-matchsticks-to-square"><a href="https://leetcode.com/problems/matchsticks-to-square/">473. Matchsticks to Square</a></h4>
<p>题目描述：还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。<br>
输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。</p>
<pre><code>示例 :
输入: [1,1,2,2,2]
输出: true
解释: 能拼成一个边长为2的正方形，每边两根火柴。
</code></pre>
<p>Note:</p>
<ul>
<li>给定的火柴长度和在 0 到 10^9之间。</li>
<li>火柴数组的长度不超过15。</li>
</ul>
<p>分析：一次构造正方形的每条边。</p>
<ol>
<li>从大到小枚举所有边</li>
<li>每条边内部的木棒长度规定从大到小</li>
<li>如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒</li>
<li>如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支</li>
<li>如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉分支<br>
C++</li>
</ol>
<pre><code class="language-c++">
</code></pre>
]]></content>
    </entry>
</feed>