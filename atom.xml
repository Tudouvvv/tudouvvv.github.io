<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tudouvvv.github.io/</id>
    <title>Tudouvvv</title>
    <updated>2019-10-22T02:22:40.106Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tudouvvv.github.io/"/>
    <link rel="self" href="https://tudouvvv.github.io//atom.xml"/>
    <subtitle>人生还长，慢慢来</subtitle>
    <logo>https://tudouvvv.github.io//images/avatar.png</logo>
    <icon>https://tudouvvv.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Tudouvvv</rights>
    <entry>
        <title type="html"><![CDATA[做作的日常①]]></title>
        <id>https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang</id>
        <link href="https://tudouvvv.github.io//post/zuo-zuo-de-ri-chang">
        </link>
        <updated>2019-10-07T12:45:12.000Z</updated>
        <content type="html"><![CDATA[<p>十一就要结束了呀！！！<br>
时间呀时间，你慢点撒！</p>
<ol>
<li>求斐波那契数列的前1000个数（当时连斐波那契数列是啥都不知道hh）<br>
斐波那契数列是这样一个数列：1, 1, 2, 3, 5, 8, ..., ...<br>
即f(1) = 1, f(2) = 1, f(n) = f(n - 1) + f(n - 2)这样一个递推关系式<br>
可以开一个1000个空间的数组，也可以用while循环来做，但是没啥区别，都是要通过迭代的方式来进行。<br>
Python</li>
</ol>
<pre><code class="language-python">class Solution:
    def Fibonacci_sequence(self, nums):
        f = [0 for _ in range(nums)]
        if nums == 1:
            return [1]
        if nums == 2:
            return [1, 1]
        f[0], f[1] = 1, 1
        for i in range(2, nums):
            f[i] = f[i - 1] + f[i - 2]
        return f
</code></pre>
<ol start="2">
<li>求前1000个质数<br>
质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。<br>
可以写一个函数来判断一个数是不是质数，然后主函数用一个while循环进行判断，直到有1000个数，而且判断的时候只需要从2到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>即可。<br>
Python</li>
</ol>
<pre><code class="language-python">class Solution:
    def Prime(self, nums):
        f = [2]
        if nums == 1:
            return f
        i = 3
        while len(f) &lt; nums:
            if self.is_prime(i): f.append(i)
            i += 1
        return f

    def is_prime(self, n):
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第八周(动态规划专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第八周(动态规划专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第八周(动态规划专题)">
        </link>
        <updated>2019-09-27T09:32:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="53-maximum-subarray"><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></h4>
<p>题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<pre><code>示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre>
<p>分析：</p>
<ol>
<li>要计算连续的最大和，其实就是要看加了某个数之后的和与该数的大小，如果变小了那就没必要了，所以每次进行判断，如果前面的数&gt;0，那么就加上它，这样遍历一遍，整个数组中最大的值就是我们要找的答案。<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans = INT_MIN;
        for(int i = 1; i &lt; nums.size(); i ++)
        {
            if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1];
        }
        for (auto num : nums)  ans = max(ans, num);
        return ans;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        for i in range(1, len(nums)):
            if nums[i - 1] &gt; 0:
                nums[i] += nums[i - 1]
        return max(nums)
</code></pre>
<ol start="2">
<li>动态规划<br>
从集合的角度来考虑DP问题，最重要的就是要求出状态转移方程是什么样子的，对每个nums[i]来说，它的连续子数组的和共有以下情况:</li>
</ol>
<ul>
<li>nums[1] + nums[2] + ... + nums[i]</li>
<li>nums[2] + nums[3] + ... + nums[i]</li>
<li>...</li>
<li>0 + nums[i]<br>
我们去掉nums[i]来找这些情况中的最大和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> ，这些情况中的最大和就等于nums[i - 1]情况下的最大和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以状态转移方程就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f(x) = max(0,  f(x-1)) + nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int res= INT_MIN, last = 0;
        for (int i = 0; i &lt; nums.size(); i ++)
        {
            int now = max(0, last) + nums[i];
            res = max(res, now);
            last = now;
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        res = -float('inf')
        last = 0
        for i in range(len(nums)):
            now = max(0, last) + nums[i]
            res = max(res, now)
            last = now
        return res
</code></pre>
<h4 id="120-triangle"><a href="https://leetcode.com/problems/triangle/">120. Triangle</a></h4>
<p>题目描述：给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<pre><code>例如，给定三角形：
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
</code></pre>
<p>分析：首先记录第一行的数字res = triangle[0][0]，初始时i = 0，然后从第二行开始，res += min(char[i], char[i + 1])，这是它相邻的两个位置，记录min_char的index，然后替换i，继续枚举。<br>
Python❌</p>
<pre><code class="language-python">class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        if not list: return 0
        res = triangle[0][0]
        i = 0
        for char in triangle[1:]:
            min_char = min(char[i], char[i + 1])
            res += min_char
            i = char.index(min_char)
        return res
</code></pre>
<p>但是不知道为什么有个案例过不了<code>[[-1],[2,3],[1,-1,-3]]</code>，讲道理不是应该-1 + 2 + -1 = 0 嘛，不知道为什么答案是-1。<br>
✅ps.我明白了，这并不是一个贪心算法的过程，而是要看全局，所以正确的路径应该是-1 + 3 + -3 = -1。<br>
所以这也是一道用dp解决的问题：<br>
<img src="https://tudouvvv.github.io//post-images/1569826922552.png" alt=""><br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(n));
        f[0][0] = nums[0][0];
        for(int i = 1; i &lt; n; i ++)
            for(int j = 0; j &lt;= i; j ++)
            {
                f[i][j] = INT_MAX;
                if (j &gt; 0) f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j]);
                if (j &lt; i) f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j]);
            }
        long long res = INT_MAX;
        for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1][i]);
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def minimumTotal(self, nums: List[List[int]]) -&gt; int:
        n = len(nums)
        f = [[0 for _ in range(n)] for _ in range(n)]
        f[0][0] = nums[0][0]
        for i in range(1, n):
            for j in range(i + 1):
                f[i][j] = float('inf')
                if j &gt; 0: f[i][j] = min(f[i][j], f[i - 1][j - 1] + nums[i][j])
                if j &lt; i: f[i][j] = min(f[i][j], f[i - 1][j] + nums[i][j])
        res = float('inf')
        for i in range(n):
            res = min(res, f[n - 1][i])
        return res
</code></pre>
<p>因为我们最后只需要最后一行的数据进行判断，并且每行的结果只依赖于上一行的结果，所以完全不需要开n行数组，只需要开两行，然后滚动就行，这就是滚动数组：</p>
<pre><code class="language-c++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;vector&lt;long long&gt;&gt; f(2, vector&lt;long long&gt;(n));
        f[0][0] = nums[0][0];
        for(int i = 1; i &lt; n; i ++)
            for(int j = 0; j &lt;= i; j ++)
            {
                f[i &amp; 1][j] = INT_MAX;
                if (j &gt; 0) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j - 1] + nums[i][j]);
                if (j &lt; i) f[i &amp; 1][j] = min(f[i &amp; 1][j], f[i - 1 &amp; 1][j] + nums[i][j]);
            }
        long long res = INT_MAX;
        for (int i = 0; i &lt; n; i ++) res = min(res, f[n - 1 &amp; 1][i]);
        return res;
    }
};
</code></pre>
<h4 id="63-unique-paths-ii"><a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a></h4>
<p>题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>
<img src="https://tudouvvv.github.io//post-images/1569829741021.png" alt=""><br>
网格中的障碍物和空位置分别用 1 和 0 来表示。<br>
说明：m 和 n 的值均不超过 100。</p>
<pre><code>示例:
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</code></pre>
<p>分析：<img src="https://tudouvvv.github.io//post-images/1569830381210.png" alt=""><br>
对于状态计算来说，分为两种情况：</p>
<ol>
<li>最后一步从上往下走: f[i][j] += f[i - 1][j]</li>
<li>最后一步从左往右走: f[i][j] += f[i][j - 1]<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; g) {
        int n = g.size(), m = g[0].size();
        vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(m));
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; m; j ++)
            {
                if (g[i][j]) continue;
                if (!i &amp;&amp; !j) f[i][j] = 1;
                if (i &gt; 0) f[i][j] += f[i - 1][j];
                if (j &gt; 0) f[i][j] += f[i][j - 1];
            }
        return f[n - 1][m - 1];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int:
        n = len(g)
        m = len(g[0])
        f = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if g[i][j]: continue;
                if i == 0 and j == 0: f[i][j] = 1
                if (i &gt; 0): f[i][j] += f[i - 1][j]
                if (j &gt; 0): f[i][j] += f[i][j - 1]
        return f[n - 1][m - 1]
</code></pre>
<h4 id="91-decode-ways"><a href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a></h4>
<p>题目描述：一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>
'A' -&gt; 1<br>
'B' -&gt; 2<br>
...<br>
'Z' -&gt; 26<br>
给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<pre><code>示例:
输入: &quot;226&quot;
输出: 3
解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。
</code></pre>
<p>分析：还是用DP的思路来解决：<br>
<img src="https://tudouvvv.github.io//post-images/1569833953551.png" alt=""><br>
首先状态表示，f[i]表示所有由前i个数字解码得到的字符串的个数，然后是状态计算，共有两种情况:最后一个字母是一个数字f[i - 1]，最后一个字母是两个数字f[i - 2]，特别还是要考虑边界条件。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector&lt;int&gt; f(n + 1);
        f[0] = 1;
        for (int i = 1; i &lt;= n; i ++)
        {
            if (s[i - 1] != '0') f[i] += f[i - 1];
            if (i &gt;= 2)
            {
                int t = (s[i - 2] - '0') * 10 + s[i - 1] - '0';
                if (t &gt;= 10 and t &lt;= 26) f[i] += f[i - 2];
            }
        }
        return f[n];    
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        n = len(s)
        f = [0 for _ in range(n + 1)]
        f[0] = 1
        
        for i in range(1, n + 1):
            if s[i - 1] != '0': f[i] += f[i - 1]
            if i &gt; 1:
                t = int(s[i - 2]) * 10 + int(s[i - 1])
                if 10 &lt;= t &lt;=26:
                    f[i] += f[i - 2]
        return f[n]
</code></pre>
<h4 id="198-house-robber"><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></h4>
<p>题目描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<pre><code>示例:
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</code></pre>
<p>分析：我把奇数的加一起，偶数的加一起，max一下不就可以了嘛</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        res1 = 0
        res2 = 0
        for i in range(len(nums)):
            if i % 2 == 0:
                res1 += nums[i]
            else:
                res2 += nums[i]
        return max(res1, res2)
</code></pre>
<p>好吧，少考虑了情况，如果是[2, 1, 1, 2]的话就不需要隔一个偷一个了。<br>
考虑用DP来做，用两个数组分别表示状态：<br>
<img src="https://tudouvvv.github.io//post-images/1570085349472.png" alt=""><br>
那么在进行状态计算的时候，f[i]因为表示不取nums[i]的最大值，所以就等于nums[i-1]的最大值，所以f[i] = max(f[i - 1], g[i - 1])<br>
g[i]表示选了nums[i]的最大值，既然选了nums[i]，那么肯定没有选nums[i - 1]，于是g[i] = f[i - 1] + nums[i]。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; f(n + 1), g(n + 1);
        
        for (int i = 1; i &lt;=n; i ++ )
        {
            f[i] = max(f[i - 1], g[i - 1]);
            g[i] = f[i - 1] + nums[i - 1];
        }
        
        return max(f[n], g[n]);
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [0 for _ in range(n + 1)]
        g = [0 for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            f[i] = max(f[i - 1], g[i - 1])
            g[i] = f[i - 1] + nums[i - 1]
            
        return max(f[n], g[n])
</code></pre>
<h4 id="300-longest-increasing-subsequence"><a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></h4>
<p>题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<pre><code>示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
</code></pre>
<p>Note:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。<br>
分析：用DP来解决，首先状态表示f[i]：表示以第i个数结尾的上升子序列的最大值；然后是状态更新，我们要遍历从0到i的所有数，如果nums[j] &lt; nums[i]， 就说明它可i以被放进去，那么f[i] = max(f[i], f[j] + 1)，最后再遍历f，找出最大值即可。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; f(n, 1);
        
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; i; j ++)
                if (nums[j] &lt; nums[i])
                {
                    f[i] = max(f[i], f[j] + 1);
                }
        
        int res = 0;
        for (int i = 0; i &lt; n; i ++) res = max(res, f[i]);
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        n = len(nums)
        f = [1 for _ in range(n)]
        
        for i in range(n):
            for j in range(i):
                if nums[j] &lt; nums[i]:
                    f[i] = max(f[i], f[j] + 1)
        
        res = 0
        for i in range(n): res = max(res, f[i])
        return res
</code></pre>
<h4 id="72-edit-distance"><a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a></h4>
<p>题目描述：给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>
你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<pre><code>示例:
输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出: 3
解释: 
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')
</code></pre>
<p>分析：首先集合表示：f[i, j]表示将第一个字符串的前i个字母，变成第二个字符串的前j个字母的方案的最小值，那么在进行状态计算时，我们考虑最后一步的情况，由于它共有三种操作方式，所以最后一步的情况如下：</p>
<ol>
<li>插入：我在第一个字符串中插入一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i个字符和第二个字符串的前j - 1个字符相同，所以f[i, j] = f[i, j - 1] + 1</li>
<li>删除：我在第一个字符串中删除一个字符使得它和第二个字符串的前j个字符串相同，所以说，现在第一个字符串的前i - 1个字符和第二个字符串的前j的字符相同，所以f[i, j] = f[i - 1, j] + 1</li>
<li>替换：替换又分为两种情况：1）第一个字符串的第i个字符和第二个字符串的第j个字符是相同的，不需要替换了，所以f[i, j] = f[i - 1, j - 1]; 2）第一个字符串的第i个字符和第二个字符串的第j个字符是不同的，需要替换一下，所以f[i, j] = f[i - 1, j - 1] + 1;<br>
最后只需要在上面四种方案中求一个最小值代表状态即可。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size(), m = word2.size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));
        for (int i = 0; i &lt;= n; i ++) f[i][0] = i;
        for (int i = 0; i &lt;= m; i ++) f[0][i] = i;
        for (int i = 1; i &lt;= n; i ++)
            for (int j = 1; j &lt;= m; j ++)
            {
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1;
                f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i -1] != word2[j - 1]));
            }
        
        return f[n][m];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        n, m = len(word1), len(word2)
        f = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
        for i in range(n + 1): f[i][0] = i
        for i in range(m + 1): f[0][i] = i
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1
                f[i][j] = min(f[i][j], f[i - 1][j - 1] + (word1[i - 1] != word2[j - 1]));
        return f[n][m]
</code></pre>
<h4 id="518-coin-change-2"><a href="https://leetcode.com/problems/coin-change-2/">518. Coin Change 2</a></h4>
<p>题目描述：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。<br>
Note:<br>
你可以假设：</p>
<ul>
<li>0 &lt;= amount (总金额) &lt;= 5000</li>
<li>1 &lt;= coin (硬币面额) &lt;= 5000</li>
<li>硬币种类不超过 500 种</li>
<li>结果符合 32 位符号整数</li>
</ul>
<pre><code>示例:
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre>
<p>分析：首先状态表示f[i,j]表示为用前i个硬币凑出总钱数为j的凑法的数量，那么在状态表示时，有很多种情况：</p>
<ol>
<li>用了0个第i个硬币，所以f[i, j] = f[i - 1, j];</li>
<li>用了t个第i个硬币，所以f[i, j] = f[i - 1, j - t * coins[i]];<br>
所以，f[i ,j] = f[i - 1, j] + f[i - 1, j - c] + f[i - 1, j - 2c] + ... + f[i - 1, j - kc]<br>
但是，f[i, j - c] = f[i - 1, j - c] + f[i - 1, j - 2c]  + ... + f[i - 1, j - kc]<br>
所以，我们可以用f[i, j - c]的状态替换掉后面一堆东西，于是f[i, j] = f[i - 1, j] + f[i, j - c]<br>
由于这里i只与上一层有关系，所以可以用滚动数组来求解，同时f[i - 1, j] 与 f[i , j]表示的j都是一样的，所以可以用一个一维的滚动数组来简化f[j] = f[j] + f[j - c]。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        int m = amount;
        vector&lt;int&gt; f(m + 1);
        f[0] = 1;
        for (auto c : coins)
            for (int j = c; j &lt;= m; j ++)
                f[j] += f[j - c];
        return f[m];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        m = amount
        f = [0 for _ in range(m + 1)]
        f[0] = 1
        for coin in coins:
            for j in range(coin, m + 1):
                f[j] += f[j - coin]
        return f[m]
</code></pre>
<h4 id="664-strange-printer"><a href="https://leetcode.com/problems/strange-printer/">664. Strange Printer</a></h4>
<p>题目描述：有台奇怪的打印机有以下两个特殊要求：<br>
打印机每次只能打印同一个字符序列。<br>
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。<br>
给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。</p>
<pre><code>示例:
输入: &quot;aba&quot;
输出: 2
解释: 首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 'a'。
</code></pre>
<p>分析：f[l][r]表示将[L, R]染成最终模样的方式的最小值：<br>
<img src="https://tudouvvv.github.io//post-images/1570433988785.png" alt=""><br>
首先是把端点染成想要的颜色，f[l][r] = f[l + 1][r] + 1<br>
然后另一种情况是染[l, k]，l和k处的颜色相同的话，f[l][r]= f[l][k - 1] + f[k + 1][r]<br>
最后求两者的最小值即可。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int strangePrinter(string s) {
        int n = s.size();
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1));
        if (s.empty()) return 0;
        for (int len = 1; len &lt;= n; len ++)
            for (int l = 0; l + len - 1 &lt; n; l ++)
            {
                int r = l + len - 1;
                f[l][r] = f[l + 1][r] + 1;
                for (int k = l + 1; k &lt;= r; k ++)
                    if (s[l] == s[k])
                        f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r]);
            }
        return f[0][n - 1];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def strangePrinter(self, s: str) -&gt; int:
        n = len(s)
        if n == 0: return 0
        f = [[0 for _ in range(n + 1)]for _ in range(n + 1)]
        for lens in range(1, n + 1):
            for l in range(0, n - lens + 1):
                r = l + lens - 1
                f[l][r] = f[l + 1][r] + 1
                for k in range(l + 1, r + 1):
                    if s[l] == s[k]:
                        f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r])
                        print(f)
        return f[0][n - 1]
</code></pre>
<h4 id="10-regular-expression-matching存疑">❌<a href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching</a>(存疑)</h4>
<p>题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p>
<pre><code>'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
</code></pre>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。<br>
Note:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li>
</ul>
<pre><code>示例:
输入:
s = &quot;aa&quot;
p = &quot;a*&quot;
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。
</code></pre>
<p>分析：考虑用DP来做，f[i][j]表示s的第i个字符与p的第j个字符是否匹配，我们现在已经得知了之前的状态，也就是f[i - 1][j - 1]，现在要考虑的就是s[i]与p[j]的关系：</p>
<ol>
<li>如果s[i] = p[j], 那么f[i][j] = f[i - 1][j - 1]</li>
<li>如果p[j] = '.', 那么f[i][j] = f[i - 1][j - 1]</li>
<li>如果p[j] = '*', 那么我们要考虑s[i] 与 p[j - 1]的关系：
<ol>
<li>如果s[i] != p[j - 1], 那么f[i][j] = f[i - 1][j - 2]，此时*表示匹配0个前面的字母</li>
<li>如果p[j - 1] = '.' || p[j - 1] = s[i]：</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第七周(基本数据结构专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第七周(基本数据结构专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第七周(基本数据结构专题)">
        </link>
        <updated>2019-09-23T07:09:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-two-sum"><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h4>
<p>题目描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<pre><code>示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<p>分析：可以设计一个字典来保存值与索引的映射关系，然后去找target-nums[i]是否在字典中，如果在并且该值不等于nums[i]的话(避免重复利用)，就说明这是一个答案。<br>
Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        dicts = {}
        for i, v in enumerate(nums):
            dicts[v] = i
        for i in range(len(nums)):
            if target - nums[i] in dicts and dicts[target - nums[i]] != i:
                return [i, dicts[target-nums[i]]]
</code></pre>
<p>也可以用hash表来做：<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hash;
        for (int i = 0; i &lt; nums.size(); i ++)
        {
            if (hash.count(target - nums[i]))  return{hash[target - nums[i]], i};
            hash[nums[i]] = i;
        }
        return {-1, -1};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        dicts = {}
        for i in range(len(nums)):
            if target - nums[i] in dicts:
                return [dicts[target - nums[i]], i]
            dicts[nums[i]] = i
        return [-1, -1]
</code></pre>
<p>Ps.</p>
<ul>
<li>if (hash.count(key)) 是判断hash表中是否存在关键字key；</li>
<li>if (hash[key]) 是判断key对应的value值是否是真，如果key在hash表中不存在，则会先为其创建默认值，比如int的默认值是0，vector<int>的默认值是vector<int>()；<br>
在C++中，如果想往哈希表中插入一对(key, value)，一般写hash[key] = value；<br>
如果想查找一个key是否存在，一般有两种写法：</li>
<li>if (hash.find(key) != hash.end())</li>
<li>if (hash.count(key) != 0)<br>
第二种写法短一些，所以用得比较多。<br>
来源：<a href="https://www.acwing.com/">AcWing</a></li>
</ul>
<h4 id="187-repeated-dna-sequences"><a href="https://leetcode.com/problems/repeated-dna-sequences/">187. Repeated DNA Sequences</a></h4>
<p>题目描述：所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。<br>
编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</p>
<pre><code>示例:=
输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;
输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]
</code></pre>
<p>分析：如果是确定的十个字母长的字符串，那是否可以从前往后枚举，至多就有n - 1中情况，这样是不是有点慢。<br>
好吧，确实是这样做的，先把字符串中长度为10的子串拿出啦插入到hash表中，然后统计次数，最后输出次数大于等于2的子串就可以了。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; findRepeatedDnaSequences(string s) {
        unordered_map &lt;string, int&gt; hash;
        vector&lt;string&gt; res;
        for (int i = 0; i + 10 &lt;= s.size(); i ++)
        {
            string str = s.substr(i, 10);
            hash[str] ++;
            if (hash[str] == 2) res.push_back(str);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findRepeatedDnaSequences(self, s: str) -&gt; List[str]:
        dicts = {}
        res  = []
        for i in range(len(s) - 9):
            substr = s[i : i + 10]
            dicts.setdefault(substr, 0)
            dicts[substr] += 1
            if dicts[substr] == 2: res.append(substr)
        return res
</code></pre>
<h4 id="706-design-hashmap"><a href="https://leetcode.com/problems/design-hashmap/">706. Design HashMap</a></h4>
<p>题目描述：不使用任何内建的哈希表库设计一个哈希映射<br>
具体地说，你的设计应该包含以下的功能</p>
<ul>
<li>put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。</li>
<li>get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。</li>
<li>remove(key)：如果映射中存在这个键，删除这个数值对。<br>
Note:</li>
<li>所有的值都在 [1, 1000000]的范围内。</li>
<li>操作的总数目在[1, 10000]范围内。</li>
<li>不要使用内建的哈希库。</li>
</ul>
<pre><code>示例：
MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);         
hashMap.get(1);            // 返回 1
hashMap.get(3);            // 返回 -1 (未找到)
hashMap.put(2, 1);         // 更新已有的值
hashMap.get(2);            // 返回 1 
hashMap.remove(2);         // 删除键为2的数据
hashMap.get(2);            // 返回 -1 (未找到) 
</code></pre>
<p>分析：为了避免插入的时候冲突，使用拉链法，用一个链表来存储映射到该位置的元素。</p>
<ol>
<li>对于put(key, value)操作:<br>
先求出key的哈希值(取模)，然后遍历该位置上的链表:<br>
如果链表中包含key，则更新其对应的value；<br>
如果链表中不包含key，则直接将（key，value）插入该链表中。</li>
<li>对于get(key)操作:<br>
求出key对应的哈希值后，遍历该位置上的链表.<br>
如果key在链表中，则返回其对应的value，否则返回-1。</li>
<li>对于remove(key)，求出key的哈希值后，遍历该位置上的链表，如果key在链表中，则将其删除。</li>
</ol>
<p>Python</p>
<pre><code class="language-python">class MyHashMap:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.hash = [[] for _ in range(20011)]
        # 开辟一个大数组，长度为质数，注意这里不能用 [[]] * 20011，会被覆盖
        # 一般定义成离2的整次幂比较远的质数，这样取模之后冲突的概率比较低。

    def put(self, key: int, value: int) -&gt; None:
        &quot;&quot;&quot;
        value will always be non-negative.
        &quot;&quot;&quot;
        index = key % 20011
        for item in self.hash[index]:
            if item[0] == key:
                item[1] = value
                return
        self.hash[index].append([key, value])

    def get(self, key: int) -&gt; int:
        &quot;&quot;&quot;
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        &quot;&quot;&quot;
        index = key % 20011
        for item in self.hash[index]:
            if item[0] == key:
                return item[1]
        return -1

    def remove(self, key: int) -&gt; None:
        &quot;&quot;&quot;
        Removes the mapping of the specified value key if this map contains a mapping for the key
        &quot;&quot;&quot;
        index = key % 20011
        delete = []
        for item in self.hash[index]:
            if item[0] == key:
                self.hash[index].remove(item)

# Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)
</code></pre>
<h4 id="652-find-duplicate-subtrees"><a href="https://leetcode.com/problems/find-duplicate-subtrees/">652. Find Duplicate Subtrees</a></h4>
<p>题目描述：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。<br>
两棵树重复是指它们具有相同的结构以及相同的结点值。<br>
分析:<br>
首先把所有的子树枚举出来，然后把该子树用hash映射成一个整数。然后在建一个hash表示每个子树出现的次数，寻找子树时可以使用前序遍历的深度优先搜索。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    int cnt = 0;
    unordered_map&lt;string, int&gt; hash;
    unordered_map&lt;int, int&gt; count;
    vector &lt;TreeNode*&gt; ans;
    
    string dfs(TreeNode* root)
    {
        if (!root) return to_string(hash[&quot;#&quot;]);
        
        auto left = dfs(root-&gt;left);
        auto right = dfs(root-&gt;right);
        string tree = to_string(root-&gt;val) + ',' + left + ',' + right;
        if (! hash.count(tree)) hash[tree] = ++ cnt;
        int t = hash[tree];
        count[t] ++ ;
        if (count[t] == 2) ans.push_back(root);
        
        return to_string(t);
        
    }
    
    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) {
        hash[&quot;#&quot;] = ++ cnt;
        dfs(root);
        return ans;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -&gt; List[TreeNode]:
        self.cnt = 0
        hashs = {}
        count = {}
        ans = []
        hashs['#'] = self.cnt = self.cnt + 1
        
        def dfs(root):
            if not root: return str(hashs['#'])
            
            left = dfs(root.left)
            right = dfs(root.right)
            
            tree = str(root.val) + ',' + left + ',' + right
            self.cnt += 1
            hashs.setdefault(tree, self.cnt)
            t = hashs[tree]
            count.setdefault(t, 0)
            count[t] += 1
            if count[t] == 2: ans.append(root)
            
            return str(t)
        
        dfs(root);
        return ans;
</code></pre>
<h4 id="560-subarray-sum-equals-k"><a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a></h4>
<p>题目描述：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。<br>
Note:</p>
<ul>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li>
</ul>
<pre><code>示例:
输入: nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
</code></pre>
<p>分析：滑动窗口嘛//前缀和！！！<br>
用前缀和加hash的方式可以做，每次记录s[i] - k出现的次数，因为假设s[j] = s[i] - k, 那么说明从j+1 到 i的和为k。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int subarraySum(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; hash;
        int res = 0;
        hash[0] = 1;
        
        for (int i = 0, sum = 0; i &lt; nums.size(); i ++)
        {
            sum += nums[i];
            res += hash[sum - k];
            hash[sum] ++;
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        hashs = {}
        res = 0
        count = 0
        hashs[0] = 1
        for i in range(len(nums)):
            count += nums[i]
            if count - k in hashs:
                res += hashs[count - k]
            if count in hashs:
                hashs[count] += 1
            else: hashs[count] = 1
        return res
</code></pre>
<h4 id="547-friend-circles"><a href="https://leetcode.com/problems/friend-circles/">547. Friend Circles</a>(存疑)</h4>
<p>题目描述：班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br>
给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br>
Note:</p>
<ul>
<li>N 在[1,200]的范围内。</li>
<li>对于所有学生，有M[i][i] = 1。</li>
<li>如果有M[i][j] = 1，则有M[j][i] = 1。</li>
</ul>
<pre><code>示例:
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
</code></pre>
<p>分析：<br>
并查集：1）合并两个集合；2）判断两个点是否在同一个集合中。<br>
所以刚开始每个都是单独的集合，如果两个点之间为1，说明它们在一个集合之中，于是合并它们，集合个数减一。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    vector&lt;int&gt; p;
    
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        int n = M.size();
        int res = n;
        for (int i = 0; i &lt; n; i ++) p.push_back(i);
        for (int i = 0; i &lt; n; i ++)
            for (int j = 0; j &lt; i; j ++)
            {
                if (M[i][j] == 0) continue;
                if (find(i) != find(j))
                {
                    p[find(i)] = find(p[j]);
                    res --;
                }
            }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findCircleNum(self, M: List[List[int]]) -&gt; int:
        p = []
        res = n = len(M)
        for i in range(n):
            p.append(i)
            
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]
        
        for i in range(n):
            for j in range(i):
                if M[i][j] == 0: continue
                if find(i) != find(j):
                    p[find(i)] = find(j)
                    res -= 1
        return res
</code></pre>
<h4 id="684-redundant-connection"><a href="https://leetcode.com/problems/redundant-connection/">684. Redundant Connection</a></h4>
<p>题目描述：在本问题中, 树指的是一个连通且无环的无向图。<br>
输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。<br>
结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。<br>
返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>
<pre><code>示例：
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
</code></pre>
<p>分析：并查集应用：<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    vector&lt;int&gt; p;
    
    int find(int x)
    {
        if (p[x] != x)  p[x] = find(p[x]);
        return p[x];
    }
    
    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n = edges.size();
        
        for (int i = 0; i &lt;= n; i ++) p.push_back(i);
        
        for (auto e : edges)
        {
            int a = e[0], b = e[1];
            if (find(a) == find(b)) return {a, b};
            p[find(a)] = find(b);
        }
        
        return {-1, -1};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:
        p = []
        n = len(edges)
        for i in range(n + 1): p.append(i)
        
        def find(x):
            if p[x] != x: p[x] = find(p[x])
            return p[x]
        
        for e in edges:
            a = e[0]
            b = e[1]
            if find(a) == find(b): return [a, b];
            p[find(a)] = find(b)
        return [-1, -1]
</code></pre>
<h4 id="692-top-k-frequent-words"><a href="https://leetcode.com/problems/top-k-frequent-words/">692. Top K Frequent Words</a></h4>
<p>Ps.对一个堆来说:</p>
<ol>
<li>查找最大值O(1)</li>
<li>插入一个数O(logn)</li>
<li>删除一个数O(logn)<br>
题目描述：给一非空的单词列表，返回前 k 个出现次数最多的单词。<br>
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。<br>
Note：</li>
</ol>
<ul>
<li>假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。</li>
<li>输入的单词均由小写字母组成。</li>
</ul>
<pre><code>示例：
输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2
输出: [&quot;i&quot;, &quot;love&quot;]
解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。
</code></pre>
<p>分析：可不可以用hash来做！！！<br>
我们要找出出现次数最多的k个单词，用小根堆来维护出现次数最多的k个单词。</p>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) {
        unordered_map&lt;string, int&gt; hash;
        typedef pair&lt;int, string&gt; PIS;
        priority_queue&lt;PIS&gt; heap;
        
        for (auto word : words) hash[word] ++;
        
        for (auto item : hash)
        {
            PIS t(-item.second, item.first);
            heap.push(t);
            if (heap.size() &gt; k) heap.pop();
        }
        
        vector&lt;string&gt; res(k);
        for (int i = k - 1; i &gt;= 0; i --)
        {
            res[i] = heap.top().second;
            heap.pop();
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution(object):
    def topKFrequent(self, words, k):
        count = collections.Counter(words)
        heap = [(-freq, word) for word, freq in count.items()]
        heapq.heapify(heap)
        # print(heapq.nsmallest(3, heap))
        return [heapq.heappop(heap)[1] for _ in range(k)]
</code></pre>
<p>也可以直接用排序来做：<br>
Python</p>
<pre><code class="language-python">class Solution:
    def topKFrequent(self, words: List[str], k: int) -&gt; List[str]:
        d = {}
        for word in words: 
            d[word] = d.get(word, 0) + 1
        res = sorted(d, key = lambda word : (-d[word], word))
        return res[:k]
</code></pre>
<h4 id="295-find-median-from-data-stream"><a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream</a></h4>
<p>题目描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<br>
例如，<br>
[2,3,4] 的中位数是 3<br>
[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>
设计一个支持以下两种操作的数据结构：<br>
void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>
double findMedian() - 返回目前所有元素的中位数。</p>
<pre><code>示例：
addNum(1)
addNum(2)
findMedian() -&gt; 1.5
addNum(3) 
findMedian() -&gt; 2
</code></pre>
<p>分析：init一个列表，每次add的时候就往里加元素，find的时候判断长度是否为偶数，可能需要注意的是添加数以后列表应该也是有序的。<br>
Python</p>
<pre><code class="language-python">class MedianFinder:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.res = []

    def addNum(self, num: int) -&gt; None:
        self.res.append(num)

    def findMedian(self) -&gt; float:
        self.res = sorted(self.res)
        n = len(self.res)
        if n % 2 == 0:
            return float((self.res[n//2] + self.res[n//2 - 1]) * 0.5)
        else:
             return self.res[int(n/2)]

# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
</code></pre>
<p>然后超时了，因为每次都要对列表进行排序，耗费的时间太多。<br>
正确的解法：构建一个对顶堆：<br>
<img src="https://tudouvvv.github.io//post-images/1569500324525.png" alt=""><br>
如图，上面是一个小根堆，保存数值较大的一部分，下面是一个大根堆，保存数值较小的一部分，每部分的元素个数都是n / 2，这样中间的元素就是我们要找的数。<br>
如果 x&gt;= 下面的根节点，插入上面的堆，反之插入下面的堆，然后维护两个堆的个数即可。<br>
C++</p>
<pre><code class="language-c++">class MedianFinder {
public:
    
    priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; up;
    priority_queue &lt;int&gt; down;
    
    /** initialize your data structure here. */
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if (down.empty() || num &gt; down.top()) up.push(num);
        else
        {
            down.push(num);
            up.push(down.top());
            down.pop();
        }
        if (up.size() &gt; down.size() + 1)
        {
            down.push(up.top());
            up.pop();
        }
    }
    
    double findMedian() {
        if (down.size() + up.size() &amp; 1) return up.top();
        else return (down.top() + up.top()) / 2.0;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj-&gt;addNum(num);
 * double param_2 = obj-&gt;findMedian();
 */
</code></pre>
<p>Python</p>
<pre><code class="language-python">from heapq import heappush, heappop
class MedianFinder:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.up = []
        self.down = []

    def addNum(self, num: int) -&gt; None:
        if (len(self.down) == 0 or -num &lt; self.down[0]): 
            heappush(self.up, num);
        else:
            heappush(self.down, -num)
            heappush(self.up, -self.down[0])
            heappop(self.down)
            
        if len(self.up) &gt; len(self.down) + 1:
            heappush(self.down, -self.up[0])
            heappop(self.up)

    def findMedian(self) -&gt; float:
        if len(self.up) + len(self.down) &amp; 1: return self.up[0]
        else: 
            return (self.up[0] - self.down[0]) * 0.5

# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
</code></pre>
<h4 id="352-data-stream-as-disjoint-intervals"><a href="https://leetcode.com/problems/data-stream-as-disjoint-intervals/">352. Data Stream as Disjoint Intervals</a></h4>
<p>题目描述：给定一个非负整数的数据流输入 a1，a2，…，an，…，将到目前为止看到的数字总结为不相交的区间列表。<br>
例如，假设数据流中的整数为 1，3，7，2，6，…，每次的总结为：</p>
<ol>
<li>[1, 1]</li>
<li>[1, 1], [3, 3]</li>
<li>[1, 1], [3, 3], [7, 7]</li>
<li>[1, 3], [7, 7]</li>
<li>[1, 3], [6, 7]<br>
分析：根据题意，在第四步的时候，应该加一个区间[2, 2]，但是由于[1, 2, 3]是连续的，所以合并区间，变为了[1, 3]。<br>
用平衡树来维护所有区间，构建两个字典，L和R，分别对左右端点进行映射，L中的value是左端点，R中的value是右端点，然后当有新的x插入的时候，一共有四种情况：<br>
<img src="https://tudouvvv.github.io//post-images/1569506788992.png" alt=""><br>
比如说一个区间是[x, y]，那么L[y] = x, R[x] = y。<br>
C++</li>
</ol>
<pre><code class="language-c++">class SummaryRanges {
public:
    /** Initialize your data structure here. */
    
    map&lt;int, int&gt; L, R;
    
    SummaryRanges() {
        
    }
    
    void addNum(int x) {
        if (L.size())
        {
            auto it = L.lower_bound(x);
            if (it != L.end() &amp;&amp; it-&gt;second &lt;= x) return;
        }
        
        int left = L.count(x - 1), right = R.count(x + 1);
        
        if (left &amp;&amp; right)
        {
            R[L[x - 1]] = R[x + 1];
            L[R[x + 1]] = L[x - 1];
            L.erase(x - 1), R.erase(x + 1);
        }
        else if (left)
        {
            R[L[x - 1]] = x;
            L[x] = L[x - 1];
            L.erase(x - 1);
        }
        else if (right)
        {
            L[R[x + 1]] = x;
            R[x] = R[x + 1];
            R.erase(x + 1);
        }
        else
        {
            R[x] = L[x] = x;
        }
        
    }
    vector&lt;vector&lt;int&gt;&gt; getIntervals() {
        vector&lt;vector&lt;int&gt;&gt; res;
        for (auto item : R) res.push_back({item.first, item.second});
        return res;
    }
};

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges* obj = new SummaryRanges();
 * obj-&gt;addNum(val);
 * vector&lt;vector&lt;int&gt;&gt; param_2 = obj-&gt;getIntervals();
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第六周( 滑动窗口、双指针、单调队列和单调栈专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第六周</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第六周">
        </link>
        <updated>2019-09-05T08:42:03.000Z</updated>
        <content type="html"><![CDATA[<h4 id="167-two-sum-ii-input-array-is-sorted"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167. Two Sum II - Input array is sorted</a></h4>
<p>题目描述：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>
Note：</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<pre><code>示例:
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
</code></pre>
<p>分析：暴力做法：设置两个for循环，来遍历数对，由于是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的复杂度，所以超时了。<br>
双指针算法：我们设定两个指针i和j，i &lt;= j ，并且nums[i] + nums[j] &gt;= target，当i增大时，j势必会减小，这样就有一个单调性，直到我们找到答案。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        for (int i = 0, j = numbers.size() - 1; i &lt; numbers.size(); i ++)
        {
            while (j - 1 &gt; i &amp;&amp; numbers[j - 1] + numbers[i] &gt;= target) j --;
            if (numbers[i] + numbers[j] == target) return{i + 1, j + 1};
        }
        return {};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        j = len(numbers) - 1
        for i in range(len(numbers)):
            while j - 1 &gt; i and numbers[j - 1] + numbers[i] &gt;= target:
                j -= 1
            if numbers[i] + numbers[j] == target: 
                return [i + 1, j + 1]
        return []
</code></pre>
<h4 id="88-merge-sorted-array"><a href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a></h4>
<p>题目描述：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>
Note：<br>
说明:</p>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li>
</ul>
<pre><code>示例:
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]
</code></pre>
<p>分析：先用两个指针分别指向每个数组的最后一位，表示该数组的最大值；每次把两个指针指向的最大值拿出来，然后放在后面。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i &gt;= 0 &amp;&amp; j &gt;= 0)
            if (nums1[i] &gt; nums2[j]) nums1[k -- ] = nums1[i --];
            else nums1[k --] = nums2[j --];
        while (j &gt;= 0) nums1[k --] = nums2[j --];        
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        while m &gt; 0 and n &gt; 0:
            if nums1[m - 1] &gt; nums2[n - 1]:
                nums1[m + n - 1] = nums1[m - 1]
                m -= 1
            else:
                nums1[m + n - 1] = nums2[n - 1]
                n -= 1
        if n &gt; 0:
            nums1[:n] = nums2[:n]
</code></pre>
<h4 id="26-remove-duplicates-from-sorted-array"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></h4>
<p>题目描述：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<pre><code>示例 :
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p>分析：可以设置一个指针target指向最小的数字，每次与它进行判断，如果比它大，那么这就是一个新的数，替换target，并且交换位置。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int target = nums[0];
        int count = 1;
        for (int i = 1; i &lt; nums.size(); i ++)
        {
            if (nums[i] &gt; target)
            {
                target = nums[i];
                int tmp = nums[count];
                nums[count] = nums[i];
                nums[i] = tmp;
                count += 1;
            }
        }
        return count;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if not nums:
            return 0
        min_target = nums[0]
        count = 1
        i = 1
        while i &lt; len(nums):
            if nums[i] &gt; min_target:
                min_target = nums[i]
                nums[count], nums[i] = nums[i], nums[count]
                count += 1
            i += 1
        return count
</code></pre>
<p>其实，不需要这么麻烦，设定一个指针k指向前面不同的数的最后一位的下一位，从前往后遍历，每次与它的前一个数进行比较，不同的话替换前面的指针k指向的数，k + 1即可；</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int k = 1;
        for (int j = 1; j &lt; nums.size(); j ++)
        {
        if (nums[j] != nums[j - 1]) nums[k ++] = nums[j];
        }
        return k;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums: return 0
        k = 1;
        for i in range(1, len(nums)):
            if nums[i] != nums[i - 1]:
                nums[k] = nums[i];
                k += 1
        return k;
</code></pre>
<h4 id="76-minimum-window-substring"><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></h4>
<p>题目描述：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。<br>
Note：</p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<pre><code>示例：
输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;
输出: &quot;BANC&quot;
</code></pre>
<p>分析：暴力写法：枚举S所有的子串，再去看是否包含T里所有的字母。<br>
滑动窗口算法：i和j表示窗口的左右两个边界，j随i的变化而变化，设定一个hash表表示t中字母的数量，cnt表示有多少个不同的字母；然后遍历s，设定一个变量c表示遇到了几个我们需要的字母，当遇到需要的字母时<code>if hash[s[i]] == 1: c ++</code>，然后<code>hash[s[i]] --</code>表示需要的数量-1，这样不断挪动右窗口的边界就行，那做做窗口怎么更新呢？当我们一直往右走时，总会遇到一段拥有所有的字母，此时再往右走，hash中包含我们需要的字母的数值就会变为负值，此时进行判断，如果左边界的字母的hash值是负值，那就说明这个字母我们不需要，因为右边已经有了或者不是我们需要的，然后往右挪动一下，hash++即可。每次挪动右边记得要更新答案。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map&lt;char, int&gt; hash;
        string res;
        for (auto c : t) hash[c] ++;
        int cnt = hash.size();
        for (int i = 0, j = 0, c = 0; i &lt; s.size(); i ++)
        {
            if (hash[s[i]] == 1) c++;
            hash[s[i]] --;
            while (hash[s[j]] &lt; 0) hash[s[j ++]] ++;
            if (c == cnt)
            {
                if (res.empty() || res.size() &gt; i - j + 1) res = s.substr(j, i - j + 1);
            }
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">import collections

class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        hash_dict = collections.Counter(t)
        res = &quot;&quot;
        cnt = len(hash_dict)
        j = 0
        c = 0
        for i in range(len(s)):
            if (hash_dict[s[i]] == 1): c += 1
            hash_dict[s[i]] -= 1
            while j &lt; len(s) and hash_dict[s[j]] &lt; 0:
                hash_dict[s[j]] += 1
                j += 1
            if c == cnt:
                if (not res) or len(res) &gt; i - j + 1:
                    res = s[j : i+1]
        return res     
</code></pre>
<h4 id="32-longest-valid-parentheses"><a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a></h4>
<p>题目描述：给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。</p>
<pre><code>示例 :
输入: &quot;)()())&quot;
输出: 4
解释: 最长有效括号子串为 &quot;()()&quot;
</code></pre>
<p>分析：刚开始考虑用栈来做...<br>
括号序列的一个性质：</p>
<ul>
<li>不论怎么匹配，左右括号一定是确定的</li>
<li>一个括号序列合法&lt;=&gt;所有前缀和&gt;=0，且总和=0(左括号为1，右括号为-1)<br>
所以我们可以用这个性质来做，start表示当前枚举的开头位置，cnt表示前缀和，然后开始遍历，计算start--&gt;i的前缀和cnt，如果cnt&lt;0，那就说明当前这一段不合法，start = i + 1，cnt = 0继续遍历；如果cnt &gt; 0那就说明当前合法，继续做；如果cnt = 0， 那就说明[start, i]这一段是合法序列，更新答案即可；但是会有这样一种情况，左括号的数量大于右括号的数量<code>(((())</code>这样cnt永远&gt;0，是更新不了答案的，所以还需要反着再来一遍。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    
    int work(string s)
    {
        int res = 0;
        for (int i = 0, start = 0, cnt = 0; i &lt; s.size(); i ++)
        {
            if (s[i] == '(') cnt ++ ;
            else
            {
                cnt -- ;
                if (cnt &lt; 0) start = i + 1, cnt = 0;
                else if (cnt == 0)  res = max(res, i - start + 1);
            }
        }
        return res;
    }
    
    int longestValidParentheses(string s) {
        int res = work(s);
        reverse(s.begin(), s.end());
        for (auto &amp;c : s) c ^= 1;
        return max(res, work(s));
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        res = self.work(s);
        s = s[::-1];
        s_reverse = &quot;&quot;
        for char in s:
            char = chr(ord(char) ^ 1)
            s_reverse += char
        return max(res, self.work(s_reverse))
    
    def work(self, s):
        res, start, cnt = 0, 0, 0
        for i in range(len(s)):
            if s[i] == '(': cnt += 1
            else:
                cnt -= 1
                if cnt &lt; 0: start, cnt = i + 1, 0
                elif cnt == 0:
                    res = max(res, i - start + 1)
        return res      
</code></pre>
<p>用栈来做：<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int longestValidParentheses(string s) {
        stack&lt;int&gt; stack;
        int ans = 0;
        int base = -1;
        for (int i = 0; i &lt; s.size(); i ++ )
        {
            if (s[i] == '(') stack.push(i);
            else 
                if (stack.size() &gt; 0)
                {
                    stack.pop();
                    if (stack.size() == 0) ans = max(ans, i - base);
                    else ans = max(ans, i - stack.top());
                }
                else base = i;
        }
        return ans;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        stack = []
        ans = 0
        base = -1
        for i, c in enumerate(s):
            if c == '(': stack.append(i)
            elif stack:
                stack.pop()
                if stack:
                    ans = max(ans, i - stack[-1])
                else:
                    ans = max(ans, i - base)
            else:
                base = i
        return ans
</code></pre>
<h4 id="155-min-stack"><a href="https://leetcode.com/problems/min-stack/">155. Min Stack</a></h4>
<p>题目描述：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) -- 将元素 x 推入栈中。</li>
<li>pop() -- 删除栈顶的元素。</li>
<li>top() -- 获取栈顶元素。</li>
<li>getMin() -- 检索栈中的最小元素。</li>
</ul>
<pre><code>示例:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</code></pre>
<p>分析：本来的想法是建立一个列表，通过append和del操作来构造所需要的函数。<br>
后来发现可以直接调用push和pop操作，不过唯一不同的是，在进行getMin操作时，可以新建一个栈，存的当前栈的最小值，第一个元素表示第一个数的最小值（也就是第一个数），第二个元素存的是前两个数的最小值，以此类推...<br>
C++</p>
<pre><code class="language-c++">class MinStack {
public:
    
    stack&lt;int&gt; stk, stk_min;
    
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        stk.push(x);
        if (stk_min.empty()) stk_min.push(x);
        else stk_min.push(min(x, stk_min.top()));
    }
    
    void pop() {
        stk.pop();
        stk_min.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return stk_min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(x);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
</code></pre>
<p>Python</p>
<pre><code class="language-python">class MinStack:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stk = []
        self.stk_min = []

    def push(self, x: int) -&gt; None:
        self.stk.append(x)
        if self.stk_min:
            self.stk_min.append(min(x, self.stk_min[-1]))
        else: self.stk_min.append(x)

    def pop(self) -&gt; None:
        self.stk.pop()
        self.stk_min.pop()

    def top(self) -&gt; int:
        return self.stk[-1]

    def getMin(self) -&gt; int:
        return self.stk_min[-1]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
</code></pre>
<h4 id="84-largest-rectangle-in-histogram"><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram</a></h4>
<p>题目描述：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>
求在该柱状图中，能够勾勒出来的矩形的最大面积。<br>
<img src="https://tudouvvv.github.io//post-images/1568512602453.png" alt=""></p>
<pre><code>示例:
输入: [2,1,5,6,2,3]
输出: 10
</code></pre>
<p>分析：<br>
单调栈：查找每个数左/右侧第一个比它小/大的数<br>
单调队列：查找滑动窗口中的最值<br>
这道题首先要考虑的是如何能枚举出来所有的矩形：</p>
<ol>
<li>枚举所有柱形的上边界作为整个矩形的上边界，然后求出左右边界（往左右可以扩充的位置）</li>
<li>找出左边离它最近的，比它小的柱形</li>
<li>找出右边离它最近的，比它小的柱形<br>
比如输入[2,1,5,6,2,3]，构建一个栈，每次push元素的时候都要比栈顶元素大，如果没有，就pop栈直到栈中没有比它大的元素，再进栈，这样就构成了一个单调栈。<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        int n = heights.size();
        vector&lt;int&gt; left(n), right(n);
        
        stack&lt;int&gt; stk;
        for (int i = 0; i &lt; n; i ++)
        {
            while (stk.size() &amp;&amp; heights[stk.top()] &gt;= heights[i])  stk.pop();
            if (stk.empty()) left[i] = -1;
            else left[i] = stk.top();
            stk.push(i);
        }
        while(stk.size()) stk.pop();
        for (int i = n - 1; i &gt;= 0; i --)
        {
            while (stk.size() &amp;&amp; heights[stk.top()] &gt;= heights[i]) stk.pop();
            if (stk.empty()) right[i] = n;
            else right[i] = stk.top();
            stk.push(i);
        }
        
        int res = 0;
        for (int i = 0; i &lt; n; i ++)  res = max(res, heights[i] * (right[i] - left[i] - 1));
        
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def largestRectangleArea(self, heights: List[int]) -&gt; int:
        n = len(heights)
        right, left = [0] * n, [0] * n
        stk = []
        for i in range(n):
            while (len(stk) and heights[stk[-1]] &gt;= heights[i]): stk.pop()
            if not stk: left[i] = -1
            else: left[i] = stk[-1]
            stk.append(i)
        while len(stk): stk.pop()
        
        for i in range(n-1, -1, -1):
            while (len(stk) and heights[stk[-1]] &gt;= heights[i]): stk.pop()
            if not stk: right[i] = n
            else: right[i] = stk[-1]
            stk.append(i)
        res = 0
        for i in range(n): res = max(res, heights[i] * (right[i] - left[i] - 1))

        return res
</code></pre>
<h4 id="42-trapping-rain-water"><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a></h4>
<p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
<img src="https://tudouvvv.github.io//post-images/1568259976116.png" alt=""></p>
<pre><code>示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
</code></pre>
<p>分析：找到数组中的低谷，低谷就是雨水可以存在的位置。</p>
<ul>
<li>三次线性扫描<br>
每个矩形上方的水的数量是由它自己、它左边最高的位置以及它右边最高的位置决定的，所以我们需要首先得到每个位置左边最高位置和右边最高位置，然后水的数量就等于 <code>min(left[i], right[i]) - height[i]</code>。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        int res = 0;
        
        if (n == 0) return 0;
        
        vector&lt;int&gt; left(n), right(n);
        left[0] = height[0];
        for (int i = 1; i &lt; n; i ++)
            left[i] = max(left[i - 1], height[i]);
        right[n - 1] = height[n - 1];
        for (int i = n - 2; i &gt;= 0; i --)
            right[i] = max(right[i + 1], height[i]);
        for (int i = 0; i &lt; n; i ++)
            res += min(left[i], right[i]) - height[i];
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def trap(self, height: List[int]) -&gt; int:
        n = len(height)
        res = 0
        left, right = [0] * n, [0] * n
        
        if not height: return 0
        
        left[0] = height[0]
        for i in range(n):
            left[i] = max(left[i - 1], height[i])
        right[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            right[i] = max(right[i + 1], height[i])
            
        for i in range(n):
            res += min(left[i], right[i]) - height[i]
        
        return res
</code></pre>
<ul>
<li>单调栈（存疑）</li>
</ul>
<h4 id="239-sliding-window-maximum"><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></h4>
<p>题目描述：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>
返回滑动窗口中的最大值。</p>
<pre><code>示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>分析：</p>
<ul>
<li>暴力解法：枚举所有的情况，python可以进行切片操作，然后用max得到该窗口内的最大值。<br>
Python</li>
</ul>
<pre><code class="language-python">class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        if not nums:
            return []
        res = []
        n = len(nums)
        for i in range(n - k + 1):
            res.append(max(nums[i:i + k]))
        return res
</code></pre>
<ul>
<li>单调队列<br>
单调队列是一个普通的双端队列，即队头和队尾都可以添加和弹出元素。维护这样一个队列：队头元素最大，队尾最小，这样在每个窗口中，只需要push队头元素即可。<br>
每次添加元素时都需要进行检查：1）合法性检查：即如果队头元素下标已经不在窗口范围内，应该出队；2）单调性检查：如果nums[i]大于或等于队尾元素下标所对应的值，则当前队尾再也不可能充当某个滑动窗口的最大值了，故需要队尾出队。始终保持队中元素从队头到队尾单调递减。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        vector&lt;int&gt; res;
        deque&lt;int&gt; q;
        for(int i = 0; i &lt; nums.size(); i ++)
        {
            while (q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front();
            while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();
            q.push_back(i);
            if (i &gt;= k - 1)  res.push_back(nums[q.front()]);
        }
        
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        res = []
        q = []
        n = len(nums)
        for i in range(n):
            if(len(q) and i - k + 1 &gt; q[0]): 
                q.pop(0)
            while(len(q) and nums[i] &gt;= nums[q[-1]]): 
                q.pop()
            q.append(i)
            if i &gt;= k - 1: 
                res.append(nums[q[0]])
        return res
</code></pre>
<h4 id="918-maximum-sum-circular-subarray"><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/">918. Maximum Sum Circular Subarray</a>(存疑)</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第五周(DFS+回溯专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第五周(DFS+回溯专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第五周(DFS+回溯专题)">
        </link>
        <updated>2019-08-28T03:18:25.000Z</updated>
        <content type="html"><![CDATA[<p>搜索 != 递归</p>
<h4 id="17-letter-combinations-of-a-phone-number"><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h4>
<p>题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>
数字到字母的映射与以前电话九宫格按键相同，1不对应任何字母。</p>
<pre><code>示例：
输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre>
<p>分析：用循环来来做这道题，首先设置空列表表示答案，先取出数字，再取出字母，最后再拿出列表中的元素，把它们拼接在一起，更新列表即可。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    string chars[8] = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
    
    vector&lt;string&gt; letterCombinations(string digits) {
        if (digits.empty()) return vector&lt;string&gt;();
        
        vector &lt;string&gt; states(1, &quot;&quot;);
        for (auto u : digits)
        {
            vector &lt;string&gt; now;
            for (auto c : chars[u - '2'])
                for (auto s : states)
                    now.push_back(s + c);
            states = now;
        }
        return states;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        chars = [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;]
        if not digits: return []
        states = [&quot;&quot;]
        for u in digits:
            now = []
            for c in chars[int(u) - 2]:
                for s in states:
                    now.append(s + c)
            states = now
        return states
</code></pre>
<h4 id="79-word-search"><a href="https://leetcode.com/problems/word-search/">79. Word Search</a></h4>
<p>题目描述：给定一个二维网格和一个单词，找出该单词是否存在于网格中。<br>
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<pre><code>示例：
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
给定 word = &quot;ABCCED&quot;, 返回 true.
给定 word = &quot;SEE&quot;, 返回 true.
给定 word = &quot;ABCB&quot;, 返回 false.
</code></pre>
<p>分析：首先枚举起点，从起点开始，依次搜索下一个点的位置，在枚举的过程中，要保证和目标单词匹配。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    int n, m;
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};   
    
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if (board.empty() || board[0].empty()) return false;
        
        n = board.size(), m = board[0].size();
        
        for (int i=0; i &lt; n; i++)
            for (int j=0; j &lt; m; j ++)
                if (dfs(board, i, j, word, 0))
                    return true;
        return false;
    }
    
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string&amp; word, int u)
    {
        if (board[x][y] != word[u]) return false;
        if (u == word.size() - 1) return true;
        
        board[x][y] = '.';
        for (int i=0; i &lt; 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m)
                if (dfs(board, a, b, word, u + 1))
                    return true;
        }
        board[x][y] = word[u];
        
        return false;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def exist(self, board: List[List[str]], word: str) -&gt; bool:
        dx = [-1, 0, 1, 0]
        dy = [0, 1, 0, -1]
        n = len(board)
        m = len(board[0])
        if n == 0 or m == 0:
            return False
        
        def dfs(x, y, u):
            if board[x][y] != word[u]: return False
            if u == len(word) - 1: return True
            board[x][y] = '.'
            for i in range(4):
                a = x + dx[i]
                b = y + dy[i]
                if a &gt;= 0 and a &lt; n and b &gt;=0 and b &lt; m:
                    if dfs(a, b, u+1):
                        return True
            board[x][y] = word[u]
            return False
        
        for i in range(n):
            for j in range(m):
                if dfs(i, j, 0):
                    return True
        return False
</code></pre>
<h4 id="46-permutations"><a href="https://leetcode.com/problems/permutations/">46. Permutations</a></h4>
<p>题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<pre><code>示例:
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
<p>分析：有两种顺序：1. 枚举每个位置上放哪个数。2. 枚举每个数放在哪个位置上。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    int n;
    vector&lt;bool&gt; st;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        n = nums.size();
        st = vector&lt;bool&gt;(n);        
        dfs(nums, 0);
        
        return ans;
    }
    void dfs(vector&lt;int&gt; &amp;nums, int u)
    {
        if (u == n)
        {
            ans.push_back(path);
            return;
        }
        for (int i = 0; i &lt; n; i++)
            if (!st[i])
            {
                st[i] = true;
                path.push_back(nums[i]);
                dfs(nums, u + 1);
                path.pop_back();
                st[i] = false;
            }
    }
};
</code></pre>
<p>Python (这里需要注意的是，当ans.append(path)时，只是引用了path的地址，当path变化的时候，ans中的path也是会变化的，所以如果不对path进行深拷贝的话，那么最后path会变成空，最后ans里面添加的数值都会变成空)</p>
<pre><code class="language-python">class Solution:
    def permute(self, nums: List[int]) -&gt; List[List[int]]:
        n = len(nums)
        st = [0] * n
        path = []
        ans = []
        
        def dfs(u):
            if u == n:
                path_copy = path[::1]
                ans.append(path_copy)
                # ans.append(copy.deepcopy(path))
                return
            for i in range(n):
                if not st[i]:
                    st[i] = True
                    path.append(nums[i])
                    dfs(u + 1)
                    path.pop()
                    st[i] = False
        
        dfs(0)
        return ans
</code></pre>
<h4 id="47-permutations-ii"><a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a></h4>
<p>题目描述：给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<pre><code>示例：
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>
<p>分析：枚举每个数放在哪个位置上去，搜索的时候不能重复。</p>
<ul>
<li>先将所有相同数放在一起：排序</li>
<li>人为规定相同数字的相对顺序：不变<br>
dfs(u, start)</li>
<li>u表示枚举到了哪个数字。</li>
<li>start表示当前可以从哪个位置开始搜，比如把第一个1放在了第五个位置上，那么第二个1就必须从第六个位置开始搜。枚举新的数字时，start = 0，枚举相同的数字时，start 从下一位开始。<br>
C++</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    
    int n;
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    vector&lt;bool&gt; st;
    
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        n = nums.size();
        st = vector&lt;bool&gt; (n);
        path = vector&lt;int&gt; (n);
        
        sort(nums.begin(), nums.end());
        dfs(nums, 0, 0);
        return ans;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int u, int start){
        if (u == n)
        {
            ans.push_back(path);
            return;
        }
        
        for (int i = start; i &lt; n; i++)
            if (!st[i])
            {
                st[i] = true;
                path[i] = nums[u];
                dfs(nums, u + 1, u + 1 &lt; n &amp;&amp; nums[u + 1] == nums[u] ? i + 1 : 0);
                st[i] = false;
            }
    }
};
</code></pre>
<h4 id="78-subsets"><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></h4>
<p>题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>
Note：</p>
<ul>
<li>解集不能包含重复的子集。</li>
<li>空集是一个特殊的子集。</li>
</ul>
<pre><code>示例:
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre>
<p>分析：可以用二进制表示所有的可能性，比如上面有三位数字，那么共有的可能性就有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 中可能性，二进制表示的可能性如下：</p>
<pre><code>000   -&gt;   []
001   -&gt;   [1]
010   -&gt;   [2]
011   -&gt;   [1, 2]
100   -&gt;   [3]
101   -&gt;   [1, 3]
110   -&gt;   [1, 2]
111   -&gt;   [1, 2, 3]
</code></pre>
<p>所以通过枚举所有的二进制表示，然后如果位上是1，那么就把该位表示的数字放进来。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        for (int i = 0; i &lt; 1 &lt;&lt; nums.size(); i ++)
        {
            vector&lt;int&gt; now;
            for (int j = 0; j &lt; nums.size(); j ++)
                if (i &gt;&gt; j &amp; 1)
                    now.push_back(nums[j]);
            res.push_back(now);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res = []
        for i in range(1 &lt;&lt; len(nums)):
            now = []
            for j in range(len(nums)):
                if i &gt;&gt; j &amp; 1:
                    now.append(nums[j])
            res.append(now)
        return res
</code></pre>
<h4 id="90-subsets-ii"><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h4>
<p>题目描述：给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>
Note：</p>
<ul>
<li>解集不能包含重复的子集。</li>
</ul>
<pre><code>示例:
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre>
<p>分析：先统计每个数字出现的次数，次数之积就是所有可能的方案。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        dfs(nums, 0);
        return ans;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int u){
        if (u == nums.size())
        {
            ans.push_back(path);
            return;
        }
        
        // 计算当前数字的个数
        int k = 0;
        while (u + k &lt; nums.size() &amp;&amp; nums[u+k] == nums[u]) k++;
        for (int i = 0; i &lt;= k; i ++)
        {
            dfs(nums, u + k);
            path.push_back(nums[u]);
        }
        
        // 恢复现场
        for (int i = 0; i &lt;= k; i++) path.pop_back();
    }
};
</code></pre>
<p>Python(存疑)</p>
<h4 id="216-combination-sum-iii"><a href="https://leetcode.com/problems/combination-sum-iii/">216. Combination Sum III</a></h4>
<p>题目描述：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。<br>
Note：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<pre><code>示例 :
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
</code></pre>
<p>分析：</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {
        dfs(k, 1, n);
        return ans;
    } 
    
    void dfs(int k, int start, int n){
        if (!k)
        {
            if (!n) ans.push_back(path);
            return;
        }
        
        for (int i = start; i &lt;= 9; i ++)
        {
            path.push_back(i);
            dfs(k - 1, i + 1, n - i);
            path.pop_back();
        }
    }
};
</code></pre>
<h4 id="52-n-queens-ii"><a href="https://leetcode.com/problems/n-queens-ii/">52. N-Queens II</a></h4>
<p>题目描述：n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击(任意两个皇后都不能处于同一行、同一列或同一斜线上)。</p>
<pre><code>示例:

输入: 4
输出: 2
解释: 4 皇后问题存在如下两个不同的解法。
[
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
</code></pre>
<p>分析：由于攻击的关系，所以每行每列只能摆一个皇后。依次枚举每一行皇后的位置，需要满足以下条件：</p>
<ul>
<li>每一列只能有一个皇后- &gt;设置数组col[n]表示是否有皇后</li>
<li>每一条斜线上只能有一个皇后 - &gt; 由于有两个方向的斜线，所以用d[2n-1]和ud[2n-1]表示。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int ans = 0, n;
    vector&lt;bool&gt; col, d, ud;
    
    int totalNQueens(int _n) {
        n = _n;
        col = vector&lt;bool&gt; (n);
        d = ud = vector&lt;bool&gt; (n * 2);
        
        dfs(0);
        return ans;
    }
    
    void dfs(int u)
    {
        if (u == n)
        {
            ans ++;
            return;
        }
        for (int i = 0; i &lt; n; i++)
            if (!col[i] &amp;&amp; !d[u + i] &amp;&amp; !ud[u - i + n])
            {
                col[i] = d[u + i] = ud[u - i + n] = true;
                dfs(u + 1);
                col[i] = d[u + i] = ud[u - i + n] = false;
            }
    }
};
</code></pre>
<h4 id="37-sudoku-solver"><a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a></h4>
<p>题目描述：编写一个程序，通过已填充的空格来解决数独问题。<br>
一个数独的解法需遵循如下规则：<br>
数字 1-9 在每一行只能出现一次。<br>
数字 1-9 在每一列只能出现一次。<br>
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>
空白格用 '.' 表示。<br>
Note:</p>
<ul>
<li>给定的数独序列只包含数字 1-9 和字符 '.' 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 9x9 形式的。<br>
分析：搜索顺序：从前往后枚举每个空格该填哪个数。需要维护每一行、每一列以及每个九宫格的状态，因为每行、每列、每个九宫格中的数字不能重复，所以设定<code>row[9][9]（一共九行，每行九个数字）、col[9][9]、cell[3][3][9]（3 × 3的格子，每个格子有九个数字）</code>来表示状态。<br>
Ps. 八皇后、数独都是精确覆盖问题，可以用Dancing Links来解决。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    
    bool row[9][9] = {0}, col[9][9] = {0}, cell[3][3][9] = {0};
    
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        for (int i = 0; i &lt; 9; i++)
            for (int j = 0; j &lt; 9; j++)
            {
                char c = board[i][j];
                if (c != '.')
                {
                    int t = c - '1';
                    row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true;
                }
            }
        dfs(board, 0, 0);
    }
    
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y)
    {
        if (y == 9)  x++, y = 0;
        if (x == 9) return true;
        if (board[x][y] != '.') return dfs(board, x, y + 1);
        
        for (int i = 0; i &lt; 9; i ++)
            if (!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / 3][y / 3][i])
            {
                board[x][y] = '1' + i;
                row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true;
                if (dfs(board, x, y + 1)) return true;            
                row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false;
                board[x][y] = '.';
            }
        return false;
    }
};
</code></pre>
<h4 id="473-matchsticks-to-square"><a href="https://leetcode.com/problems/matchsticks-to-square/">473. Matchsticks to Square</a></h4>
<p>题目描述：还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。<br>
输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。</p>
<pre><code>示例 :
输入: [1,1,2,2,2]
输出: true
解释: 能拼成一个边长为2的正方形，每边两根火柴。
</code></pre>
<p>Note:</p>
<ul>
<li>给定的火柴长度和在 0 到 10^9之间。</li>
<li>火柴数组的长度不超过15。</li>
</ul>
<p>分析：一次构造正方形的每条边。</p>
<ol>
<li>从大到小枚举所有边</li>
<li>每条边内部的木棒长度规定从大到小</li>
<li>如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒</li>
<li>如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支</li>
<li>如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉分支<br>
C++</li>
</ol>
<pre><code class="language-c++">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第四周(字符串处理专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第四周(字符串处理专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第四周(字符串处理专题)">
        </link>
        <updated>2019-08-26T08:01:46.000Z</updated>
        <content type="html"><![CDATA[<h4 id="38-count-and-say"><a href="https://leetcode.com/problems/count-and-say/">38. Count and Say</a></h4>
<p>题目描述：报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
</code></pre>
<p>1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。<br>
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。<br>
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。<br>
给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。<br>
注意：整数顺序将表示为一个字符串。</p>
<p>分析：每一行生成的内容都是根据上一行的内容得来的，每次需要得到连续段的个数以及数值，转成字符串即可。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    string countAndSay(int n) {
        string s = &quot;1&quot;;
        for (int i = 0; i &lt; n -1; i++)
        {
            string ns;
            for (int j = 0; j &lt; s.size(); j++)
            {
                int k = j + 1;
                while (k &lt; s.size() &amp;&amp; s[k] == s[j]) k++;
                ns += to_string(k - j) + s[j];
                j = k - 1;
            }
            s = ns;
        }
        return s;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def countAndSay(self, n: int) -&gt; str:
        s = '1'
        for i in range(n-1):
            ns = &quot;&quot;
            j = 0
            while j &lt; len(s):
                k = j + 1
                while (k &lt; len(s) and s[j] == s[k]):
                    k += 1
                ns += str(k - j) + s[j]
                j = k - 1
                j += 1
            s = ns
        return s
</code></pre>
<h4 id="49-group-anagrams"><a href="https://leetcode.com/problems/group-anagrams/">49. Group Anagrams</a></h4>
<p>题目描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<pre><code>示例：
输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre>
<p>Note:</p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。<br>
分析：先把每个字符串排个序，构建一个字典，每个字符串是value，排好序的是key，这样就可以把相同的放在一起。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;
        for (auto str: strs)
        {
            string key = str;
            sort(key.begin(), key.end());
            hash[key].push_back(str);
        }
        
        vector&lt;vector&lt;string&gt;&gt; res;
        for (auto item : hash) res.push_back(item.second);
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        dicts = {}
        for sts in strs:
            key = tuple(sorted(sts))
            dicts[key] = dicts.get(key, []) + [sts]
        return list(dicts.values())
</code></pre>
<h4 id="151-reverse-words-in-a-string"><a href="https://leetcode.com/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a>(存疑)</h4>
<p>题目描述：<br>
给定一个字符串，逐个翻转字符串中的每个单词。</p>
<pre><code>示例：
输入: &quot;  hello world!  &quot;
输出: &quot;world! hello&quot;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
</code></pre>
<p>Note：</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p>分析：用python写的话可以用<code>split</code>和<code>strip</code>来处理掉无关的空格，然后再用<code>join</code>连接即可。<br>
也可以分两步来做：</p>
<ol>
<li>先把每个单词翻转</li>
<li>翻转整个字符串<br>
<img src="https://tudouvvv.github.io//post-images/1566872102761.png" alt=""><br>
然后再找到连续的不包含空格的一段。<br>
C++</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    string reverseWords(string s) {
       int k = 0;
        for (int i = 0; i &lt; s.size();)
        {
            while(i &lt; s.size() &amp;&amp; s[i] == ' ') i++;
            if (i == s.size()) break;
            int j = i;
            while(j &lt; s.size() &amp;&amp; s[j] != ' ') j++;
            reverse(s.begin()+i, s.begin()+j);
            if (k) s[k ++] = ' ';
            while(i &lt; j) s[k ++ ] = s[i ++];
        }
        s.erase(s.begin() + k, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def reverseWords(self, s: str) -&gt; str:
        sts = s.strip().split(' ')[::-1]
        while '' in sts:
            sts.remove('')
        return &quot; &quot;.join(sts)
</code></pre>
<h4 id="165-compare-version-numbers"><a href="https://leetcode.com/problems/compare-version-numbers/">165. Compare Version Numbers</a></h4>
<p>题目描述：比较两个版本号 version1 和 version2。<br>
如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。<br>
你可以假设版本字符串非空，并且只包含数字和 . 字符。<br>
 . 字符不代表小数点，而是用于分隔数字序列。</p>
<pre><code>示例：
输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;
输出: -1
</code></pre>
<p>分析:<br>
每次比较每位的数字是否一样。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
   int compareVersion(string v1, string v2) {
       int i = 0, j = 0;
       while (i &lt; v1.size() || j &lt; v2.size())
       {
           int x = i, y = j;
           while (x &lt; v1.size() &amp;&amp; v1[x] != '.') x++;
           while (y &lt; v2.size() &amp;&amp; v2[y] != '.') y++;
           int a = i == x ? 0 : atoi(v1.substr(i, x-i).c_str());
           int b = j == y ? 0 : atoi(v2.substr(j, y-j).c_str());
           if (a &gt; b) return 1;
           if (a &lt; b) return -1;
           i = x + 1, j = y + 1;
       }
       return 0;
   }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
   def compareVersion(self, v1: str, v2: str) -&gt; int:
       i, j = 0, 0
       while (i &lt; len(v1) or j &lt; len(v2)):
           x = i
           y = j
           while (x &lt; len(v1) and v1[x] != '.'):
               x += 1
           while (y &lt; len(v2) and v2[y] != '.'):
               y += 1
           a = 0 if i == x else int(v1[i:x])
           b = 0 if y == j else int(v2[j:y])
           
           if a &gt; b: return 1
           if a &lt; b: return -1
           i = x + 1
           j = y + 1
       return 0
</code></pre>
<h4 id="929-unique-email-addresses"><a href="https://leetcode.com/problems/unique-email-addresses/">929. Unique Email Addresses</a></h4>
<p>题目描述：如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，&quot;alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。）<br>
如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。）<br>
可以同时使用这两个规则。</p>
<pre><code>示例：
Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]
Output: 2
Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails
</code></pre>
<p>Note:</p>
<ul>
<li>1 &lt;= emails[i].length &lt;= 100</li>
<li>1 &lt;= emails.length &lt;= 100</li>
<li>每封 emails[i] 都包含有且仅有一个 '@' 字符。</li>
<li>所有本地和域名都是非空的。</li>
<li>本地名称不以“+”字符开头。<br>
分析：拿到一个地址后，分成两部分：用户名和域名。对用户名进行过滤，.进行忽略，+后面忽略，然后在拼成一个新的email。然后再判断有多少个不同的即可。</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int numUniqueEmails(vector&lt;string&gt;&amp; emails) {
        unordered_set&lt;string&gt; hash;
        for (auto email : emails)
        {
            int at = email.find('@');
            string name;
            for (auto c : email.substr(0, at))
            {
                if (c == '+') break;
                if (c != '.') name += c;
            }
            string domain = email.substr(at + 1);
            hash.insert(name + '@' + domain);
        }
        return hash.size();
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def numUniqueEmails(self, emails: List[str]) -&gt; int:
        email_set = set()
        for email in emails:
            name = &quot;&quot;
            at = email.index('@')
            for c in email[0:at]:
                if c == '+': break
                if c != '.': name += c
            domain = email[at+1:]
            email_set.add(name + '@' + domain)
        return len(email_set)
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def numUniqueEmails(self, emails: List[str]) -&gt; int:
        email_set = set()
        for email in emails:
            name, domain = email.split(&quot;@&quot;)
            if('+' in name):
                plus_pos = name.index('+')
                name = name[ : plus_pos]
            email_set.add(name.replace('.','')+'@'+ domain)
        return len(email_set)
</code></pre>
<h4 id="5-longest-palindromic-substring"><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></h4>
<p>题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<pre><code>示例：
输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
</code></pre>
<p>分析：要分奇偶两种情况，奇数就是中间的字母，偶数就是中间两个字母。然后进行暴力枚举，判断每个中心点的情况，一定会得到答案。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        for (int i = 0; i &lt; s.size(); i ++)
        {
            // 奇数情况
            for (int j = i, k = i; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++)
                if (res.size() &lt; (k - j + 1))
                    res = s.substr(j, k - j + 1);
            // 偶数情况
            for (int j = i, k = i + 1; j &gt;= 0 &amp;&amp; k &lt; s.size() &amp;&amp; s[j] == s[k]; j--, k++)
                if (res.size() &lt; (k - j + 1))
                    res = s.substr(j, k - j + 1);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        i = 0
        res = &quot;&quot;
        while i &lt; len(s):
            j, k = i, i
            while (j &gt;=0 and k &lt; len(s) and s[j] == s[k]):
                if len(res) &lt; k - j + 1:
                    res = s[j:k + 1]
                j -= 1
                k += 1
            p, q = i, i+1
            while (p &gt;= 0 and q &lt; len(s) and s[p] == s[q]):
                if len(res) &lt; q - p + 1:
                    res = s[p:q + 1]
                p -= 1
                q += 1
            i += 1
        return res
</code></pre>
<h4 id="6-zigzag-conversion"><a href="https://leetcode.com/problems/zigzag-conversion/">6. ZigZag Conversion</a></h4>
<p>题目描述：将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<pre><code>示例：
输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4
输出: &quot;LDREOEIIECIHNTSG&quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
</code></pre>
<p>分析：<img src="https://tudouvvv.github.io//post-images/1566895652783.png" alt=""><br>
以n=5为例，可以看出，第一行和最后一行是等差数列，首项分别是0和n-1，中间几行是两个交错的等差数列，公差是2(n-1)。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    string convert(string s, int n) {
        if (n == 1) return s;
        string res;
        for (int i = 0; i &lt; n; i++)
        {
            if (!i || i == n - 1)
            {
                for (int j = i; j &lt; s.size(); j += 2 * (n-1))  res += s[j];
            }
            else
            {
                for (int j = i, k = 2 * (n - 1) - i; j &lt; s.size() || k &lt; s.size(); j += 2*(n-1), k += 2*(n-1))
                {
                    if (j &lt; s.size()) res += s[j];
                    if (k &lt; s.size()) res += s[k];
                }
            }
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def convert(self, s: str, n: int) -&gt; str:
        if n == 1: return s
        res = &quot;&quot;
        i = 0
        while i &lt; n:
            if (not i) or (i == n - 1):
                j = i
                while j &lt; len(s):
                    res += s[j]
                    j += 2*(n-1)
            else:
                p = i
                q = 2 * (n - 1) - i
                while p &lt; len(s) or q &lt; len(s):
                    if p &lt; len(s): res += s[p]
                    if q &lt; len(s): res += s[q]
                    p += 2 * (n-1)
                    q += 2 * (n-1)
            i += 1
        return res
</code></pre>
<h4 id="3-longest-substring-without-repeating-characters"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></h4>
<p>题目描述：给定一个字符串，请你找出其中不含有重复字符的<code>最长子串</code>的长度。<br>
【这道题的要求是 ！！！找到字符串中最长的子串而不是子序列<br>
子串即原序列中连在一起的字符串，而子序列是原序列中所有字母的集合】</p>
<pre><code>示例:
输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre>
<p>分析：双指针算法，一个指针向前走，一个指针待命，如果前一个指针遇见了重复的字符，那么另一个指针向前走一格，构建一个哈希表表示每个字符出现的次数。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map&lt;char, int&gt; hash;
        int res = 0;
        for (int i = 0, j = 0; i &lt; s.size(); i++)
        {
            hash[s[i]] ++;
            while (hash[s[i]] &gt; 1) hash[s[j++]] -- ;
            res = max(res, i - j + 1);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        res = 0
        dicts = {}
        new_s = set(s[::])
        for char in new_s:
            dicts[char] = 0
        i, j = 0, 0
        while i &lt; len(s):
            dicts[s[i]] += 1
            while dicts[s[i]] &gt; 1:
                dicts[s[j]] -= 1
                j += 1
            res = max(i - j + 1, res)
            i += 1
        return res
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s):
        start = maxLength = 0
        usedChar = {}
        for i in range(len(s)):
            if s[i] in usedChar and start &lt;= usedChar[s[i]]:
                start = usedChar[s[i]] + 1
            else:
                maxLength = max(maxLength, i - start + 1)
            usedChar[s[i]] = i
        return maxLength
</code></pre>
<h4 id="208-implement-trie-prefix-tree"><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)</a>（存疑）</h4>
<p>题目描述：实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<pre><code>示例:
Trie trie = new Trie();

trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // 返回 true
trie.search(&quot;app&quot;);     // 返回 false
trie.startsWith(&quot;app&quot;); // 返回 true
trie.insert(&quot;app&quot;);   
trie.search(&quot;app&quot;);     // 返回 true
</code></pre>
<p>Note：</p>
<ul>
<li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li>
<li>保证所有输入均为非空字符串。<br>
分析：Trie树是一个字典树，根节点为空，其它任何一个节点包含一个字母，当一个单词完成时，打一个标记。</li>
</ul>
<h4 id="273-integer-to-english-words"><a href="https://leetcode.com/problems/integer-to-english-words/">273. Integer to English Words</a></h4>
<p>题目描述：将非负整数转换为其对应的英文表示。可以保证给定输入小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1。</p>
<pre><code>示例：
输入: 1234567891
输出: &quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot;
</code></pre>
<p><img src="https://tudouvvv.github.io//post-images/1566914676505.png" alt=""><br>
分析：把整个流程分块儿，可以看出三位数是一块儿，构建这样一个函数得到三位数的表示方式，然后填入单位即可。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    string small[20] = {&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;,  &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;};
    string decade[10] = {&quot;&quot;, &quot;&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;};
    string big[4] = {&quot;Billion&quot;, &quot;Million&quot;, &quot;Thousand&quot;, &quot;&quot;};
    
    string numberToWords(int num) {
        if (!num) return small[0];
        
        string res;
        for (int i = 1000000000, j = 0; i &gt; 0; i /= 1000, j++)
            if (num &gt;= i)
            {
                res += get_part(num / i) + big[j] + ' ';
                num %= i;
            }
        while (res.back() == ' ') res.pop_back();
        return res;
    }
    
    string get_part(int num)
    {
        string res;
        if (num &gt;= 100)
        {
            res += small[num / 100] + &quot; Hundred &quot;;
            num %= 100;
        }
        if (!num) return res;
        if (num &gt;= 20)
        {
            res += decade[num / 10] + ' ';
            num %= 10;
        }
        if (!num) return res;
        res += small[num] + ' ';
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def numberToWords(self, num: int) -&gt; str:
        small = [&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, 
			&quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;,
			&quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;,
			&quot;Sixteen&quot;, &quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;]
        decade = [&quot;&quot;, &quot;&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;,
		 &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;]
        big = [&quot;Billion&quot;, &quot;Million&quot;, &quot;Thousand&quot;, &quot;&quot;]
        
        if not num: return small[0]
        res = &quot;&quot;
        i = 1000000000
        j = 0
        while i &gt; 0:
            if num &gt;= i:
                res += self.get_part(int(num // i), small, decade) + big[j] + ' '
                num %= i
            i /= 1000
            j +=1
        return res.strip()
        
    def get_part(self, num, small, decade):
        res = &quot;&quot;
        if num &gt;= 100:
            res += small[int(num // 100)] + &quot; Hundred &quot;
            num %= 100
        if not num: return res
        if num &gt;= 20:
            res += decade[int(num // 10)] + ' '
            num %= 10
        if not num: return res
        res += small[num] + ' '
        return res
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第三周(树专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第三周(树专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第三周(树专题)">
        </link>
        <updated>2019-07-30T03:56:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="98-validate-binary-search-tree"><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h4>
<p>题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树（BST）。<br>
假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<pre><code>示例：
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
根节点的值为 5 ，但是其右子节点值为 4 。
</code></pre>
<p>分析：<br>
<img src="https://tudouvvv.github.io//post-images/1564546182987.png" alt=""><br>
用递归的思想，自上往下的进行搜索判断。首先，假定根节点的值是x，它的范围是在[-∞,+∞]之间的，那么它的左子树的范围就是[-∞,x-1]之间的，假定左子树根节点的值为y，那么对它来说，它的左子树的范围是[-∞,y-1]，右子树的范围是在[y+1,x-1]。以此类推，不断判断，如果哪一个结点的值不在它所属的范围内，那么它就不是一颗BST。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
       return dfs(root, INT_MIN, INT_MAX);
    }
    
    bool dfs(TreeNode *root, long long minv, long long maxv)
    {
        if (!root) return true;
        if (root-&gt;val &lt; minv || root-&gt;val &gt; maxv)  return false;
        # 1ll的目的是为了防止溢出，因为val有可能是负无穷或正无穷
        return dfs(root-&gt;left, minv, root-&gt;val -1ll) &amp;&amp; dfs(root-&gt;right, root-&gt;val +1ll, maxv);
    }
};
</code></pre>
<p>Python</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        return self.dfs(root, -float('inf'), float('inf'))
    
    def dfs(self, root, minv, maxv):
        if not root:
            return True
        if root.val &lt; minv or root.val &gt; maxv:
            return False
        return self.dfs(root.left, minv, root.val-1) and self.dfs(root.right, root.val+1, maxv)
</code></pre>
<h4 id="94-binary-tree-inorder-traversal"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a></h4>
<p>题目描述：给定一个二叉树，返回它的中序遍历。</p>
<pre><code>示例：
输入: [1,null,2,3]
   1
    \
     2
    /
   3
输出: [1,3,2]
</code></pre>
<p>Note:</p>
<ul>
<li>进阶: 递归算法很简单，你可以通过迭代算法完成吗？<br>
分析：<br>
可以用栈来实现中序遍历，将整棵树的最左边一条链压入栈中，每次取出栈顶元素，如果它有右子树，则将右子树压入栈中。<br>
C++</li>
</ul>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; stk;
        auto p = root;
        while (p || stk.size())
        {
            while(p)
            {
                stk.push(p);
                p = p-&gt;left;
            }
            p = stk.top();
            stk.pop();
            res.push_back(p-&gt;val);
            p = p-&gt;right;
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res = []
        stk = []
        p = root
        while(p or len(stk)):
            while p:
                stk.append(p)
                p = p.left
            p = stk.pop()
            res.append(p.val)
            p = p.right
        return res
</code></pre>
<h4 id="101-symmetric-tree"><a href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a></h4>
<p>题目描述：给定一个二叉树，检查它是否是镜像对称的。</p>
<pre><code>示例：
    1
   / \
  2   2
 / \ / \
3  4 4  3
二叉树 [1,2,2,3,4,4,3] 是对称的。
</code></pre>
<p>Note:</p>
<ul>
<li>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。<br>
分析：</li>
<li>递归的方式</li>
</ul>
<ol>
<li>两个根节点的值要相等</li>
<li>左边的左子树与右边的右子树对称</li>
<li>左边的右子树与右边的左子树对称</li>
</ol>
<ul>
<li>迭代的方式</li>
</ul>
<ol>
<li>左边的树：左中右遍历</li>
<li>右边的树：右中左遍历</li>
<li>同时遍历，判断两边的值是否一样<br>
C++(递归的方式)</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return dfs(root-&gt;left, root-&gt;right);        
    }
    bool dfs(TreeNode* p, TreeNode* q){
        // 如果是空的，则必须同时为空才对称
        if (!p || !q) return !p &amp;&amp; !q;
        return p-&gt;val == q-&gt;val &amp;&amp; dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root: return True
        return self.dfs(root.left, root.right)
    def dfs(self, p, q):
        if (not p) or (not q): return (not p) and (not q)
        return p.val == q.val and self.dfs(p.left, q.right) and self.dfs(p.right, q.left)
</code></pre>
<p>C++(迭代的方式)</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        stack&lt;TreeNode*&gt; left, right;
        auto l = root-&gt;left, r = root-&gt;right;
        while (l || r || left.size() || right.size())
        {
            while (l &amp;&amp; r)
            {
                left.push(l), l = l-&gt;left;
                right.push(r), r = r-&gt;right;
            }
            if (l || r) return false;
            
            l = left.top(), left.pop();
            r = right.top(), right.pop();
            if (l-&gt;val != r-&gt;val) return false;
            l = l-&gt;right, r = r-&gt;left;
        }
        return true;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root: return True
        left, right = [], []
        l, r = root.left, root.right
        while (l or r or len(left) or len(right)):
            while (l and r):
                left.append(l)
                l = l.left
                right.append(r)
                r = r.right
            # 上面循环结束只有两种情况:全空或者一个空，一个不空
            # 一个空，一个不空肯定不对称，返回False
            if (l or r): return False
            l = left.pop()
            r = right.pop()
            if l.val != r.val: return False
            l = l.right
            r = r.left
        return True
</code></pre>
<h4 id="105-construct-binary-tree-from-preorder-and-inorder-traversal"><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h4>
<p>题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。<br>
Node:</p>
<ul>
<li>你可以假设树中没有重复的元素。</li>
</ul>
<pre><code>示例：
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>分析：</p>
<ol>
<li>前序遍历的第一个点肯定是根节点，在中序遍历中找到这个数，那么它左边的数就是左子树，右边的数就是右子树；</li>
<li>知道左子树的个数后，在前序遍历中就可以把左子树的前序遍历和右子树的前序遍历区分开来；</li>
<li>然后不断递归即可；</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map&lt;int, int&gt; pos;
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        int n = preorder.size();
        for (int i =0; i &lt; n; i++) pos[inorder[i]] = i;
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);
    }
    
    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir){
        if (pl &gt; pr) return NULL;
        int val = preorder[pl];
        int k = pos[val];
        int len = k - il;
        auto root = new TreeNode(val);
        root-&gt;left = dfs(preorder, inorder, pl+1, pl+len, il, k-1);
        root-&gt;right = dfs(preorder, inorder, pl+len+1, pr, k+1, ir);
        
        return root;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        pos = {}
        n = len(preorder)
        for i, char in enumerate(inorder):
            pos[char] = i
        return self.dfs(pos, preorder, inorder, 0, n-1, 0, n-1)
    
    def dfs(self, pos, preorder, inorder, pl, pr, il, ir):
        if pl &gt; pr: return None
        val = preorder[pl]
        k = pos[val]
        length = k - il
        root = TreeNode(val)
        root.left = self.dfs(pos, preorder, inorder, pl+1, pl+length, il, k-1)
        root.right = self.dfs(pos, preorder, inorder, pl+length+1, pr, k+1, ir)
        return root
</code></pre>
<p>✅update：可以使用pop因为前序遍历中的数字一定是某个子树的根节点，它在中序遍历中左边的数都是左子树，右边的数都是右子树，然后可以根据这个使用pop(python中可以想pop谁就pop谁)每次pop第一个数，然后找到它在中序遍历中的index，继续迭代即可。</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder or not inorder: return None
        root = TreeNode(preorder.pop(0))
        index = inorder.index(root.val)
        root.left = self.buildTree(preorder, inorder[:index])
        root.right = self.buildTree(preorder, inorder[index+1:])
        return root
</code></pre>
<h4 id="102-binary-tree-level-order-traversal"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h4>
<p>题目描述：给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<pre><code>示例:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
</code></pre>
<p>分析：一层一层地进行，设置一个队列，每次存储这层元素，最后再把每层的元素存储到一个二维数组中即可。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!root) return res;
        
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        
        while(q.size())
        {
            int len = q.size();
            vector&lt;int&gt; level;
            
            for(int i = 0; i &lt; len; i++)
            {
                auto t = q.front();
                q.pop();
                level.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.push_back(level);
        }
        return res;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        res = []
        q = []
        if not root: return res
        q.append(root)
        
        while(len(q)):
            length = len(q)
            level = []
            for i in range(length):
                t = q[0]
                del(q[0])
                level.append(t.val)
                if t.left: 
                    q.append(t.left)
                if t.right: 
                    q.append(t.right)
            res.append(level)
        return res
</code></pre>
<h4 id="236-lowest-common-ancestor-of-a-binary-tree"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h4>
<p>题目描述:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
Note:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<pre><code>示例：
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
</code></pre>
<p>分析：</p>
<ul>
<li>如果以root为根的子树中包含p和q，则返回它们的公共祖先</li>
<li>如果只包含p/q，那么只返回p/q</li>
<li>如果都不包含，则返回NULL</li>
</ul>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;
        auto left = lowestCommonAncestor(root-&gt;left, p, q);
        auto right = lowestCommonAncestor(root-&gt;right, p, q);
        if (!left) return right;
        if (!right) return left;
        return root;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        if root == None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left: return right
        if not right: return left
        return root
</code></pre>
<h4 id="543-diameter-of-binary-tree"><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h4>
<p>题目描述：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p>
<pre><code>示例
给定二叉树
          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
</code></pre>
<p>Note</p>
<ul>
<li>两结点之间的路径长度是以它们之间边的数目表示。<br>
分析：递归时需要计算，从当前结点出发，求左右两边深度的最大值。<br>
C++</li>
</ul>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return ans;
    }
    int dfs(TreeNode* root){
        if (!root) return 0;
        auto left = dfs(root-&gt;left);
        auto right = dfs(root-&gt;right);
        ans = max(ans, left+right);
        return max(left+1, right+1);
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:
        self.ans = 0
        def dfs(root):
            if not root: return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.ans = max(self.ans, left+right)
            return max(left+1, right+1)
        dfs(root)
        return self.ans
</code></pre>
<h4 id="124-binary-tree-maximum-path-sum"><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></h4>
<p>题目描述：给定一个非空二叉树，返回其最大路径和。<br>
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<pre><code>示例
输入: [-10,9,20,null,null,15,7]
   -10
   / \
  9  20
    /  \
   15   7
输出: 42
</code></pre>
<p>分析：与上道题不同返回最长的边数不同，这道题有了权重，但与上题类似，先枚举最高点。<br>
每个点有三种情况：</p>
<ol>
<li>向左走，root.val+L</li>
<li>向右走，root.val+R</li>
<li>不走，root.val+0<br>
每次在这三种情况中取最大值。<br>
C++</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans;
    }
    // 返回从root向下走的最大值
    int dfs(TreeNode* root){
        if (!root) return 0;
        auto left = dfs(root-&gt;left);
        auto right = dfs(root-&gt;right);
        
        ans = max(ans, left+right+root-&gt;val);
        return max(0, root-&gt;val + max(0, max(left, right)));
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -&gt; int:
        self.ans = -float('inf')
        def dfs(root):
            if not root: return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.ans = max(self.ans, left+right+root.val)
            return max(0, root.val+max(0, left, right))
        dfs(root)
        return self.ans
</code></pre>
<h4 id="173-binary-search-tree-iterator"><a href="https://leetcode.com/problems/binary-search-tree-iterator/">173. Binary Search Tree Iterator</a></h4>
<p>题目描述：实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。<br>
调用 next() 将返回二叉搜索树中的下一个最小的数。<br>
Note:</p>
<ul>
<li>next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。</li>
<li>以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。<br>
<img src="https://tudouvvv.github.io//post-images/1566803022501.png" alt=""></li>
</ul>
<pre><code>示例：
BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false
</code></pre>
<p>分析：按照中序遍历的方法输出树中的每一个节点，<code>next</code>返回下一个值，<code>hasNext</code>返回是否存在下一个值，可以用栈的方式来进行，栈的空间大小与树的大小成正比。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator {
public:
    stack&lt;TreeNode*&gt; stk;
    BSTIterator(TreeNode* root) {
        while(root)
        {
            stk.push(root);
            root = root-&gt;left;
        }
    }
    
    /** @return the next smallest number */
    int next() {
        auto p = stk.top();
        stk.pop();
        int res = p-&gt;val;
        p = p-&gt;right;
        while (p)
        {
            stk.push(p);
            p = p-&gt;left;
        }
        return res;
    }
    
    /** @return whether we have a next smallest number */
    bool hasNext() {
        return ! stk.empty();
    }
};

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj-&gt;next();
 * bool param_2 = obj-&gt;hasNext();
 */
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stk = []
        while root:
            self.stk.append(root)
            root = root.left

    def next(self) -&gt; int:
        &quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;
        p = self.stk.pop()
        res = p.val
        p = p.right
        while p:
            self.stk.append(p)
            p = p.left
        return res

    def hasNext(self) -&gt; bool:
        &quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;
        return len(self.stk) &gt; 0


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
</code></pre>
<h4 id="297-serialize-and-deserialize-binary-tree"><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize and Deserialize Binary Tree</a>(存疑)</h4>
<p>题目描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<pre><code>示例：
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 &quot;[1,2,3,null,null,4,5]&quot;
</code></pre>
<p>Note:</p>
<ul>
<li>这与 LeetCode 目前使用的方式一致，你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</li>
<li>不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</li>
</ul>
<p>分析：采用前序遍历的方式，因为加上了空节点，所以可以用前序遍历的方式来构建一棵唯一二叉树。一般情况下，前序遍历并不能唯一确定一棵二叉树；前序遍历+中序遍历可以唯一确定一棵二叉树。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string res;
        dfs1(root, res);
        return res;
    }
    
    void dfs1(TreeNode* root, string &amp;res)
    {
        if (!root)
        {
            res += &quot;#,&quot;;
            return;
        }
        res += to_string(root-&gt;val) + ',';
        dfs1(root-&gt;left, res);
        dfs1(root-&gt;right, res);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs2(data, u);
    }
    
    TreeNode* dfs2(string &amp;data, int &amp;u)
    {
        if (data[u] == '#'){
            u += 2;
            return NULL;
        }
        
        int t = 0;
        bool is_minus = false;
        if (data[u] == '-')
        {
            is_minus = true;
            u ++;
        }
        while (data[u] != ',')
        {
            t = t * 10 + data[u] - '0';
            u ++;
        }
        u ++;
        if (is_minus) t = -t;
        
        auto root = new TreeNode(t);
        root-&gt;left = dfs2(data, u);
        root-&gt;right = dfs2(data, u);
        
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第二周(链表专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第二周(链表专题)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第二周(链表专题)">
        </link>
        <updated>2019-07-24T07:23:43.000Z</updated>
        <content type="html"><![CDATA[<p>链表的题目可以通过画图来看！！！</p>
<h4 id="19-remove-nth-node-from-end-of-list"><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></h4>
<p>题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>
你能尝试使用一趟扫描实现吗？</p>
<pre><code>示例：
给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
</code></pre>
<p>分析：对于单链表而言，要删除一个结点，首先要找到这个结点的头结点， 比如说示例中的4号结点，我们首先要找到3号结点，然后让3号结点的next指针指向下一个结点的头部，这样就可以删掉4号结点。</p>
<p>由于有可能删除我们的头结点，所以我们一般会创建一个虚拟结点来指向头结点。</p>
<ol>
<li>建立一个虚拟头结点，来指向原始头结点</li>
<li>设定一个红指针，让它先向后走n步，然后在设定一个绿指针，两个指针同时向后移动，红指针到达最后一个结点时终止，此时绿指针就是倒数第n+1个结点。</li>
<li>让绿指针指向后面一个结点的头结点。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dumpy = new ListNode(-1);
        dumpy-&gt;next = head;
        
        auto first = dumpy, second =dumpy;
        while (n--) first = first -&gt; next;
        while (first-&gt;next)
        {
            first = first-&gt;next;
            second = second-&gt;next;
        }
        second-&gt;next = second-&gt;next-&gt;next;
        return dumpy -&gt;next;
    }
}; 
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dumpy = ListNode(-1)
        dumpy.next = head 
        first, second = dumpy, dumpy

        while first.next:
            if n:
                n -= 1
            else:
                second = second.next
            first = first.next
        second.next = second.next.next
        return dumpy.next
</code></pre>
<h4 id="237-delete-node-in-a-linked-list"><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">237. Delete Node in a Linked List</a></h4>
<p>题目描述：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<pre><code>示例：
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
</code></pre>
<p>说明:</p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<p>分析：因为上一道题说过，删除某个结点需要直到它上一个结点的地址，但是现在只给了该结点的地址，所以一个做法是把它下一个节点的值赋值给它，然后删除下一个结点，因为给的并不是最后一个结点，所以是可行的。<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val = node.next.val
        node.next = node.next.next
</code></pre>
<p>并且这道题我们其实是用node-&gt;next的结构来替换node的结构，所以也可以这样写：</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        *(node) = *(node-&gt;next);
    }
};
</code></pre>
<h4 id="83-remove-duplicates-from-sorted-list"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List</a></h4>
<p>题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<pre><code>示例：
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3
</code></pre>
<p>分析：从小到达排好序的链表，所以第一个结点是肯定不会被删掉的。我们从前到后进行枚举，每个结点有两种情况：1. 如果下一个点和当前点相同，删除下一个点；2. 如果下一个点和当前点不同，指针向后一位。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        auto cur = head;
        while (cur)
        {
            if (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val)
                cur-&gt;next = cur-&gt;next-&gt;next;
            else cur = cur-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        cur = head
        while cur:
            if cur.next and cur.next.val == cur.val:
                cur.next = cur.next.next
            else: cur = cur.next
        return head
</code></pre>
<h4 id="61-rotate-list"><a href="https://leetcode.com/problems/rotate-list/">61. Rotate List</a></h4>
<p>题目描述：给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<pre><code>示例：
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
</code></pre>
<p>分析：翻转就是把最后k个结点移到前面，由于k可能超过链表的长度，所以应该首先取模；<br>
<img src="https://tudouvvv.github.io//post-images/1563972831098.png" alt=""><br>
然后利用双指针，first指针首先从头往后走k步，然后second指针和first同时走，first走到结尾的时候停止，此时，first指向末尾，second指向倒数第k+1位；最后1. first-&gt;next=head； 2. head=second.next；3. second.next-&gt;null。<br>
ps. 头结点变得情况可以用虚拟头结点<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return NULL;
        int n = 0;
        for (auto p = head; p; p=p-&gt;next) n++;
        k %= n;
        auto first=head, second=head;
        while(k--) first = first-&gt;next;
        while(first-&gt;next)
        {
            first = first-&gt;next;
            second = second-&gt;next;
        }
        first-&gt;next = head;
        head =  second-&gt;next;
        second-&gt;next = NULL;
        return head;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:
        if not head: return None
        n = 1
        p = head
        while p.next:
            p = p.next
            n += 1
        k %= n
        first, second = head, head
        while k:
            first = first.next
            k -= 1
        while first.next:
            first = first.next 
            second = second.next
        first.next = head
        head = second.next
        second.next = None
        return head
</code></pre>
<h4 id="24-swap-nodes-in-pairs">⭐<a href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></h4>
<p>题目描述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<pre><code>示例：
Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.
</code></pre>
<p>分析：每次枚举一对儿结点，因为这道题头结点会发生变化，所以创建虚拟头结点p，然后分别创建a、b两个结点。<br>
<img src="https://tudouvvv.github.io//post-images/1564026372602.png" alt=""><br>
修改三个指针的指向位置即可：<br>
p-&gt;next = b；a-&gt;next = b-&gt;next；b-&gt;next = a；然后挪动p<br>
的位置，指向下一对儿结点的头部p= a。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        auto dummy = new ListNode(-1);
        dummy -&gt; next = head;
        
        for (auto p=dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;)
        {
            auto a = p-&gt;next, b = a-&gt;next;
            p-&gt;next = b;
            a-&gt;next = b-&gt;next;
            b-&gt;next = a;
            p = a;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        p = dummy
        while p.next and p.next.next:
            a = p.next
            b = a.next
            p.next = b
            a.next = b.next
            b.next = a
            p = a
        return dummy.next
</code></pre>
<h4 id="206-reverse-linked-list">⭐<a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></h4>
<p>题目描述：反转一个单链表。</p>
<pre><code>示例：
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>分析：翻转结点等价于把中间结点的指向位置翻转，具体做法就是：</p>
<ol>
<li>设定两个指针a、b分别指向1，2</li>
<li>c = b-&gt;next;</li>
<li>b-&gt;next=a;</li>
<li>a = b, b = c<br>
这样就完成了一次翻转，并且把两个指针移到到了下一个需要反转的位置。当b为空的时候，翻转结束；然后令head-&gt;next = NULL，head = a即可。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head) return NULL;
        auto a = head, b = a-&gt;next;
        while (b)
        {
            auto c = b -&gt; next;
            b-&gt;next = a;
            a=b, b=c;
        }
        head-&gt;next = NULL;
        head = a;
        
        return head;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        a = head
        b = a.next
        while b:
            c = b.next
            b.next = a
            a = b
            b = c
        head.next = None
        
        return a
</code></pre>
<h4 id="92-reverse-linked-list-ii">⭐<a href="https://leetcode.com/problems/reverse-linked-list-ii/">92. Reverse Linked List II</a></h4>
<p>题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<pre><code>示例：
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
</code></pre>
<p>分析：我们要翻转其中一段链表m-&gt;n，我们首先得知道m的位置b，它前一个点a以及n的位置c以及它后一个点d，然后因为这道题中头结点也有可能发生翻转，所以我们创建一个虚拟的头结点。<br>
具体做法：</p>
<ol>
<li>先建立一个虚拟头结点</li>
<li>求出a、b、c、d的位置，a是虚拟头结点走m-1步，依此类推...</li>
<li>然后复用上段代码，翻转b--c;</li>
<li>然后a.next = c，b.next=d。<br>
C++</li>
</ol>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (m==n) return head;
        auto dummy = new ListNode(-1);
        dummy -&gt; next = head;
        
        auto a=dummy, c=dummy;
        for (int i=0; i &lt; m- 1; i++) a = a-&gt;next;
        for (int i=0; i &lt; n; i ++) c = c-&gt;next;
        auto b = a-&gt;next, d = c-&gt;next;
        
        for (auto p = b, q = b-&gt;next; q != d;)
        {
            auto o = q-&gt;next;
            q-&gt;next = p;
            p = q;
            q = o;
        }
        
        a -&gt; next = c;
        b -&gt; next = d;
        
    return dummy-&gt;next;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:
        if m == n:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        
        a, c  = dummy, dummy
        while m-1 &gt; 0:
            a = a.next
            m -= 1
        while n &gt; 0:
            c = c.next
            n -= 1
        b = a.next
        d = c.next
        p, q = b, b.next
        while q != d:
            o = q.next
            q.next = p
            p, q = q, o
        a.next = c
        b.next = d
        return dummy.next
</code></pre>
<h4 id="160-intersection-of-two-linked-lists"><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></h4>
<p>题目描述：编写一个程序，找到两个单链表相交的起始节点。<br>
如下面的两个链表：<br>
<img src="https://tudouvvv.github.io//post-images/1564042210816.png" alt="">在节点 c1 开始相交。<br>
注意：</p>
<ol>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>
分析：<img src="https://tudouvvv.github.io//post-images/1564042664892.png" alt=""><br>
设定两个指针，每次向后走一位，走到头后交换出发点，如果两个链表相交，那么它们在走过a+b+c后就一定会相遇，如果最后为空，那么它们就没有相交。</li>
</ol>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        auto p = headA, q = headB;
        while (p!=q)
        {
            if (p) p = p-&gt;next;
            else p = headB;
            if (q) q = q-&gt;next;
            else q = headA;
        }
        return p;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        &quot;&quot;&quot;
        :type head1, head1: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        p, q = headA, headB
        while p != q:
            if p != None:
                p = p.next
            else: p = headB
            if q != None:
                q = q.next
            else: q = headA
        return p
</code></pre>
<h4 id="142-linked-list-cycle-ii"><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></h4>
<p>题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<ul>
<li>不允许修改链表</li>
<li>能否只用O(1)的空间</li>
</ul>
<p><img src="https://tudouvvv.github.io//post-images/1564452405688.png" alt=""><br>
分析：设定两个指针，一个快指针fast（红色），一个慢指针slow（蓝色），fast指针每次走两步，slow指针每次走一步，当slow指针到b的时候，fast指针在左边c'处，离b的距离是y，由于快指针比慢指针快，所以二者会在c处相遇。相遇之后把慢指针重新放在头部，然后两个指针每次走一步，当两者相遇时一定在b点。因为第一次慢指针走到b时，走了x步，而快指针走了2x步，所以b--&gt;c'的距离是x步，整个圈的距离是x+y步，现在慢指针在开头，快指针在c处，两者每次走一步，当慢指针走x步时，快指针也走x步，就恰好相遇在b处。</p>
<p>C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        auto slow = head, fast = head;
        while (fast)
        {
            fast = fast-&gt;next;
            slow = slow-&gt;next;
            if (fast) fast = fast -&gt;next;
            // if (slow) slow = slow-&gt;next;
            else break;
            
            if  (fast == slow)
            {
                slow = head;
                while (slow != fast)
                {
                    slow = slow -&gt;next;
                    fast = fast -&gt;next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        slow, fast = head, head
        while fast:
            fast = fast.next
            slow = slow.next
            if fast: fast = fast.next
            else: break
            if slow == fast:
                slow = head
                while slow!= fast:
                    slow = slow.next
                    fast = fast.next
                return slow
        return None
</code></pre>
<h4 id="148-sort-list存疑">⭐<a href="https://leetcode.com/problems/sort-list/">148. Sort List</a>【存疑】</h4>
<p>题目描述：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<pre><code>示例：
Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
</code></pre>
<p>分析：快排和归并排序的空间复杂度不满足要求，<br>
C++</p>
<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        int n = 0;
        for (auto p=head; p; p=p-&gt;next)  n++;
        auto dummy = new ListNode(-1);
        dummy-&gt;next = head;
        for (int i = 1; i &lt; n; i *= 2)
        {
            auto cur = dummy;
            for (int j = 0; j + i &lt; n; j += i * 2)
            {
                auto left = cur-&gt;next, right = cur-&gt;next;
                for (int k = 0; k &lt; i; k ++) right = right-&gt;next;
                int l = 0, r = 0;
                while (l &lt; i &amp;&amp; r &lt; i &amp;&amp; right)
                    if (left-&gt;val &lt;= right-&gt;val)
                    {
                        cur-&gt;next = left;
                        cur = left;
                        left = left-&gt;next;
                        l ++;
                    }
                    else
                    {
                        cur-&gt;next = right;
                        cur = right;
                        right = right-&gt;next;
                        r ++;
                    }
                while (l &lt; i)
                {
                    cur-&gt;next = left;
                    cur = left;
                    left = left-&gt;next;
                    l ++;
                }
                while (r &lt; i &amp;&amp; right)
                {
                    cur-&gt;next = right;
                    cur = right;
                    right = right-&gt;next;
                    r ++;
                }
                
                cur-&gt;next = right; 
            }
        }
        
        return dummy-&gt;next;
        
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode暑期打卡第一周(二分专题)]]></title>
        <id>https://tudouvvv.github.io//post/LeetCode暑期打卡第一周(二分法)</id>
        <link href="https://tudouvvv.github.io//post/LeetCode暑期打卡第一周(二分法)">
        </link>
        <updated>2019-07-15T09:13:13.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p>二分的知识点就是每次把备选答案的空间缩小一半，但是整数二分一个很蛋疼的问题就是边界问题。</p>
<h3 id="二分思想">二分思想：</h3>
<p>答案是在一个区间之中，L-----R，通过中点的情况来判断答案的所处位置，然后删掉另外一边，缩小一半备选空间，然后再继续判断新的中点的情况，直到L==R找到答案。</p>
<p>70% 的二分题目都跟单调性有关(其余的题目虽然可以用二分但是不一定具有单调性)<br>
95% 的题目存在两段性的性质（左边一段成立，右边一段不成立），就可以找到一个边界点。</p>
<h3 id="时间复杂度logn">时间复杂度：logN</h3>
<h3 id="二分模板">二分模板</h3>
<h4 id="模板一">模板一：</h4>
<p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid]</code>和<code>[mid + 1, r]</code>时，其更新操作是<code>r = mid</code>或者<code>l = mid + 1</code>;，计算<code>mid</code>时不需要加1。</p>
<pre><code>int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;    // 向下取整
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
</code></pre>
<p>上面这个模板是用来求解最大值最小的问题</p>
<h4 id="模板二">模板二</h4>
<p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid - 1]</code>和<code>[mid, r]</code>时，其更新操作是<code>r = mid - 1</code>或者<code>l = mid</code>;，此时为了防止死循环，计算<code>mid</code>时需要加1。</p>
<pre><code>int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;    // 向上取整
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<p>这个模板是用来求解最小值最大的问题</p>
<h3 id="二分的流程">二分的流程：</h3>
<ol>
<li>先考虑二分的区间;</li>
<li>编写二分的代码框架;</li>
<li>设计一个check（性质）;</li>
<li>判断一下区间如何更新;</li>
<li>如果更新方式写的是l = mid，r = mid - 1，那么就在算mid的时候加上1</li>
</ol>
<h3 id="习题练习">习题练习</h3>
<h4 id="69-sqrtx"><a href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x)</a></h4>
<p>题目描述：计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>分析：首先二分的区间是[0, x]，然后确定一下判断的性质，我们想要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">mid^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>&lt;=x，那么就应该用第二个模板。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        int l=0, r=x;
        while (l &lt; r)
        {
            int mid = l + (long long)r + 1 &gt;&gt; 1;   // 防止mid溢出，所以用long long 型
            if (mid &lt;= x / mid)  l=mid;   //并且为了防止陷入死循环，需要+1向上取整
            else r = mid -1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def mySqrt(self, x: int) -&gt; int:
        l, r = 0, x
        while l&lt;r:
            mid = l + r + 1 &gt;&gt; 1
            if mid &lt;= (x / mid):
                l = mid
            else:
                r = mid -1
        return l
</code></pre>
<p>当然也可以选择另一个判断方式，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">mid^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>&gt;x，此时在[0, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><msqrt><mi>x</mi></msqrt><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left \lfloor\sqrt{x }\right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>]内是不满足的，在[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><msqrt><mi>x</mi></msqrt><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left \lfloor\sqrt{x }\right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⌊</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⌋</span></span></span></span></span>+1, x]内是满足的，所以最后返回l-1或者r-1即可</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        if (x==1) return 1;
        if (x==0) return 0;
        int l=0, r=x;
        while (l &lt; r) {
            int mid = l + (long long)r &gt;&gt; 1;
            if (mid &gt; x/mid)   r = mid;
            else l = mid + 1;
        }
        return l-1;
    }
};
</code></pre>
<h4 id="35-search-insert-position"><a href="https://leetcode.com/problems/search-insert-position/">35. Search Insert Position</a></h4>
<p>题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>
你可以假设数组中无重复元素。</p>
<p>分析：首先可二分的边界条件就是数组的大小，即[0, nums.size()]，我们确定的check条件是：nums[mid] &gt;= target，那就说明target在mid的左边，需要改变 右边界<code>r = mid</code>，如果nums[mid] &lt; target，就说明target在mid右边，需要改变左边界，<code>l = mid + 1</code>。当然check条件也可以改为nums[mid] &lt; target，这样区间更新策略换一下就行。</p>
<p>确定一下边界条件：如果数组为空，那么应该返回0；如果target&gt;nums.back()，返回数组的长度。</p>
<p>updata✅:该题实际上返回的是大于等于target的元素的索引</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty() || target &gt; nums.back()) return nums.size();
        int l=0, r = nums.size()-1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r=mid;
            else  l = mid+1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchInsert(self, nums: List[int], target: int) -&gt; int:
        if len(nums) == 0 or target &gt; nums[-1]:
            return len(nums)
        l = 0
        r = len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target:
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="34-find-first-and-last-position-of-element-in-sorted-array"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></h4>
<p>题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>
你的算法时间复杂度必须是 O(log n) 级别，如果数组中不存在目标值，返回 [-1, -1]。<br>
示例：</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
</code></pre>
<p>分析：因为要返回两个位置，所以应该要用两次二分法，一次返回开始位置的索引，一次返回结束位置的索引。首先是开始位置，nums[mid] &gt;= target，然后是结束位置，nums[mid] &lt;= target。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty()) return {-1, -1};
        int l =0, r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) return {-1, -1};
        int start = l;
        l = 0, r = nums.size() - 1;
        while(l &lt; r)
        {
            int mid = l + r  + 1 &gt;&gt; 1;
            if (nums[mid] &lt;= target) l = mid;
            else r = mid - 1;
        }
        int end = r;
        return {start, end};
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
        if len(nums) == 0: return [-1, -1]
        l, r = 0, len(nums)-1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target:
                r = mid
            else: l = mid + 1
        if nums[l] != target: return [-1, -1]
        else: start = l
        l, r = 0, len(nums)-1
        while l &lt; r:
            mid = l + r + 1 &gt;&gt; 1
            if nums[mid] &lt;= target:
                l = mid
            else: r = mid - 1
        end = r
        return [start, end]
</code></pre>
<h4 id="74-search-a-2d-matrix"><a href="https://leetcode.com/problems/search-a-2d-matrix/">74. Search a 2D Matrix</a></h4>
<p>题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。<br>
示例：</li>
</ul>
<pre><code>输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true
</code></pre>
<p>分析：如果展成一列的话，那么是单调递增的，这样就可以把整个空间分成两部分，check的性质是nums[mid] &gt;= target，需要了解到的是，数组的长度是：<code>n * m</code>(n为矩阵的行数，n为矩阵的列数)，然后还需要把mid还原为i和j，<code>i = mid // m</code>，<code>j = mid % m</code>。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) return false;
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = m * n - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (matrix[mid / m][mid % m] &gt;= target) r = mid;
            else l = mid + 1;
        }
        return matrix[r / m][r % m] == target;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        if len(matrix) == 0 or len(matrix[0]) == 0: return False
        n = len(matrix)
        m = len(matrix[0])
        l = 0
        r = m * n - 1
        while l &lt; r:
            mid  = l + r &gt;&gt; 1
            if matrix[mid // m][mid % m] &gt;= target:
                r = mid
            else: l = mid + 1
        return matrix[l // m][l % m] == target
</code></pre>
<h4 id="153-find-minimum-in-rotated-sorted-array"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></h4>
<p>题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
<code>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</code>请找出其中最小的元素，你可以假设数组中不存在重复元素。</p>
<p>分析：题目就是说把一个升序数组的一部分移到了数组的前面，如果用二分法来做的话，就首先应该找到一个二段性，可以把整个区间分成两部分。<br>
<img src="https://tudouvvv.github.io//post-images/1563356609008.png" alt=""><br>
如图，整个数组的分布相当于这个样子，我们想找的就是红色的这个点，判断的条件就是：<code>nums[mid] &lt;= nums.back()</code>，nums.back()就是蓝色的这个点，这样就把整个数组分成了两部分。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int l = 0, r = nums.size() - 1;
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt;= nums.back()) r = mid;
            else l = mid + 1;
        }
        return nums[r];
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findMin(self, nums: List[int]) -&gt; int:
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &lt;= nums[-1]:
                r = mid
            else: l = mid + 1
        return nums[l]
</code></pre>
<h4 id="33-search-in-rotated-sorted-array"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></h4>
<p>题目描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>
<code>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )</code><br>
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>
你可以假设数组中不存在重复的元素，你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>分析：虽然这道题没有明显的二分性，但是可以曲线救国，首先可以找到数组的最小值，把整个数组分成两块儿，然后再通过与<code>nums.back()</code>的比较来查看target是属于哪一块儿，再到该块儿进行二分。那第一步找到数组的最小值可以直接复用上一道题。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        if (nums.empty()) return -1;
        int l = 0, r = nums.size() - 1;
// 找到最小值的位置
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt;= nums.back()) r = mid;
            else l = mid + 1;
        }
// 判断target属于哪一块儿
        if (target &gt; nums.back()) l = 0, r --;
        else r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r + 1&gt;&gt; 1;
            if (nums[mid] &lt;= target) l = mid;
            else r = mid - 1;
        }
// 这里只能用l，因为如果整个数组是单调的，那么之前l=r=0
// 判断属于哪一块儿后r有可能变为-1，那么第二个while循环就不会执行
// 此时nums[r] = nums[-1]会越界
        if (nums[l] == target) return l;
        return -1;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def search(self, nums: List[int], target: int) -&gt; int:
        if not nums: return -1;
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &lt;= nums[-1]:
                r = mid
            else: l = mid + 1
        if target &gt; nums[-1]: 
            l = 0
            r -= 1
        else: r = len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt;= target: r = mid
            else: l = mid + 1
        if target == nums[l]: return l
        else: return -1
</code></pre>
<h4 id="278-first-bad-version"><a href="https://leetcode.com/problems/first-bad-version/">278. First Bad Version</a></h4>
<p>题目描述：你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。<br>
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。<br>
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<pre><code>示例：
给定 n = 5，并且 version = 4 是第一个错误的版本。
调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true
所以，4 是第一个错误的版本。 
</code></pre>
<p>分析：很明显这是一个二分的题目，因为就相当于这是一条时间线，从中间某个节点出现问题，那么就二分了，并且都不用去想二分的性质，因为题目已经给你提供了一个接口<code>isBadVersion</code>。<br>
C++</p>
<pre><code class="language-c++">// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int l = 0, r = n;
        while (l &lt; r)
        {
            int mid = (long long)l + r &gt;&gt; 1;  //测试的时候溢出了所以加了long long
            if (isBadVersion(mid)) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python"># The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        l, r = 0, n
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if isBadVersion(mid):
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="162-find-peak-element"><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a></h4>
<p>题目描述：峰值元素是指其值大于左右相邻值的元素。<br>
给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br>
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br>
你可以假设 nums[-1] = nums[n] = -∞。</p>
<p>分析：考虑二分的做法，不管怎么样，数组中一定是存在一个峰值的，我们比较nums[mid] 与 nums[mid+1]的关系，如果nums[mid] &lt; nums[mid+1]，那么二分的两段中，右边必存在峰值，就算一直递增，那么端点也算峰值；反之亦然。<br>
所以用二分的思想，必然会找到一个峰值。<br>
update✅:每次都砍掉小的那一边，这样保证另一边中一定存在一个比较大的值，这样不管是接下来递增还是递减就一定保证会有峰值。</p>
<p>C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int l = 0, r = nums.size() - 1;
        while(l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
						// 为什么不用判断mid+1是否越界呢，因为此时mid= n - 1的话
						// l = r = n - 1，没有进入while循环
            if (nums[mid] &gt; nums[mid+1]) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findPeakElement(self, nums: List[int]) -&gt; int:
        l, r = 0, len(nums) - 1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            if nums[mid] &gt; nums[mid+1]:
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="287-find-the-duplicate-number"><a href="https://leetcode.com/problems/find-the-duplicate-number/">287. Find the Duplicate Number</a></h4>
<p>题目描述：给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>
Note：</p>
<ul>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<p>分析：<br>
<code>抽屉原理</code>：假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。<br>
将整个数组二分为两半，则两边至少会有一边存在重复的数，两边分别拥有的数的个数是：L = mid - l +1 ，R = r - mid + 1，现在我们的区间是[1, n]，mid就是1---&gt;n中间的那个数，举例：nums = [1,3,4,2,2]，此时的区间为[1, 4]，n= 4, mid = 2，统计小于等于mid的数的个数：</p>
<pre><code>for num in nums:
    if num &lt;= mid: 
        cnt += 1
</code></pre>
<p>计算出来cnt = 3，然后来比较cnt与左边的数的个数，如果cnt &gt; L，说明<br>
重复的这个数就在左边(这里的左边是相对区间[1, 4]来说的)<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int l = 1, r = nums.size() - 1;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            int cnt = 0;
            for (auto num : nums)
                if (num &gt;=l &amp;&amp; num &lt;= mid) 
                    cnt++;
            if (cnt&gt;mid-l+1) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def findDuplicate(self, nums: List[int]) -&gt; int:
        l, r = 1, len(nums)-1
        while l &lt; r:
            mid = l + r &gt;&gt; 1
            cnt = 0
            for num in nums:
                if num &gt;= l and num &lt;= mid:
                    cnt += 1
            if cnt &gt; mid - l + 1:
                r = mid
            else: l = mid + 1
        return l
</code></pre>
<h4 id="275-h-index-ii"><a href="https://leetcode.com/problems/h-index-ii/">275. H-Index II</a></h4>
<p>题目描述：给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。<br>
h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）</p>
<p>分析：意思就是在一个数组中找到一个数h，使得数组中至少有h个数 &gt;= h。首先确定h的范围，h最大为n，最小为0，并且h是有二分性质的。如果h满足条件，那么h-1必然也满足...，所以小于&lt;=h的数满足答案，&gt;h的数不满足答案。用二分法找到h就行。<br>
C++</p>
<pre><code class="language-c++">class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        int l = 0, r = citations.size();
        while (l &lt; r)
        {
            int mid = l + r + 1 &gt;&gt; 1;
            if (citations[citations.size() - mid] &gt;= mid) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
</code></pre>
<p>Python</p>
<pre><code class="language-python">class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        l, r = 0, len(citations)
        while l &lt; r:
            mid = l + r +1 &gt;&gt; 1;
            if citations[len(citations) - mid] &gt;= mid:
                l = mid
            else: r = mid - 1;
        return l
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[每日一题]-942. DI String Match]]></title>
        <id>https://tudouvvv.github.io//post/942-DI-String-Match</id>
        <link href="https://tudouvvv.github.io//post/942-DI-String-Match">
        </link>
        <updated>2019-04-04T08:19:05.000Z</updated>
        <summary type="html"><![CDATA[<center>升 级 打 怪 ing ~ ~</center>]]></summary>
        <content type="html"><![CDATA[<center>升 级 打 怪 ing ~ ~</center>
<!--more-->
<p>题目地址：<a href="https://leetcode.com/problems/di-string-match/">942. DI String Match</a></p>
<p>题目要求：</p>
<p>输入一个字符串S，只包含I(increase)和D(decrease)，然后A是一个从0到len(S)的数组，现在要求如果S[i] == &quot;I&quot;，那么A[i] &lt; A[i+1]；如果S[i] == &quot;D&quot;，那么A[i] &gt; A[i+1]。</p>
<p>思路：</p>
<p>必须要为后面的操作留有余地，所以遇见I的时候，拿出最小的数保证剩余的数都比它大；遇见D的时候，拿出最大的数保证剩下的数都比它小。</p>
<center>----------------------</center>
<p>所以我的做法是：</p>
<pre><code class="language-python">class Solution:
    def diStringMatch(self, S: str) -&gt; List[int]:
        p = []
        N = []
        for i in range(len(S)+ 1):
            p.append(i)
        for char in S:
            if char == &quot;D&quot;:
                N.append(max(p))
                p.remove(max(p))
            else:
                N.append(min(p))
                p.remove(min(p))
        N.append(p[0])
        return N
</code></pre>
<p>先构建一个从0到len(S)的序列(现在看来很蠢)然后遍历S，遇见D取大的，遇见I取小的，最后再把剩下的数加进去</p>
<p>提交后果然，Time Limit Exceeded</p>
<p>去讨论区看一看，我为什么要新建一个数组？？？每次取的数都是最左边或者最右边的数，直接设置两个指针指向两边即可。</p>
<pre><code class="language-python">
class Solution:
    def diStringMatch(self, S: str) -&gt; List[int]:
        l, r, N = 0, len(S), []
        for char in S:
            N.append(l if char =='I' else r)
            l, r = l +(char == 'I'), r - (char == 'D')
        return N + [l]
</code></pre>
<p>基本上大家的思路都是这样，可能写法不太一样，像我这种写法就非常的臃肿-----</p>
]]></content>
    </entry>
</feed>